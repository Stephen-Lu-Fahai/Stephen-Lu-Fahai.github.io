{"meta":{"title":"StephenLu`s Blog","subtitle":"Embedded Software Engineering","description":"","author":"Stephen Lu","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-09-27T07:44:47.000Z","updated":"2022-09-27T07:45:37.738Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-27T07:44:42.000Z","updated":"2022-09-27T07:45:26.354Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"EGL无窗口FBO渲染记录","slug":"OpenGl/EGL无窗口FBO渲染记录","date":"2025-05-14T07:56:18.000Z","updated":"2025-05-14T08:41:33.051Z","comments":true,"path":"2025/05/14/OpenGl/EGL无窗口FBO渲染记录/","link":"","permalink":"http://example.com/2025/05/14/OpenGl/EGL%E6%97%A0%E7%AA%97%E5%8F%A3FBO%E6%B8%B2%E6%9F%93%E8%AE%B0%E5%BD%95/","excerpt":"","text":"一、前言在原先的概念中，无论是openGL还是EGL都是建议在X 或者wayland等窗口上实现的渲染。由于项目中需要动态插拔显示器，甚至要求系统启动后才接入显示器。 这就要求动态创建X或wayland等窗口系统。好在“nvidia显卡xorg多种配置方案” 这篇文章中已经解决了动态X创建的问题。接下来解决的是渲染的问题。 二、渲染方案方案1：使用cuda指针IPC这种方式已经在项目中使用，但是缺点也很明显。 缺点1：一个Cuda device的指针，一旦与openGL的PBO进行注册绑定，那么它将无法作为IPC共享指针。也就是说程序中要创建两个Dev指针，一个用于cuda-opengl-interop, 另一个用于进程间的IPC 缺点2：由缺点1衍生出来的问题，也就是主程序需要将openGL渲染后的场景(保存在pbo绑定的dev指针)，d2d拷贝到IPC的dev指针中； 同理，副程序需要将IPC指针中的场景，拷贝到自身PBO绑定的Dev指针(这样才能更新纹理)。 每多一个副程序，就会多两次d2d的cudaMemcpy，在显卡4个显示接口都用满的情况下，对系统性能是一个很大的考验。 方案2：进程间共享纹理具体：这个正是解决了方案1中多次d2d拷贝的问题。只需要在一个主程序中将纹理渲染好，接下来只需要把这个纹理共享出去即可。 更进一步的想法:考虑到设备使用过程中显示器会被动态插拔(尽管没有哪个人会这么丧心病狂使用设备)。 假设主程序运行在display=:1.0的X窗口上，副程序依次运行在:1.1 、:1.2等窗口上。 这时候如果被拔出的正好是:1.0窗口运行的显示器，这时候主程序就可能产生莫名其妙的问题。 最终确定:可以考虑EGL使用headless方式创建FBO离屏渲染，无需依赖X或Wayland窗口即可渲染出相应的场景。并且EGLImage还能将纹理共享出去。副程序直接获取纹理，绑定渲染即可。 这个方案目前已经实现，详情参考gitlab上的代码。 三、问题记录在上述方案2实现的过程中遇到一个非常有趣的问题，FBO渲染结束后，必须要用PBO将渲染的场景glReadPixel读取(尽管没有使用这个读取的结果)，否则副程序就会非常卡顿。 具体的原因还有待确定，这也是无意中解决副程序卡顿的问题。 最初的现象是：主程序渲染结束后，无论是否调用eglSwapBuffer，副程序渲染都会非常卡，画面几乎不动。 这时候想用PBO将渲染后的场景读取并录制成mp4，查看视频文件是否也卡顿。结果PBO读取后，副程序就非常流畅。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://example.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://example.com/tags/OpenGL/"}]},{"title":"nvidia显卡手动创建Wayland窗口配置","slug":"ubuntu/nvidia显卡手动创建Wayland窗口配置","date":"2025-04-15T07:02:19.000Z","updated":"2025-04-28T09:59:10.312Z","comments":true,"path":"2025/04/15/ubuntu/nvidia显卡手动创建Wayland窗口配置/","link":"","permalink":"http://example.com/2025/04/15/ubuntu/nvidia%E6%98%BE%E5%8D%A1%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BAWayland%E7%AA%97%E5%8F%A3%E9%85%8D%E7%BD%AE/","excerpt":"","text":"前提确认Nvida显卡的card12lufahai@ubuntu24:~$ ls /dev/dri/by-path card1 card2 renderD128 renderD129 可以看到系统中有card1 和 card2，分别对应intel集成显卡和nvidia显卡。进一步可以通过下面指令查看是否是nvidia显卡, 123lufahai@ubuntu24:~$ udevadm info -a /dev/dri/card2 | grep nvidia输出： DRIVERS==&quot;nvidia&quot; nvidia显卡需开启modeset先验证： 12sudo cat /sys/module/nvidia_drm/parameters/modeset输出: N 代表当前显卡并未开启modeset设置，在这种情况下对Nvidia显卡启动weston，会提示错误： 1ERROR: DRM device &#x27;card2&#x27; is not a KMS device 解决： 1234567sudo nano /etc/default/grub修改cmdline并保存退出:GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash nvidia-drm.modeset=1 nvidia-drm.fbdev=1&quot;sudo update-grubsudo reboot 重启后重新查询&#x2F;sys&#x2F;…&#x2F;modeset,这回输出Y 创建配置文件weston.ini 12345678[core]backend=drm-backend.sorequire-input=false[output]name=HDMI-A-1mode=3840x2160transform=normal 额外资料：根据nvidia文档描述，weston启动时会从如下地方一次搜索weston.ini配置文件https://developer.nvidia.com/docs/drive/drive-os/6.0.9/public/drive-os-linux-sdk/common/topics/window_system_stub/WestonConfigurationFileLocation40.html 1234567891011121314If $XDG_CONFIG_HOME is set, Weston searches in: $XDG_CONFIG_HOME/weston.iniIf $HOME is set, Weston searches in: $HOME/.config/weston.iniIf $XDG_CONFIG_DIRS is set, Weston searches in: $XDG_CONFIG_DIR/weston/weston.iniIf $XDG_CONFIG_DIRS is not set, Weston searches in: /etc/xdg/weston/weston.iniIf no variables are set, Weston searches in: &lt;current dir&gt;/weston.iniWhere the environment variable:$HOME is your home directory.$XDG_CONFIG_HOME is your specific configuration directory.$XDG_CONFIG_DIRS is a colon &#x27;:&#x27; delimited list of configuration base directories, such as /etc/xdg-foo:/etc/xdg. 启动需要指定XDG_RUNTIME_DIR目录， 启动脚本如下： 123mkdir -p /tmp/.xdg &amp;&amp; chmod 0700 /tmp/.xdgexport XDG_RUNTIME_DIR=/tmp/.xdgweston --drm-device=card2 --renderer=gl 在tty console终端可以直接启动，不需要sudo权限，即便是nvidia显卡连接了多个显示器，所有已连接的显示器都会创建weston窗口，并且是扩展的方式，鼠标可以在显示器之间的窗口滑动。 进一步理解drm与weston实例对应关系一个GPU(intel核显 或 Nvidia显卡)，只能对应地以drm backend方式创建一个weston示例。因为每个GPU对应的是&#x2F;dev&#x2F;dri 目录下的一个card，创建weston的时候通过–drm-device&#x3D;card2 指定使用那个GPU。因此之前的想法：针对显卡的多个显示器创建多个Weston的想法是不对的。 同一个drm card下的多个显示器异显主要参考： https://www.toradex.com/zh-cn/blog/verdin-imx8m-plus-qt5-shuang-ping-xian-shi?srsltid=AfmBOopge_L04NM4Do79U6DuOSF2TTrNhI4iI_KsGCay0LvYmRwHmSki 配置1234567891011121314151617[core]idle-time=0 xwayland=truerepaint-window=16modules=screen-share.soshell=kiosk-shell.so[output]name=HDMI-A-1app-ids=Qt5_CinematicExperiencemode=1920x1080[output]name=HDMI-A-2app-ids=smarthomemode=1920x1080 说明app-ids 只能在kiosk下生效，默认的desktop不生效。并且app-ids 不一定就是可执行文件名查找方式如下： 123WAYLAND_DEBUG=1 ./smarthome 2&gt;&amp;1 | grep app输出的字符串就是app-ids：[2173895.185] -&gt; xdg_toplevel@21.set_app_id(&quot;smarthome&quot;) 局限在nvidia显卡上暂时还测试不出来，参考文章用的是Arm板子 进展250428使用kiosk方式创建窗口后，EGL程序通过下面指定，EGL就能通过supervisor在显示器上渲染。mWlDisplay &#x3D; wl_display_connect(“wayland-1”); 但，双屏下还是合并的。 可以进一步研究通过配置不同的seat，从而启动多个Weston,这样就有多个wayland-x, 这样每个渲染程序就能对应找到自己需要渲染的显示器。","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"opencl引入主机内存字节对齐问题","slug":"openCL/opencl引入主机内存字节对齐问题","date":"2025-04-08T01:21:47.000Z","updated":"2025-04-17T07:48:10.213Z","comments":true,"path":"2025/04/08/openCL/opencl引入主机内存字节对齐问题/","link":"","permalink":"http://example.com/2025/04/08/openCL/opencl%E5%BC%95%E5%85%A5%E4%B8%BB%E6%9C%BA%E5%86%85%E5%AD%98%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/","excerpt":"","text":"主机内存拷贝到openCL内存方式1：定义cl_mem的时候设置Flag | CL_MEM_ALLOC_HOST_PTR 12size_t size = mWidth * mHeight * 4;cl_mem srcBuf = clCreateBuffer(mContext, CL_MEM_READ_ONLY | CL_MEM_ALLOC_HOST_PTR, size, NULL, &amp;err); 这样主机内存拷贝到opencl内存的时候就可以使用map方式： 12345void *srcPtr = clEnqueueMapBuffer(mQueue, srcBuf, CL_FALSE, CL_MAP_WRITE, 0, size, 0, 0, 0, 0);if (srcPtr) &#123; memcpy(srcPtr, *buf, size); clEnqueueUnmapMemObject(mQueue, srcBuf, srcPtr, 0, 0, 0);&#125; 这种方式比直接写的方式效率更高。 1enqueueWriteBuffer(*mBufSrc, CL_FALSE, 0, mImgHalfSize, mVecSrc.data()); 方式2：openCL直接引入主机内存可以避免上步骤的内存拷贝前提是要查询openCL是否支持引入host内存的扩展。 12345cl_arm_import_memory cl_arm_import_memory_dma_buf cl_arm_import_memory_host cl_arm_import_memory_protected cl_arm_import_memory_android_hardware_buffer 测试1 123456789101112size_t imgSize = mImgWidth * mImgHeight * 3 / 2;unsigned char* imgBuf = malloc(imgSize);const cl_import_properties_arm importProperties[] = &#123; CL_IMPORT_TYPE_ARM, CL_IMPORT_TYPE_HOST_ARM, 0&#125;;cl_int imRet = CL_SUCCESS;cl_mem mSrcBuf = clImportMemoryARM(mContext, CL_MEM_READ_WRITE, importProperties, imgBuf, imgSize, &amp;imRet);if (imRet != CL_SUCCESS) &#123; qDebug() &lt;&lt; &quot;failed to import host memory: &quot; &lt;&lt; imRet;&#125; 此时程序返回的是-6，具体意思是out of host memory. 解决参考 1https://stackoverflow.com/questions/78786585/climportmemoryarm-opencl-sometime-return-error-6 简单来说就是内存对齐问题，直接通过malloc申请的内存无法保证内存字节对齐。解决如下： 12345678910111213/* arm64 OS */size_t imgSize = mImgWidth * mImgHeight * 3 / 2;posix_memalign((void**)&amp;imgBuf, 64, imgSize);const cl_import_properties_arm importProperties[] = &#123; CL_IMPORT_TYPE_ARM, CL_IMPORT_TYPE_HOST_ARM, 0&#125;;cl_int imRet = CL_SUCCESS;cl_mem mSrcBuf = clImportMemoryARM(mContext, CL_MEM_READ_WRITE, importProperties, imgBuf, imgSize, &amp;imRet);if (imRet != CL_SUCCESS) &#123; qDebug() &lt;&lt; &quot;failed to import host memory: &quot; &lt;&lt; imRet;&#125; 参考资料https://registry.khronos.org/OpenCL/extensions/arm/cl_arm_import_memory.txt 结论在arm平台上使用import host的方式，效率最高，因为第一种方式还要map才能复制。但是就一般性而言，第一种方式对其他平台兼容性更好。","categories":[{"name":"openCL","slug":"openCL","permalink":"http://example.com/categories/openCL/"}],"tags":[{"name":"openCL","slug":"openCL","permalink":"http://example.com/tags/openCL/"}]},{"title":"ubuntu24解决chrome-sandbox权限导致app无法启动问题","slug":"ubuntu/ubuntu24解决chrome-sandbox权限导致app无法启动问题","date":"2025-04-02T03:19:51.000Z","updated":"2025-04-02T03:23:59.723Z","comments":true,"path":"2025/04/02/ubuntu/ubuntu24解决chrome-sandbox权限导致app无法启动问题/","link":"","permalink":"http://example.com/2025/04/02/ubuntu/ubuntu24%E8%A7%A3%E5%86%B3chrome-sandbox%E6%9D%83%E9%99%90%E5%AF%BC%E8%87%B4app%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题来源安装了新版本的ubuntu24，之前的clash软件启动后提示 1[42711:0402/111553.491149:FATAL:setuid_sandbox_host.cc(157)] The SUID sandbox helper binary was found, but is not configured correctly. Rather than run without sandboxing I&#x27;m aborting now. You need to make sure that /opt/clash/chrome-sandbox is owned by root and has mode 4755. 程序无法启动。 解决根据提示先chown再chmod，分两步进行，但不生效。最后发现要&amp;&amp;并作一条指令才生效，令人匪夷所思。 正解如下： 1sudo chown root /opt/clash/chrome-sandbox &amp;&amp; sudo chmod 4755 /opt/clash/chrome-sandbox","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"Linux打印机使用总结","slug":"ubuntu/Linux打印机使用总结","date":"2025-04-01T08:59:42.000Z","updated":"2025-04-02T09:32:36.066Z","comments":true,"path":"2025/04/01/ubuntu/Linux打印机使用总结/","link":"","permalink":"http://example.com/2025/04/01/ubuntu/Linux%E6%89%93%E5%8D%B0%E6%9C%BA%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"图形界面使用直接在设置页面添加即可。 命令行配合Qt程序使用查找打印机打印机使用USB方式连接到电脑，通过以下命令查询，注意加sudo权限 1234567891011stephen@localhost:~$ sudo lpinfo -vfile cups-brf:/network behnetwork socketnetwork ippnetwork httpnetwork httpsnetwork lpdnetwork ippsserial serial:/dev/ttyS0?baud=115200direct usb://HP/LaserJet%20M203-M206?serial=VNC3J55865 最后一个usb:&#x2F;&#x2F;HP…就是USB连接的惠普打印机。 增加打印机1sudo lpadmin -p HP_LaserJet -v usb://HP/LaserJet%20M203-M206?serial=VNC3J55865 -E -p 后面是自定义的打印机名称-v 后面是上一步查看到的地址 这时候使用下面指令就可以查看到已经添加的打印机了 1sudo lpstat -v 设置为默认1sudo lpadmin -d HP_LaserJet 测试1lp a.pdf -d HP_LaserJet 可以打印，但不知道为什么，上一步设为默认打印机后，使用lp指令要-d指定打印机，否则打印失败。但是对于Qt程序可以直接识别到上步设置的默认打印机，因此没太纠结。 Qt参考程序123456789QPrinter printerPixmap;QPixmap pixmap = QPixmap::grabWidget(ui-&gt;lab_img, ui-&gt;lab_img-&gt;rect()); //获取界面的图片printerPixmap.setOrientation(QPrinter::Landscape);//纵向：Portrait 横向：LandscapeprinterPixmap.setPageSize(QPrinter::A4);//设置纸张大小QPainter painterPixmap;painterPixmap.begin(&amp;printerPixmap);painterPixmap.scale(1, 1);//设置图像长宽是原图的多少倍painterPixmap.drawPixmap(300, 300 , pixmap);//设置图像在A4中的开始坐标是什么painterPixmap.end();","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"关于armLinux openCL与EGL互操作的探究--基于rockchip","slug":"armLinux/关于armLinux-openCL与EGL互操作的探究-基于rockchip","date":"2025-03-28T08:45:16.000Z","updated":"2025-04-08T09:06:22.028Z","comments":true,"path":"2025/03/28/armLinux/关于armLinux-openCL与EGL互操作的探究-基于rockchip/","link":"","permalink":"http://example.com/2025/03/28/armLinux/%E5%85%B3%E4%BA%8EarmLinux-openCL%E4%B8%8EEGL%E4%BA%92%E6%93%8D%E4%BD%9C%E7%9A%84%E6%8E%A2%E7%A9%B6-%E5%9F%BA%E4%BA%8Erockchip/","excerpt":"","text":"背景希望在Linux环境下使用mali GPU来对图像进行处理及显示，主要包括三个方面：1、图像采集；2、图像处理；3、图像显示。其中1和3都已被优化解决，唯独2暂时没优化到最理想的效果。 过程图像采集可以使用mjpg硬件解码，可以获得高分辨下的较高帧率，基本满足。图像渲染可以用openGL渲染，但考虑到交互和移植问题，使用了EGL渲染，不依赖X11或wayland,渲染效率更高。 图像处理使用的是openCL，可以很好的完成基本的图像处理。但目前瓶颈在于图像需要从CPU拷贝到GPU，最后再拷贝会CPU交给EGL渲染。虽说做了一次优化：使用openCL定义buf的时候直接使用host memory的指针，即zero-copy，最后再交由egl渲染。 效果还不错。 方案1：不依赖任何图形界面，直接由Qt集成的opengl进行渲染，获得的视频数据直接gliamge2d交给openGL去渲染。唯一的不足是后期的处理全靠glsl实现。在rk3566上测试效果还是很不错的。 方案2：在wayland界面下使用dmabuf作为桥梁，可以实现EGL创建一个eglImage, 然后opencl利用这个eglImage创建出关联的oclImage, 测试中发现oclImage只能对EGLimage内存进行写入操作，而无法读取。也就是这个oclImage传给kernel时只能声明为 __write_only image2d_t的方式。opencl对image进行写入后，EGL也会被同样修改，随后egl就可以直接渲染，没有任何拷贝。 但是从eglImage到oclImage仍存在一个问题，只能写入不能读取，即eglImage只能作为目标输出dstPtr.为了解决视频流输出的问题，arm提供了opencl引入host内存的扩展: clImportMemoryARM。也就是存有图像数据的hostMem可以直接给opencl使用，避免了内存拷贝问题。 至此彻底解决内存拷贝问题。但是！但是！但是！ 在wayland环境下实时渲染一个1080P的视频图像，延迟达到好几秒，而方案一几乎感受不到明显的延迟。 这并不一定是EGL渲染的问题，由可能跟wayland配置也由关系等。还需进一步优化。 old：但还有另外一种方案暂时未实现，值得去研究。hostMem –&gt; dmaBuf –&gt; opencl_image –&gt; EGL具体实现过程为EGL使用eglCreateImageKHR 创建一个openCL可以获取到的图像对象。openCL直接对图像进行处理后，EGL直接渲染出来。这个过程涉及到dmaBuf的拷贝。 主要参考，特别要注意一些Linux环境下使用的细节https://registry.khronos.org/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import.txt","categories":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/categories/armLinux/"}],"tags":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/tags/armLinux/"}]},{"title":"openGL纹理间拷贝纹理的两种方式","slug":"OpenGl/openGL纹理间拷贝纹理的两种方式","date":"2025-03-25T09:44:47.000Z","updated":"2025-03-25T09:51:39.334Z","comments":true,"path":"2025/03/25/OpenGl/openGL纹理间拷贝纹理的两种方式/","link":"","permalink":"http://example.com/2025/03/25/OpenGl/openGL%E7%BA%B9%E7%90%86%E9%97%B4%E6%8B%B7%E8%B4%9D%E7%BA%B9%E7%90%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"一、方法1：先下载再贴图123456789unsigned char * data = new unsigned char[normal_texture.width*normal_texture.height*4];glBindTexture(GL_TEXTURE_2D, src_id); // 绑定 src_idglGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_UNSIGNED_BYTE, data); // 下载到 dataglBindTexture(GL_TEXTURE_2D, dest_id); // 绑定 dest_idglTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, data); // 上传glBindTexture(GL_TEXTURE_2D, 0); 二、方法2：使用FBO12345678910111213GLuint fbo;glGenFramebuffers(1, &amp;fbo);// bind the FBOglBindFramebuffer(GL_READ_FRAMEBUFFER, fbo); // 绑定 FBO// attach the source texture to the fboglFramebufferTexture2D(GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, src_id, 0); // 绑定纹理到 FBO// bind the destination textureglBindTexture(GL_TEXTURE_2D, dest_id); // 绑定 dest_id// copy from framebuffer (here, the FBO!) to the bound textureglCopyTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 0, 0, width, height); // 从 FBO 直接拷贝到 dest_idglBindTexture(GL_TEXTURE_2D, 0);// unbind the FBOglBindFramebuffer(GL_FRAMEBUFFER, 0); 扩展：对比PBO使用pbo可以快速保存整个渲染场景而不是一个纹理数据，PBO与cuda的互操作可以让cuda直接获取到device内存上的openGL渲染图像。如果不依赖cuda的话，应该也可以使用PBO作为中转，将渲染场景拷贝到某个目标纹理。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://example.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://example.com/tags/OpenGL/"}]},{"title":"ISP pipeline之mipi与raw10数据的压缩与解包","slug":"cameraIsp/ISP-pipeline之mipi与raw10数据的压缩与解包","date":"2025-03-07T02:55:25.000Z","updated":"2025-03-07T05:28:53.904Z","comments":true,"path":"2025/03/07/cameraIsp/ISP-pipeline之mipi与raw10数据的压缩与解包/","link":"","permalink":"http://example.com/2025/03/07/cameraIsp/ISP-pipeline%E4%B9%8Bmipi%E4%B8%8Eraw10%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8C%85/","excerpt":"","text":"Raw10数据概述raw10用5 * 8 Byte表示4 * 10格式的像素，raw12用3 * 8个byte表示2 * 12格式的像素raw14用7 * 8个byte表示4 * 14格式的像素 mipi数据解压到raw10C++代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//raw14 b1,b2,b3,b4,b5,b6,b7分别为连续读出的七个uint8类型的数据,p1,p2,p3,p4为四个像素点的像素值,那么for(int i=0;i&lt;file_len;i+=7)&#123; unsigned char* b = buffer + i; unsigned char b1 = b[0]; unsigned char b2 = b[1]; unsigned char b3 = b[2]; unsigned char b4 = b[3]; unsigned char b5 = b[4]; unsigned char b6 = b[5]; unsigned char b7 = b[6]; unsigned short p1 = (b1 &lt;&lt; 6) | (b5 &amp; 0x3f); unsigned short p2 = (b2 &lt;&lt; 6) | (((b5 &gt;&gt; 6) &amp; 0x3) &lt;&lt; 4) | (b6 &amp; 0xf); unsigned short p3 = (b3 &lt;&lt; 6) | (((b6 &gt;&gt; 4) &amp; 0xf) &lt;&lt; 2) | (b7 &amp; 0x3); unsigned short p4 = (b4 &lt;&lt; 6) | ((b7 &gt;&gt; 2) &amp; 0x3f); fwrite(&amp;p1, 2, 1, fp2); fwrite(&amp;p2, 2, 1, fp2); fwrite(&amp;p3, 2, 1, fp2); fwrite(&amp;p4, 2, 1, fp2);&#125;//raw12 b1,b2,b3分别为连续读出的三个uint8类型的数据，p1,p2为两个个像素点的像素值，那么for(int i=0;i&lt;file_len;i+=3)&#123; unsigned char* b = buffer + i; unsigned char b1 = b[0]; unsigned char b2 = b[1]; unsigned char b3 = b[2]; unsigned short p1 = (b1 &lt;&lt; 4) | ((b3 ) &amp; 0xf); unsigned short p2 = (b2 &lt;&lt; 4) | ((b3 &gt;&gt; 4) &amp; 0xf); //printf(&quot;%d,%d,%d,%d\\n&quot;, p1, p2, p3, p4); fwrite(&amp;p1, 2, 1, fp2); fwrite(&amp;p2, 2, 1, fp2);&#125;//raw10 b1,b2,b3,b4,b5分别为连续读出的五个uint8类型的数据，p1,p2,p3,p4为四个像素点的像素值，那么for (int i=0;i&lt;file_len;i+=5)&#123; unsigned char*b = buffer + i; unsigned char b1 = b[0]; unsigned char b2 = b[1]; unsigned char b3 = b[2]; unsigned char b4 = b[3]; unsigned char b5 = b[4]; unsigned short p1 = (b1 &lt;&lt; 2) | ((b5) &amp; 0x3); unsigned short p2 = (b2 &lt;&lt; 2) | ((b5 &gt;&gt; 2) &amp; 0x3); unsigned short p3 = (b3 &lt;&lt; 2) | ((b5 &gt;&gt; 4) &amp; 0x3); unsigned short p4 = (b4 &lt;&lt; 2) | ((b5 &gt;&gt; 6) &amp; 0x3); //printf(&quot;%d,%d,%d,%d\\n&quot;, p1, p2, p3, p4); fwrite(&amp;p1, 2, 1, fp2); fwrite(&amp;p2, 2, 1, fp2); fwrite(&amp;p3, 2, 1, fp2); fwrite(&amp;p4, 2, 1, fp2);&#125; cuda代码实现根据上面的思路，只需要前4byte各自和第五byte各自的位拼接即可 1234567891011121314151617181920212223242526272829303132333435363738__global__ void cuUnpackMipiRaw10Knl(unsigned char* pSrc, unsigned short* pDst, short iGainOffset, long iLen)&#123; int dx = blockIdx.x * blockDim.x + threadIdx.x; if (dx &gt;= iLen) return; int dxdiv4 = dx &gt;&gt; 2; // base index int xb = dxdiv4 * 5; // offset index int xo = dx - (dxdiv4 &lt;&lt; 2); //这样x取值为 0 1 2 3 5 6 7 8 10 11 12 13 15 //恰好能避开每个base的5th byte，而5th byte则可以通过xb + 4下标获取 //这个方法就很巧妙 int x = dxdiv4 + dx; unsigned short h8val = pSrc[x]; h8val = h8val &lt;&lt; 2; unsigned short l2val = pSrc[xb + 4]; l2val = l2val &gt;&gt; (xo * 2); l2val = l2val &amp; 0x0003; int a = h8val | l2val; a = a + iGainOffset; if (a &lt; 0) a = 0; // a 10bit data in a 16bit container, it is safe pDst[dx] = a;&#125;extern &quot;C&quot; void UnpackMipiRaw10(unsigned char* pSrc, unsigned short* pDst, short iGainOffset, long iLen)&#123; dim3 numThreads(128); dim3 numBlocks(DivUp(iLen, numThreads.x)); cuUnpackMipiRaw10Knl&lt;&lt;&lt;numBlocks, numThreads &gt;&gt;&gt;(pSrc, pDst, iGainOffset, iLen);&#125; raw10数据压缩到mipi1234567891011121314151617181920212223242526272829303132__global__ void cuBayerRaw2Mipi(unsigned short* pSrc, unsigned char* pDst, long iLen)&#123; int dx = blockIdx.x * blockDim.x + threadIdx.x; if (dx &gt;= iLen) return; unsigned short v[4]; v[0] = pSrc[dx * 4]; v[1] = pSrc[dx * 4 + 1]; v[2] = pSrc[dx * 4 + 2]; v[3] = pSrc[dx * 4 + 3]; int iDstIdx = dx * 5; pDst[iDstIdx] = static_cast&lt;unsigned char&gt;(v[0] &gt;&gt; 2); pDst[iDstIdx + 1] = static_cast&lt;unsigned char&gt;(v[1] &gt;&gt; 2); pDst[iDstIdx + 2] = static_cast&lt;unsigned char&gt;(v[2] &gt;&gt; 2); pDst[iDstIdx + 3] = static_cast&lt;unsigned char&gt;(v[3] &gt;&gt; 2); v[0] = v[0] &amp; 3; v[1] = (v[1] &lt;&lt; 2) &amp; 12; v[2] = (v[2] &lt;&lt; 4) &amp; 48; v[3] = (v[3] &lt;&lt; 6) &amp; 192; pDst[iDstIdx + 4] = static_cast&lt;unsigned char&gt;(v[0] | v[1] | v[2] | v[3]);&#125;extern &quot;C&quot;void BayerRaw2Mipi(unsigned short* pSrc, unsigned char* pDst, long iLen)&#123; dim3 numThreads(128); dim3 numBlocks(DivUp(iLen, numThreads.x)); cuBayerRaw2Mipi&lt;&lt;&lt;numBlocks, numThreads &gt;&gt;&gt;(pSrc, pDst, iLen); checkCudaErrors(cudaDeviceSynchronize());&#125;","categories":[{"name":"ISP","slug":"ISP","permalink":"http://example.com/categories/ISP/"}],"tags":[{"name":"ISP","slug":"ISP","permalink":"http://example.com/tags/ISP/"}]},{"title":"ISP pipeline之DPC","slug":"cameraIsp/ISP-pipeline之DPC","date":"2025-02-27T02:56:05.000Z","updated":"2025-03-07T05:57:11.503Z","comments":true,"path":"2025/02/27/cameraIsp/ISP-pipeline之DPC/","link":"","permalink":"http://example.com/2025/02/27/cameraIsp/ISP-pipeline%E4%B9%8BDPC/","excerpt":"","text":"DPC概述由于sensor制造工艺技术瑕疵或光线采集存在缺陷，获得的原始图像数据就存在一些坏点，一般是某个邻域内的极亮或极暗点。 DPC矫正原理一般以一个5x5的邻域作为检测区域，并且常用梯度法进行检测。 如上图所示，Pc作为被检测点，步骤如下：1、先算出4个方向的二阶梯度： 水平方向：Dh1 &#x3D; |P1+P3-2P2|, Dh2 &#x3D; |P4+P5-2Pc|,Dh3 &#x3D; |P6+P8-2P7|; 竖直方向：Dv1 &#x3D; |P1+P6-2P4|, Dv2 &#x3D; |P2+P7-2Pc|,Dv3 &#x3D; |P3+P8-2P5|; 45°方向： D45_1 &#x3D; 2*|P4-P2|, D45_2 &#x3D;|P3+P6-2Pc|, D45_3 &#x3D; 2|P7-P5|; 135°方向：D135_1 &#x3D; 2*|P2-P5|, D135_2 &#x3D;|P1+P8-2Pc|, D135_3 &#x3D; 2|P7-P4|; 2、求取各方向梯度绝对值的中值。 3、选取四个方向中值的最小值作为边缘方向。 4、如果最小梯度方向为水平或者竖直，若过Pc那个梯度的绝对值大于同方向的另外两个梯度绝对值和的4倍，则Pc为坏点； 5、如果是45°方向，则计算135°三个梯度绝对值两两之差的绝对值的和， D135_sum &#x3D; |D135_1 - D135_2| + |D135_1 - D135_3| + |D135_2 - D135_3|; 如果D135_sum小于100，若此时D45_2 &gt; 3x(D45_1+D45_3) 且 D135_2&gt;3x(D135_1+D135_3)，则Pc为坏点。否则D45_2&gt;3x(D45_1+D45_3)就为坏点； 6、135°方向和45°相反的方向计算和判断即可； 7、为减少漏判，当Pc小于15且周围点都大于Pc40以上，则Pc为坏点。如果Pc大于230，且周围的点都下于Pc30以下，则该点为坏点； 8、边缘为水平方向，且判断为坏点，如过|P4-Pc|&lt;|Pc-P5|则Pc更靠近P4，根据同一颜色通道亮度的渐变性可以推导出ouput&#x3D;P4+(P2+P7-P1-P6)&#x2F;2; 否则ouput&#x3D;P5+(P2+P7-P3-P8)&#x2F;2； 9、如果为竖直方向可以参考水平方向求出。 10、边缘为45°，如果|P3-Pc|&lt;|P6-Pc|则根据同一原则output&#x3D;P3+(P4+P7-P2-p5)&#x2F;2;否则为output&#x3D;P7+(P2+P5-P7-p3)&#x2F;2； 11、边缘为135°则按照45°的方式反过来计算即可。 cuda代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936__global__ void cuDeadPixelCorrectionBGGR(unsigned short *pSrc, unsigned short *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride, unsigned short iThreshold)&#123; int dx = blockIdx.x * blockDim.x + threadIdx.x; int dy = blockIdx.y * blockDim.y + threadIdx.y; //if (dx &gt;= iWidth || dy &gt;= iHeight) //&#123; // return; //&#125; int lx = threadIdx.x; int ly = threadIdx.y; int bx = threadIdx.y * blockDim.x + threadIdx.x; // twice of half filter length plus local size int iBlockLen = 4 + DEMOSAIC_LOCAL_SIZE; // the offset at the start of the row int iLocalRowStartIdx = (ly + 2) * iBlockLen; // index to the current pixel int iLocalIdx = iLocalRowStartIdx + lx + 2; if (dx &lt; iWidth and dy &lt; iHeight) &#123; cached[iLocalIdx] = pSrc[dy * iSrcStride + dx]; // copy additional data for boarder if (lx &lt; 2) &#123; int iSrcX = dx - 2; if (iSrcX &lt; 0) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[iLocalRowStartIdx + lx] = pSrc[dy * iSrcStride + iSrcX]; if (dy &gt;= iHeight - 2) &#123; int iSrcY = dy + 2; if (iSrcY &gt;= iHeight) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[(ly + 4) * iBlockLen + lx] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; &#125; else if (lx &gt;= (DEMOSAIC_LOCAL_SIZE - 2)) &#123; int iSrcX = dx + 2; if (iSrcX &gt;= iWidth) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[iLocalIdx + 2] = pSrc[dy * iSrcStride + iSrcX]; if (dy &gt;= iHeight - 2) &#123; int iSrcY = dy + 2; if (iSrcY &gt;= iHeight) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[(ly + 4) * iBlockLen + lx + 4] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; &#125; if (ly &lt; 2) &#123; int iSrcY = dy - 2; if (iSrcY &lt; 0) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[ly * iBlockLen + lx + 2] = pSrc[iSrcY * iSrcStride + dx]; if (lx &lt; 2) &#123; int iSrcX = dx - 2; if (iSrcX &lt; 0) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[ly * iBlockLen + lx] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; else if (lx &gt;= (DEMOSAIC_LOCAL_SIZE - 2)) &#123; int iSrcX = dx + 2; if (iSrcX &gt;= iWidth) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[ly * iBlockLen + lx + 4] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; &#125; else if (ly &gt;= (DEMOSAIC_LOCAL_SIZE - 2)) &#123; int iSrcY = dy + 2; if (iSrcY &gt;= iHeight) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[(ly + 4) * iBlockLen + lx + 2] = pSrc[iSrcY * iSrcStride + dx]; if (lx &lt; 2) &#123; int iSrcX = dx - 2; if (iSrcX &lt; 0) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[(ly + 4) * iBlockLen + lx] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; else if (lx &gt;= (DEMOSAIC_LOCAL_SIZE - 2)) &#123; int iSrcX = dx + 2; if (iSrcX &gt;= iWidth) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[(ly + 4) * iBlockLen + lx + 4] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; &#125; else // the bottom of local box may not aligned with the bottom of the image &#123; if (dy &gt;= iHeight - 2) &#123; int iSrcY = dy + 2; if (iSrcY &gt;= iHeight) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[(ly + 4) * iBlockLen + lx + 2] = pSrc[iSrcY * iSrcStride + dx]; &#125; &#125; &#125; // sync __syncthreads(); unsigned short pixelNeig[8]; //&lt;@Aaron, G channel: if (bx &lt; 64)//&lt;G, this is a Green in the B row &#123; lx = (threadIdx.x/2)*2+1; ly = threadIdx.y*2 + (threadIdx.x%2)*8; dx = blockIdx.x * blockDim.x + lx; dy = blockIdx.y * blockDim.y + ly; // the offset at the start of the row iLocalRowStartIdx = (ly + 2) * iBlockLen; // index to the current pixel iLocalIdx = iLocalRowStartIdx + lx + 2; // this is a Green in the B row pixelNeig[0] = cached[iLocalIdx + -2 * iBlockLen + 0]; pixelNeig[1] = cached[iLocalIdx + -1 * iBlockLen + -1]; pixelNeig[2] = cached[iLocalIdx + -1 * iBlockLen + 1]; pixelNeig[3] = cached[iLocalIdx + 0 * iBlockLen + -2]; pixelNeig[4] = cached[iLocalIdx + 0 * iBlockLen + 2]; pixelNeig[5] = cached[iLocalIdx + 1 * iBlockLen + -1]; pixelNeig[6] = cached[iLocalIdx + 1 * iBlockLen + 1]; pixelNeig[7] = cached[iLocalIdx + 2 * iBlockLen + 0]; &#125; else if (bx &lt; 128)//&lt;G, this is a Green in the R row &#123; lx = (threadIdx.x/2)*2; ly = (threadIdx.y-4)*2 + (threadIdx.x%2)*8 + 1; dx = blockIdx.x * blockDim.x + lx; dy = blockIdx.y * blockDim.y + ly; // the offset at the start of the row iLocalRowStartIdx = (ly + 2) * iBlockLen; // index to the current pixel iLocalIdx = iLocalRowStartIdx + lx + 2; pixelNeig[0] = cached[iLocalIdx + -2 * iBlockLen + 0]; pixelNeig[1] = cached[iLocalIdx + -1 * iBlockLen + -1]; pixelNeig[2] = cached[iLocalIdx + -1 * iBlockLen + 1]; pixelNeig[3] = cached[iLocalIdx + 0 * iBlockLen + -2]; pixelNeig[4] = cached[iLocalIdx + 0 * iBlockLen + 2]; pixelNeig[5] = cached[iLocalIdx + 1 * iBlockLen + -1]; pixelNeig[6] = cached[iLocalIdx + 1 * iBlockLen + 1]; pixelNeig[7] = cached[iLocalIdx + 2 * iBlockLen + 0]; &#125; else if (bx &lt; 192)//&lt;B, &#123; lx = (threadIdx.x/2)*2; ly = (threadIdx.y-8)*2 + (threadIdx.x%2)*8; dx = blockIdx.x * blockDim.x + lx; dy = blockIdx.y * blockDim.y + ly; // the offset at the start of the row iLocalRowStartIdx = (ly + 2) * iBlockLen; // index to the current pixel iLocalIdx = iLocalRowStartIdx + lx + 2; pixelNeig[0] = cached[iLocalIdx + -2 * iBlockLen + -2]; pixelNeig[1] = cached[iLocalIdx + -2 * iBlockLen + 0]; pixelNeig[2] = cached[iLocalIdx + -2 * iBlockLen + 2]; pixelNeig[3] = cached[iLocalIdx + 0 * iBlockLen + -2]; pixelNeig[4] = cached[iLocalIdx + 0 * iBlockLen + 2]; pixelNeig[5] = cached[iLocalIdx + 2 * iBlockLen + -2]; pixelNeig[6] = cached[iLocalIdx + 2 * iBlockLen + 0]; pixelNeig[7] = cached[iLocalIdx + 2 * iBlockLen + 2]; &#125; else//&lt;R, &#123; lx = (threadIdx.x/2)*2 + 1; ly = (threadIdx.y-12)*2 + (threadIdx.x%2)*8 + 1; dx = blockIdx.x * blockDim.x + lx; dy = blockIdx.y * blockDim.y + ly; // the offset at the start of the row iLocalRowStartIdx = (ly + 2) * iBlockLen; // index to the current pixel iLocalIdx = iLocalRowStartIdx + lx + 2; pixelNeig[0] = cached[iLocalIdx + -2 * iBlockLen + -2]; pixelNeig[1] = cached[iLocalIdx + -2 * iBlockLen + 0]; pixelNeig[2] = cached[iLocalIdx + -2 * iBlockLen + 2]; pixelNeig[3] = cached[iLocalIdx + 0 * iBlockLen + -2]; pixelNeig[4] = cached[iLocalIdx + 0 * iBlockLen + 2]; pixelNeig[5] = cached[iLocalIdx + 2 * iBlockLen + -2]; pixelNeig[6] = cached[iLocalIdx + 2 * iBlockLen + 0]; pixelNeig[7] = cached[iLocalIdx + 2 * iBlockLen + 2]; &#125; unsigned short centerPixel = cached[iLocalIdx]; unsigned short medianV; int nConditionValue = 0; short pixelNeigDiff = 0; for (int i = 0; i &lt; 8; i++) &#123; pixelNeigDiff = (short)pixelNeig[i] - (short)centerPixel; if(pixelNeigDiff &gt; 0) &#123; nConditionValue += 1; &#125; if(pixelNeigDiff &lt; 0) &#123; nConditionValue -= 1; pixelNeigDiff = -pixelNeigDiff; &#125; if(pixelNeigDiff &lt;= iThreshold) &#123; break; &#125; if (abs(nConditionValue) &lt;= i) &#123; break; &#125; &#125; int iDstIdx = dy * iDstStride + dx; if (iDstIdx &gt;= iDstStride*iHeight) &#123; return; &#125; if (abs(nConditionValue) &lt; 8) &#123; pDst[iDstIdx] = centerPixel; &#125; else &#123; cuClassicMedianFilter(pixelNeig, 8, &amp;medianV); pDst[iDstIdx] = medianV; &#125;&#125;extern &quot;C&quot; void DeadPixelCorrectionBGGR(unsigned short* pSrc, unsigned short* pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride, unsigned short iThreshold)&#123; dim3 numThreads(16, 16, 1); // do not change, has to be 16 dim3 numBlocks(DivUp(iWidth, numThreads.x), DivUp(iHeight, numThreads.y)); cuDeadPixelCorrectionBGGR&lt;&lt;&lt;numBlocks, numThreads, 20 * 20 * sizeof(unsigned short)&gt;&gt;&gt;(pSrc, pDst, iWidth, iHeight, iSrcStride, iDstStride, iThreshold);&#125;__global__ void cuDeadPixelCorrectionRGGB(unsigned short *pSrc, unsigned short *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride, unsigned short iThreshold)&#123; int dx = blockIdx.x * blockDim.x + threadIdx.x; int dy = blockIdx.y * blockDim.y + threadIdx.y; //if (dx &gt;= iWidth || dy &gt;= iHeight) //&#123; // return; //&#125; int lx = threadIdx.x; int ly = threadIdx.y; int bx = threadIdx.y * blockDim.x + threadIdx.x; // twice of half filter length plus local size int iBlockLen = 4 + DEMOSAIC_LOCAL_SIZE; // the offset at the start of the row int iLocalRowStartIdx = (ly + 2) * iBlockLen; // index to the current pixel int iLocalIdx = iLocalRowStartIdx + lx + 2; if (dx &lt; iWidth and dy &lt; iHeight) &#123; cached[iLocalIdx] = pSrc[dy * iSrcStride + dx]; // copy additional data for border if (lx &lt; 2) &#123; int iSrcX = dx - 2; if (iSrcX &lt; 0) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[iLocalRowStartIdx + lx] = pSrc[dy * iSrcStride + iSrcX]; if (dy &gt;= iHeight - 2) &#123; int iSrcY = dy + 2; if (iSrcY &gt;= iHeight) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[(ly + 4) * iBlockLen + lx] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; &#125; else if (lx &gt;= (DEMOSAIC_LOCAL_SIZE - 2)) &#123; int iSrcX = dx + 2; if (iSrcX &gt;= iWidth) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[iLocalIdx + 2] = pSrc[dy * iSrcStride + iSrcX]; if (dy &gt;= iHeight - 2) &#123; int iSrcY = dy + 2; if (iSrcY &gt;= iHeight) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[(ly + 4) * iBlockLen + lx + 4] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; &#125; if (ly &lt; 2) &#123; int iSrcY = dy - 2; if (iSrcY &lt; 0) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[ly * iBlockLen + lx + 2] = pSrc[iSrcY * iSrcStride + dx]; if (lx &lt; 2) &#123; int iSrcX = dx - 2; if (iSrcX &lt; 0) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[ly * iBlockLen + lx] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; else if (lx &gt;= (DEMOSAIC_LOCAL_SIZE - 2)) &#123; int iSrcX = dx + 2; if (iSrcX &gt;= iWidth) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[ly * iBlockLen + lx + 4] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; &#125; else if (ly &gt;= (DEMOSAIC_LOCAL_SIZE - 2)) &#123; int iSrcY = dy + 2; if (iSrcY &gt;= iHeight) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[(ly + 4) * iBlockLen + lx + 2] = pSrc[iSrcY * iSrcStride + dx]; if (lx &lt; 2) &#123; int iSrcX = dx - 2; if (iSrcX &lt; 0) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[(ly + 4) * iBlockLen + lx] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; else if (lx &gt;= (DEMOSAIC_LOCAL_SIZE - 2)) &#123; int iSrcX = dx + 2; if (iSrcX &gt;= iWidth) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[(ly + 4) * iBlockLen + lx + 4] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; &#125; else // the bottom of local box may not aligned with the bottom of the image &#123; if (dy &gt;= iHeight - 2) &#123; int iSrcY = dy + 2; if (iSrcY &gt;= iHeight) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[(ly + 4) * iBlockLen + lx + 2] = pSrc[iSrcY * iSrcStride + dx]; &#125; &#125; &#125; // sync __syncthreads(); unsigned short pixelNeig[8]; //&lt;@Aaron, G channel: if (bx &lt; 64)//&lt;G, this is a Green in the B row &#123; lx = (threadIdx.x/2)*2; ly = threadIdx.y*2 + (threadIdx.x%2)*8 + 1; dx = blockIdx.x * blockDim.x + lx; dy = blockIdx.y * blockDim.y + ly; // the offset at the start of the row iLocalRowStartIdx = (ly + 2) * iBlockLen; // index to the current pixel iLocalIdx = iLocalRowStartIdx + lx + 2; // this is a Green in the B row pixelNeig[0] = cached[iLocalIdx + -2 * iBlockLen + 0]; pixelNeig[1] = cached[iLocalIdx + -1 * iBlockLen + -1]; pixelNeig[2] = cached[iLocalIdx + -1 * iBlockLen + 1]; pixelNeig[3] = cached[iLocalIdx + 0 * iBlockLen + -2]; pixelNeig[4] = cached[iLocalIdx + 0 * iBlockLen + 2]; pixelNeig[5] = cached[iLocalIdx + 1 * iBlockLen + -1]; pixelNeig[6] = cached[iLocalIdx + 1 * iBlockLen + 1]; pixelNeig[7] = cached[iLocalIdx + 2 * iBlockLen + 0]; &#125; else if (bx &lt; 128)//&lt;G, this is a Green in the R row &#123; lx = (threadIdx.x/2)*2 + 1; ly = (threadIdx.y-4)*2 + (threadIdx.x%2)*8; dx = blockIdx.x * blockDim.x + lx; dy = blockIdx.y * blockDim.y + ly; // the offset at the start of the row iLocalRowStartIdx = (ly + 2) * iBlockLen; // index to the current pixel iLocalIdx = iLocalRowStartIdx + lx + 2; pixelNeig[0] = cached[iLocalIdx + -2 * iBlockLen + 0]; pixelNeig[1] = cached[iLocalIdx + -1 * iBlockLen + -1]; pixelNeig[2] = cached[iLocalIdx + -1 * iBlockLen + 1]; pixelNeig[3] = cached[iLocalIdx + 0 * iBlockLen + -2]; pixelNeig[4] = cached[iLocalIdx + 0 * iBlockLen + 2]; pixelNeig[5] = cached[iLocalIdx + 1 * iBlockLen + -1]; pixelNeig[6] = cached[iLocalIdx + 1 * iBlockLen + 1]; pixelNeig[7] = cached[iLocalIdx + 2 * iBlockLen + 0]; &#125; else if (bx &lt; 192)//&lt;B, &#123; lx = (threadIdx.x/2)*2 + 1; ly = (threadIdx.y-8)*2 + (threadIdx.x%2)*8 + 1; dx = blockIdx.x * blockDim.x + lx; dy = blockIdx.y * blockDim.y + ly; // the offset at the start of the row iLocalRowStartIdx = (ly + 2) * iBlockLen; // index to the current pixel iLocalIdx = iLocalRowStartIdx + lx + 2; pixelNeig[0] = cached[iLocalIdx + -2 * iBlockLen + -2]; pixelNeig[1] = cached[iLocalIdx + -2 * iBlockLen + 0]; pixelNeig[2] = cached[iLocalIdx + -2 * iBlockLen + 2]; pixelNeig[3] = cached[iLocalIdx + 0 * iBlockLen + -2]; pixelNeig[4] = cached[iLocalIdx + 0 * iBlockLen + 2]; pixelNeig[5] = cached[iLocalIdx + 2 * iBlockLen + -2]; pixelNeig[6] = cached[iLocalIdx + 2 * iBlockLen + 0]; pixelNeig[7] = cached[iLocalIdx + 2 * iBlockLen + 2]; &#125; else//&lt;R, &#123; lx = (threadIdx.x/2)*2; ly = (threadIdx.y-12)*2 + (threadIdx.x%2)*8; dx = blockIdx.x * blockDim.x + lx; dy = blockIdx.y * blockDim.y + ly; // the offset at the start of the row iLocalRowStartIdx = (ly + 2) * iBlockLen; // index to the current pixel iLocalIdx = iLocalRowStartIdx + lx + 2; pixelNeig[0] = cached[iLocalIdx + -2 * iBlockLen + -2]; pixelNeig[1] = cached[iLocalIdx + -2 * iBlockLen + 0]; pixelNeig[2] = cached[iLocalIdx + -2 * iBlockLen + 2]; pixelNeig[3] = cached[iLocalIdx + 0 * iBlockLen + -2]; pixelNeig[4] = cached[iLocalIdx + 0 * iBlockLen + 2]; pixelNeig[5] = cached[iLocalIdx + 2 * iBlockLen + -2]; pixelNeig[6] = cached[iLocalIdx + 2 * iBlockLen + 0]; pixelNeig[7] = cached[iLocalIdx + 2 * iBlockLen + 2]; &#125; unsigned short centerPixel = cached[iLocalIdx]; unsigned short medianV; int nConditionValue = 0; short pixelNeigDiff = 0; for (int i = 0; i &lt; 8; i++) &#123; pixelNeigDiff = (short)pixelNeig[i] - (short)centerPixel; if(pixelNeigDiff &gt; 0) &#123; nConditionValue += 1; &#125; if(pixelNeigDiff &lt; 0) &#123; nConditionValue -= 1; pixelNeigDiff = -pixelNeigDiff; &#125; if(pixelNeigDiff &lt;= iThreshold) &#123; break; &#125; if (abs(nConditionValue) &lt;= i) &#123; break; &#125; &#125; int iDstIdx = dy * iDstStride + dx; if (iDstIdx &gt;= iDstStride*iHeight) &#123; return; &#125; if (abs(nConditionValue) &lt; 8) &#123; pDst[iDstIdx] = centerPixel; &#125; else &#123; cuClassicMedianFilter(pixelNeig, 8, &amp;medianV); pDst[iDstIdx] = medianV; &#125;&#125;extern &quot;C&quot; void DeadPixelCorrectionRGGB(unsigned short* pSrc, unsigned short* pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride, unsigned short iThreshold)&#123; dim3 numThreads(16, 16, 1); // do not change, has to be 16 dim3 numBlocks(DivUp(iWidth, numThreads.x), DivUp(iHeight, numThreads.y)); cuDeadPixelCorrectionRGGB&lt;&lt;&lt;numBlocks, numThreads, 20 * 20 * sizeof(unsigned short)&gt;&gt;&gt;(pSrc, pDst, iWidth, iHeight, iSrcStride, iDstStride, iThreshold);&#125;__global__ void cuDeadPixelCorrectionGBRG(unsigned short *pSrc, unsigned short *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride, unsigned short iThreshold)&#123; const int dx = blockIdx.x * blockDim.x + threadIdx.x; const int dy = blockIdx.y * blockDim.y + threadIdx.y; if (dx &gt;= iWidth || dy &gt;= iHeight) &#123; return; &#125; const int lx = threadIdx.x; const int ly = threadIdx.y; // twice of half filter length plus local size const int iBlockLen = 4 + DEMOSAIC_LOCAL_SIZE; // the offset at the start of the row const int iLocalRowStartIdx = (ly + 2) * iBlockLen; // index to the current pixel const int iLocalIdx = iLocalRowStartIdx + lx + 2; cached[iLocalIdx] = pSrc[dy * iSrcStride + dx]; // copy additional data for border if (lx &lt; 2) &#123; int iSrcX = dx - 2; if (iSrcX &lt; 0) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[iLocalRowStartIdx + lx] = pSrc[dy * iSrcStride + iSrcX]; if (dy &gt;= iHeight - 2) &#123; int iSrcY = dy + 2; if (iSrcY &gt;= iHeight) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[(ly + 4) * iBlockLen + lx] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; &#125; else if (lx &gt;= (DEMOSAIC_LOCAL_SIZE - 2)) &#123; int iSrcX = dx + 2; if (iSrcX &gt;= iWidth) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[iLocalIdx + 2] = pSrc[dy * iSrcStride + iSrcX]; if (dy &gt;= iHeight - 2) &#123; int iSrcY = dy + 2; if (iSrcY &gt;= iHeight) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[(ly + 4) * iBlockLen + lx + 4] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; &#125; if (ly &lt; 2) &#123; int iSrcY = dy - 2; if (iSrcY &lt; 0) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[ly * iBlockLen + lx + 2] = pSrc[iSrcY * iSrcStride + dx]; if (lx &lt; 2) &#123; int iSrcX = dx - 2; if (iSrcX &lt; 0) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[ly * iBlockLen + lx] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; else if (lx &gt;= (DEMOSAIC_LOCAL_SIZE - 2)) &#123; int iSrcX = dx + 2; if (iSrcX &gt;= iWidth) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[ly * iBlockLen + lx + 4] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; &#125; else if (ly &gt;= (DEMOSAIC_LOCAL_SIZE - 2)) &#123; int iSrcY = dy + 2; if (iSrcY &gt;= iHeight) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[(ly + 4) * iBlockLen + lx + 2] = pSrc[iSrcY * iSrcStride + dx]; if (lx &lt; 2) &#123; int iSrcX = dx - 2; if (iSrcX &lt; 0) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[(ly + 4) * iBlockLen + lx] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; else if (lx &gt;= (DEMOSAIC_LOCAL_SIZE - 2)) &#123; int iSrcX = dx + 2; if (iSrcX &gt;= iWidth) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[(ly + 4) * iBlockLen + lx + 4] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; &#125; else // the bottom of local box may not aligned with the bottom of the image &#123; if (dy &gt;= iHeight - 2) &#123; int iSrcY = dy + 2; if (iSrcY &gt;= iHeight) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[(ly + 4) * iBlockLen + lx + 2] = pSrc[iSrcY * iSrcStride + dx]; &#125; &#125; // sync __syncthreads(); unsigned short pixelNeig[8]; unsigned short centerPixel = cached[iLocalIdx]; if (dy % 2 == 0) &#123; // this is a B row if (dx % 2 == 1) &#123; // this is a B pixel, changing the index can support GBRG format pixelNeig[0] = cached[iLocalIdx + -2 * iBlockLen + -2]; pixelNeig[1] = cached[iLocalIdx + -2 * iBlockLen + 0]; pixelNeig[2] = cached[iLocalIdx + -2 * iBlockLen + 2]; pixelNeig[3] = cached[iLocalIdx + 0 * iBlockLen + -2]; pixelNeig[4] = cached[iLocalIdx + 0 * iBlockLen + 2]; pixelNeig[5] = cached[iLocalIdx + 2 * iBlockLen + -2]; pixelNeig[6] = cached[iLocalIdx + 2 * iBlockLen + 0]; pixelNeig[7] = cached[iLocalIdx + 2 * iBlockLen + 2]; &#125; else &#123; // this is a G pixel in the B row pixelNeig[0] = cached[iLocalIdx + -2 * iBlockLen + 0]; pixelNeig[1] = cached[iLocalIdx + -1 * iBlockLen + -1]; pixelNeig[2] = cached[iLocalIdx + -1 * iBlockLen + 1]; pixelNeig[3] = cached[iLocalIdx + 0 * iBlockLen + -2]; pixelNeig[4] = cached[iLocalIdx + 0 * iBlockLen + 2]; pixelNeig[5] = cached[iLocalIdx + 1 * iBlockLen + -1]; pixelNeig[6] = cached[iLocalIdx + 1 * iBlockLen + 1]; pixelNeig[7] = cached[iLocalIdx + 2 * iBlockLen + 0]; &#125; &#125; else &#123; // this is a R row if (dx % 2 == 1) &#123; // this is a G pixel in the R row, changing the index can support GBRG format pixelNeig[0] = cached[iLocalIdx + -2 * iBlockLen + 0]; pixelNeig[1] = cached[iLocalIdx + -1 * iBlockLen + -1]; pixelNeig[2] = cached[iLocalIdx + -1 * iBlockLen + 1]; pixelNeig[3] = cached[iLocalIdx + 0 * iBlockLen + -2]; pixelNeig[4] = cached[iLocalIdx + 0 * iBlockLen + 2]; pixelNeig[5] = cached[iLocalIdx + 1 * iBlockLen + -1]; pixelNeig[6] = cached[iLocalIdx + 1 * iBlockLen + 1]; pixelNeig[7] = cached[iLocalIdx + 2 * iBlockLen + 0]; &#125; else &#123; // this is a R pixel pixelNeig[0] = cached[iLocalIdx + -2 * iBlockLen + -2]; pixelNeig[1] = cached[iLocalIdx + -2 * iBlockLen + 0]; pixelNeig[2] = cached[iLocalIdx + -2 * iBlockLen + 2]; pixelNeig[3] = cached[iLocalIdx + 0 * iBlockLen + -2]; pixelNeig[4] = cached[iLocalIdx + 0 * iBlockLen + 2]; pixelNeig[5] = cached[iLocalIdx + 2 * iBlockLen + -2]; pixelNeig[6] = cached[iLocalIdx + 2 * iBlockLen + 0]; pixelNeig[7] = cached[iLocalIdx + 2 * iBlockLen + 2]; &#125; &#125; unsigned short medianV; cuClassicMedianFilter(pixelNeig, 8, &amp;medianV); bool bAllPostive = true; bool bAllNegative = true; bool bAllDiffGT = true; for (int i = 0; i &lt; 8; i++) &#123; int pixelNeigDiff = (int)pixelNeig[i] - (int)centerPixel; if(pixelNeigDiff &gt; 0) bAllNegative = false; if(pixelNeigDiff &lt; 0) bAllPostive = false; if(pixelNeigDiff &lt; 0) pixelNeigDiff = -pixelNeigDiff; if(pixelNeigDiff &lt;= iThreshold) bAllDiffGT = false; &#125; int iDstIdx = dy * iDstStride + dx; pDst[iDstIdx] = centerPixel; if(bAllPostive == true || bAllNegative == true) &#123; if(bAllDiffGT == true) &#123; pDst[iDstIdx] = medianV; &#125; &#125;&#125;extern &quot;C&quot; void DeadPixelCorrectionGBRG(unsigned short* pSrc, unsigned short* pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride, unsigned short iThreshold)&#123; dim3 numThreads(16, 16, 1); // do not change, has to be 16 dim3 numBlocks(DivUp(iWidth, numThreads.x), DivUp(iHeight, numThreads.y)); cuDeadPixelCorrectionGBRG&lt;&lt;&lt;numBlocks, numThreads, 20 * 20 * sizeof(unsigned short)&gt;&gt;&gt;(pSrc, pDst, iWidth, iHeight, iSrcStride, iDstStride, iThreshold);&#125;__global__ void cuDeadPixelCorrectionMono(unsigned short *pSrc, unsigned short *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride, unsigned short iThreshold)&#123; const int dx = blockIdx.x * blockDim.x + threadIdx.x; const int dy = blockIdx.y * blockDim.y + threadIdx.y; if (dx &gt;= iWidth || dy &gt;= iHeight) &#123; return; &#125; const int lx = threadIdx.x; const int ly = threadIdx.y; // twice of half filter length plus local size const int iBlockLen = 4 + DEMOSAIC_LOCAL_SIZE; // the offset at the start of the row const int iLocalRowStartIdx = (ly + 2) * iBlockLen; // index to the current pixel const int iLocalIdx = iLocalRowStartIdx + lx + 2; cached[iLocalIdx] = pSrc[dy * iSrcStride + dx]; // copy additional data for border if (lx &lt; 2) &#123; int iSrcX = dx - 2; if (iSrcX &lt; 0) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[iLocalRowStartIdx + lx] = pSrc[dy * iSrcStride + iSrcX]; if (dy &gt;= iHeight - 2) &#123; int iSrcY = dy + 2; if (iSrcY &gt;= iHeight) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[(ly + 4) * iBlockLen + lx] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; &#125; else if (lx &gt;= (DEMOSAIC_LOCAL_SIZE - 2)) &#123; int iSrcX = dx + 2; if (iSrcX &gt;= iWidth) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[iLocalIdx + 2] = pSrc[dy * iSrcStride + iSrcX]; if (dy &gt;= iHeight - 2) &#123; int iSrcY = dy + 2; if (iSrcY &gt;= iHeight) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[(ly + 4) * iBlockLen + lx + 4] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; &#125; if (ly &lt; 2) &#123; int iSrcY = dy - 2; if (iSrcY &lt; 0) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[ly * iBlockLen + lx + 2] = pSrc[iSrcY * iSrcStride + dx]; if (lx &lt; 2) &#123; int iSrcX = dx - 2; if (iSrcX &lt; 0) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[ly * iBlockLen + lx] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; else if (lx &gt;= (DEMOSAIC_LOCAL_SIZE - 2)) &#123; int iSrcX = dx + 2; if (iSrcX &gt;= iWidth) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[ly * iBlockLen + lx + 4] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; &#125; else if (ly &gt;= (DEMOSAIC_LOCAL_SIZE - 2)) &#123; int iSrcY = dy + 2; if (iSrcY &gt;= iHeight) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[(ly + 4) * iBlockLen + lx + 2] = pSrc[iSrcY * iSrcStride + dx]; if (lx &lt; 2) &#123; int iSrcX = dx - 2; if (iSrcX &lt; 0) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[(ly + 4) * iBlockLen + lx] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; else if (lx &gt;= (DEMOSAIC_LOCAL_SIZE - 2)) &#123; int iSrcX = dx + 2; if (iSrcX &gt;= iWidth) &#123; EXTRAPOLATE(iSrcX, 0, iWidth - 1); &#125; cached[(ly + 4) * iBlockLen + lx + 4] = pSrc[iSrcY * iSrcStride + iSrcX]; &#125; &#125; else // the bottom of local box may not aligned with the bottom of the image &#123; if (dy &gt;= iHeight - 2) &#123; int iSrcY = dy + 2; if (iSrcY &gt;= iHeight) &#123; EXTRAPOLATE(iSrcY, 0, iHeight - 1); &#125; cached[(ly + 4) * iBlockLen + lx + 2] = pSrc[iSrcY * iSrcStride + dx]; &#125; &#125; // sync __syncthreads(); unsigned short pixelNeig[8]; unsigned short centerPixel = cached[iLocalIdx]; pixelNeig[0] = cached[iLocalIdx + -1 * iBlockLen + -1]; pixelNeig[1] = cached[iLocalIdx + -1 * iBlockLen + 0]; pixelNeig[2] = cached[iLocalIdx + -1 * iBlockLen + 1]; pixelNeig[3] = cached[iLocalIdx + 0 * iBlockLen + -1]; pixelNeig[4] = cached[iLocalIdx + 0 * iBlockLen + 1]; pixelNeig[5] = cached[iLocalIdx + 1 * iBlockLen + -1]; pixelNeig[6] = cached[iLocalIdx + 1 * iBlockLen + 0]; pixelNeig[7] = cached[iLocalIdx + 1 * iBlockLen + 1]; unsigned short medianV; cuClassicMedianFilter(pixelNeig, 8, &amp;medianV); bool bAllPostive = true; bool bAllNegative = true; bool bAllDiffGT = true; for (int i = 0; i &lt; 8; i++) &#123; int pixelNeigDiff = (int)pixelNeig[i] - (int)centerPixel; if(pixelNeigDiff &gt; 0) bAllNegative = false; if(pixelNeigDiff &lt; 0) bAllPostive = false; if(pixelNeigDiff &lt; 0) pixelNeigDiff = -pixelNeigDiff; if(pixelNeigDiff &lt;= iThreshold) bAllDiffGT = false; &#125; int iDstIdx = dy * iDstStride + dx; pDst[iDstIdx] = centerPixel; if(bAllPostive == true || bAllNegative == true) &#123; if(bAllDiffGT == true) &#123; pDst[iDstIdx] = medianV; &#125; &#125;&#125;extern &quot;C&quot; void DeadPixelCorrectionMono(unsigned short* pSrc, unsigned short* pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride, unsigned short iThreshold)&#123; dim3 numThreads(16, 16, 1); // do not change, has to be 16 dim3 numBlocks(DivUp(iWidth, numThreads.x), DivUp(iHeight, numThreads.y)); cuDeadPixelCorrectionMono&lt;&lt;&lt;numBlocks, numThreads, 20 * 20 * sizeof(unsigned short)&gt;&gt;&gt;(pSrc, pDst, iWidth, iHeight, iSrcStride, iDstStride, iThreshold);&#125;","categories":[{"name":"ISP","slug":"ISP","permalink":"http://example.com/categories/ISP/"}],"tags":[{"name":"ISP","slug":"ISP","permalink":"http://example.com/tags/ISP/"}]},{"title":"ISP pipeline概述","slug":"cameraIsp/ISP-pipeline概述","date":"2025-02-27T02:48:04.000Z","updated":"2025-02-27T02:56:17.738Z","comments":true,"path":"2025/02/27/cameraIsp/ISP-pipeline概述/","link":"","permalink":"http://example.com/2025/02/27/cameraIsp/ISP-pipeline%E6%A6%82%E8%BF%B0/","excerpt":"","text":"ISP管道概览 ISP名词解释","categories":[{"name":"ISP","slug":"ISP","permalink":"http://example.com/categories/ISP/"}],"tags":[{"name":"ISP","slug":"ISP","permalink":"http://example.com/tags/ISP/"}]},{"title":"gstreamer录制过程中修改视频文件mata信息","slug":"gstreamer/gstreamer录制过程中修改视频文件mata信息","date":"2025-02-19T06:41:20.000Z","updated":"2025-02-19T08:22:43.040Z","comments":true,"path":"2025/02/19/gstreamer/gstreamer录制过程中修改视频文件mata信息/","link":"","permalink":"http://example.com/2025/02/19/gstreamer/gstreamer%E5%BD%95%E5%88%B6%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BF%AE%E6%94%B9%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6mata%E4%BF%A1%E6%81%AF/","excerpt":"","text":"背景：之前不全面的用法之前就有一个需求：在录制视频文件中增加一些额外的meta信息，示例： 1gst-launch-1.0 videotestsrc ! taginject tags=\\&quot;title=testTitle\\&quot; ! nvh264enc ! h264parse ! mp4mux ! filesink location=tmp.mp4 这种方法确实能写入title信息，但具体信息要在pipeline启动前就确定好，playing过程中无法修改更新，准确来说是taginject插件只能被初始化一次。 正确的用法实际应用过程中上面的方法就可能不适用，例如给录制的视频增加章节，每个章节具体的起止点都是在录制过程中才能确定的，很难预先确定。这种场景下就只能在end-of-stream之前再写入meta数据，具体方法API ： 1videotestsrc ! taginject name=tagger ! nvh264enc ! h264parse ! mp4mux ! filesink location=tmp.mp4 使用API接口解析上述pipeline并获取name&#x3D;tagger的元素，需要注意的是pipeline中不能对它的tags属性进行初始化，原因如上。 1GstElement *tagger = gst_bin_get_by_name(GST_BIN(pipeline), &quot;tagger&quot;); 然后在录制结束在发送EOS之调用： 1g_object_set(tagger, &quot;tags&quot;, &quot;title=testTitle,common=testCom&quot;); 局限性如上，taginject插件的tags只能被设置一次，其余的多次设置均不生效。如果需要动态多次更新可以考虑以下几个方向：1、研究GstMeta2、后处理，使用工具，如FFmpeg或ExifTool，已试过，MKV文件处理速度快，MP4巨慢3、后处理，gstreamer，无论mp4还是MKV，速度稍快(因为不用重新编解码)，处理时间略等于视频时长的十分之一，示例： 1gst-launch-1.0 filesrc location=test.mp4 ! qtdemux ! h264parse ! taginject tags=&quot;your tags&quot; ! mp4mux ! filesink location=testTagged.mp4 补充验证: 1ffprobe -v error -show_entries format_tags=comment -of default=noprint_wrappers=1:nokey=1 video-2025-02-19-15-56-51.mp4","categories":[{"name":"gstreamer","slug":"gstreamer","permalink":"http://example.com/categories/gstreamer/"}],"tags":[{"name":"gstreamer","slug":"gstreamer","permalink":"http://example.com/tags/gstreamer/"}]},{"title":"rk3399pro交叉编译Qt--eglfs","slug":"armLinux/rk3399pro交叉编译Qt-eglfs","date":"2024-12-18T01:21:49.000Z","updated":"2024-12-19T03:15:33.057Z","comments":true,"path":"2024/12/18/armLinux/rk3399pro交叉编译Qt-eglfs/","link":"","permalink":"http://example.com/2024/12/18/armLinux/rk3399pro%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91Qt-eglfs/","excerpt":"","text":"一、事先准备1、ubuntu PC1) 下载Qt5.15.2源码 2) 下载文件系统 直接新建一个sysroot空目录即可，等会再同步树莓派的库文件 2、jetson Nano1) 安装依赖选项 1sudo apt-get install libegl1-mesa-dev libdrm-dev libgles2-mesa-dev libgbm-dev libxcb-dri2-0-dev 二、编译及安装1、同步文件系统注意，可以把usr 和lib的着整个目录都同步过来。可以解决交叉编译的很多问题。 12rsync -avz root@192.168.10.201:/lib sysrootrsync -avz root@192.168.10.201:/usr sysroot 2、修复损坏的链接文件123wget https://raw.githubusercontent.com/Kukkimonsuta/rpi-buildqt/master/scripts/utils/sysroot-relativelinks.pychmod -x sysroot-relativelinks.py./sysroot-relativelinks.py sysroot 文件内容如下: 12345678910111213141516171819202122232425262728293031323334#!/usr/bin/env pythonimport sysimport os# source: https://raw.githubusercontent.com/riscv/riscv-poky/master/scripts/sysroot-relativelinks.py# Take a sysroot directory and turn all the absolute symlinks and turn them into# relative ones such that the sysroot is usable within another system.if len(sys.argv) != 2: print(&quot;Usage is &quot; + sys.argv[0] + &quot;&lt;directory&gt;&quot;) sys.exit(1)topdir = sys.argv[1]topdir = os.path.abspath(topdir)def handlelink(filePath, subdir): link = os.readlink(filePath) if link[0] != &quot;/&quot;: return if link.startswith(topdir): return newLink = os.path.relpath(topdir+link, subdir) print(&quot;\\t%s replacing %s =&gt; %s&quot; % (filePath, link, newLink)) os.unlink(filePath) os.symlink(newLink, filePath)for subdir, dirs, files in os.walk(topdir): for file in files: filePath = os.path.join(subdir, file) if os.path.islink(filePath): handlelink(filePath, subdir) 将上面的文件保存到sysroot-relativelinks.py，并且赋予+x权限如何使用: 1./sysroot-relativelinks.py sysroot 3、修改QT配置文件修改该配置文件: qt-everywhere-src-5.15.2&#x2F;qtbase&#x2F;mkspecs&#x2F;devices&#x2F;linux-firefly-rk3399pro-g++&#x2F;qmake.conf主要是添加链接库和头文件，从而识别openGL的相关库文件，修改如下: 123456789101112131415161718192021222324252627282930313233343536373839404142include(../common/linux_device_pre.conf) QMAKE_INCDIR_POST += \\ $$[QT_SYSROOT]/usr/include \\ $$[QT_SYSROOT]/usr/include/aarch64-linux-gnu QMAKE_LIBDIR_POST += \\ $$[QT_SYSROOT]/usr/lib \\ $$[QT_SYSROOT]/lib/aarch64-linux-gnu \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu QMAKE_RPATHLINKDIR_POST += \\ $$[QT_SYSROOT]/usr/lib \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu \\ $$[QT_SYSROOT]/lib/aarch64-linux-gnu QMAKE_INCDIR_OPENGL[_ES2] += \\ $$[QT_SYSROOT]/usr/include \\ $$[QT_SYSROOT]/usr/include/EGL \\ $$[QT_SYSROOT]/usr/include/GLES2 \\ $$[QT_SYSROOT]/usr/include/GLES3 \\ $$[QT_SYSROOT]/usr/include/KHRQMAKE_LIBDIR_OPENGL[_ES2] += \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu/tegra \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu QMAKE_LIBS_OPENGL[_ES2] += -lGLESv2 -lEGLQMAKE_INCDIR_EGL += $$QMAKE_INCDIR_OPENGL[_ES2]QMAKE_LIBDIR_EGL += $$QMAKE_LIBDIR_OPENGL[_ES2]QMAKE_LIBS_EGL += -lGLESv2 -lEGLQMAKE_LIBS_OPENGL_ES2 += -lGLESv2 -lEGLQMAKE_CXXFLAGS = $$QMAKE_CFLAGSEGLFS_DEVICE_INTEGRATION = eglfs_kmsload(qt_config) 1234567891011121314151617181920212223../configure \\-extprefix /home/lufahai/data/rockchip/firefly/rk3399pro/qt4Rk3399pro/qt5.15.2 \\-prefix /home/lufahai/data/rockchip/firefly/rk3399pro/qt4Rk3399pro/qt5.15.2 \\-hostprefix /home/lufahai/data/rockchip/firefly/rk3399pro/qt4Rk3399pro/hostQt5.15.2 \\-confirm-license \\-opensource \\-device-option CROSS_COMPILE=/opt/aarch64-linux-gcc/bin/aarch64-linux-gnu- \\-device linux-firefly-rk3399pro-g++ \\-sysroot /home/lufahai/data/rockchip/firefly/rk3399pro/qt4Rk3399pro/sysroot \\-opengl es2 \\-skip qtscript \\-skip wayland \\-skip qtwebengine \\-force-debug-info \\-skip qtdatavis3d \\-skip qtlocation \\-nomake examples \\-make libs -pkg-config -no-use-gold-linker -v \\-no-openssl -shared -release -pch -no-cups \\-no-glib -no-dbus -no-xcb \\-no-separate-debug-info \\-no-fontconfig \\-nomake tests -no-iconv -no-tslib qt支持多种后台插件，即便是eglfs也可以分为eglfs_x11 和 eglfs_kms，前者必须在一个X上运行。而kms是直接底层驱动图形接口，不需要依赖于其他桌面系统，渲染效率更高。 如何修改：在qmake.conf 增加-lgbm以及它对应的库文件和头文件路径(与glesv2一样)，并且下面的EGLFS_DEVICE_INTEGRATION &#x3D; eglfs_x11要改为 EGLFS_DEVICE_INTEGRATION &#x3D; eglfs_kms 如何确定是否可行：要保证EGLFS details中的EGLDevice 和 GBM为yes 1234567891011EGLFS details:EGLFS OpenWFD ........................ noEGLFS i.Mx6 .......................... noEGLFS i.Mx6 Wayland .................. noEGLFS RCAR ........................... noEGLFS EGLDevice ...................... yesEGLFS GBM ............................ yesEGLFS VSP2 ........................... noEGLFS Mali ........................... noEGLFS Raspberry Pi ................... noEGLFS X11 ............................ yes 然后直接make &amp;&amp; make install","categories":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/categories/armLinux/"}],"tags":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/tags/armLinux/"}]},{"title":"OpenGL不需要坐标直接渲染","slug":"OpenGl/OpenGL不需要坐标直接渲染","date":"2024-12-06T09:55:17.000Z","updated":"2024-12-06T10:06:48.001Z","comments":true,"path":"2024/12/06/OpenGl/OpenGL不需要坐标直接渲染/","link":"","permalink":"http://example.com/2024/12/06/OpenGl/OpenGL%E4%B8%8D%E9%9C%80%E8%A6%81%E5%9D%90%E6%A0%87%E7%9B%B4%E6%8E%A5%E6%B8%B2%E6%9F%93/","excerpt":"","text":"前言偶然在网上看到一种方法： 可以在不输入顶点坐标和纹理坐标的情况下，完整渲染出纹理。 原理顶点索引 gl_VertexID 是 OpenGL 的内建变量，它在顶点着色器中表示当前顶点的索引。它不需要显式生成或传递，因为在调用绘制命令（如 glDrawArrays）时，OpenGL 会自动为每个顶点提供该索引。当你使用 glDrawArrays(GL_TRIANGLES, 0, 3) 来绘制一个包含三个顶点的三角形时，gl_VertexID 会依次被设置为 0、1 和 2。这个索引值可以用来计算每个顶点的位置和其他属性。 实现12345678910111213#version 300 es out vec2 v_texCoord; void main() &#123; // 根据顶点索引计算纹理坐标 // gl_VertexID 的值依次为 0, 1, 2 v_texCoord = vec2((gl_VertexID &lt;&lt; 1) &amp; 2, gl_VertexID &amp; 2); // 将纹理坐标转换为标准化设备坐标 // v_texCoord 的值依次为 (0, 0), (2, 0), (0, 2) gl_Position = vec4(v_texCoord * 2.0 - 1.0, 0.0, 1.0);&#125; 计算过程： 在这个顶点着色器中，gl_VertexID 的值为 0、1、2，这三次调用对应于三角形的三个顶点。下面是每个顶点的计算细节： 顶点 0 (gl_VertexID &#x3D; 0): v_texCoord &#x3D; vec2((0 &lt;&lt; 1) &amp; 2, 0 &amp; 2) -&gt; v_texCoord &#x3D; vec2(0, 0)gl_Position &#x3D; vec4(v_texCoord * 2.0 – 1.0, 0.0, 1.0) -&gt; gl_Position &#x3D; vec4(-1.0, -1.0, 0.0, 1.0) 顶点 1 (gl_VertexID &#x3D; 1): v_texCoord &#x3D; vec2((1 &lt;&lt; 1) &amp; 2, 1 &amp; 2) -&gt; v_texCoord &#x3D; vec2(2, 0)gl_Position &#x3D; vec4(v_texCoord * 2.0 – 1.0, 0.0, 1.0) -&gt; gl_Position &#x3D; vec4(3.0, -1.0, 0.0, 1.0) 顶点 2 (gl_VertexID &#x3D; 2): v_texCoord &#x3D; vec2((2 &lt;&lt; 1) &amp; 2, 2 &amp; 2) -&gt; v_texCoord &#x3D; vec2(0, 2)gl_Position &#x3D; vec4(v_texCoord * 2.0 – 1.0, 0.0, 1.0) -&gt; gl_Position &#x3D; vec4(-1.0, 3.0, 0.0, 1.0) 通过这三个顶点，生成了一个覆盖整个屏幕的三角形。注意，这个三角形覆盖了标准化设备坐标 (NDC) 空间，从左下角 (-1, -1) 到右上角 (1, 1)，因此它可以覆盖整个屏幕。 此时生成的顶点坐标 此时生成的纹理坐标 可以看到这个大的三角形超出了屏幕区域，这个没有问题，渲染的时候将会被裁剪，不会影响性能。 纹理着色器代码 12345678910111213#version 300 es out vec2 v_texCoord; void main() &#123; // 根据顶点索引计算纹理坐标 // gl_VertexID 的值依次为 0, 1, 2 v_texCoord = vec2((gl_VertexID &lt;&lt; 1) &amp; 2, gl_VertexID &amp; 2); // 将纹理坐标转换为标准化设备坐标 // v_texCoord 的值依次为 (0, 0), (2, 0), (0, 2) gl_Position = vec4(v_texCoord * 2.0 - 1.0, 0.0, 1.0);&#125; 渲染代码 123456789//指定着色器程序glUseProgram (m_ProgramObj);//激活并绑定纹理 idglActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, m_TextureId);glUniform1i(m_SamplerLoc, 0);glDrawArrays(GL_TRIANGLES, 0, 3); 后续优化上面步骤得到的是一个上下倒立的渲染纹理，可以对照原先的方法将其翻转回来。 12345678910#version 300 es layout(location = 0) in vec4 a_position; layout(location = 1) in vec2 a_texCoord; out vec2 v_texCoord; void main() &#123; vec2 uv = vec2((gl_VertexID &lt;&lt; 1) &amp; 2, gl_VertexID &amp; 2); v_texCoord = vec2(uv.x, 1.0 - uv.y); gl_Position = vec4(uv * 2.0 - 1.0, 0.0, 1.0);&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://example.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://example.com/tags/OpenGL/"}]},{"title":"rockchip 开启高性能GPU模式","slug":"armLinux/rockchip-开启高性能GPU模式","date":"2024-12-03T01:52:01.000Z","updated":"2024-12-03T02:01:48.359Z","comments":true,"path":"2024/12/03/armLinux/rockchip-开启高性能GPU模式/","link":"","permalink":"http://example.com/2024/12/03/armLinux/rockchip-%E5%BC%80%E5%90%AF%E9%AB%98%E6%80%A7%E8%83%BDGPU%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"背景使用RK3566的mjpg硬件解码USB摄像头得到的720P的NV12图像，利用opencl将其转换成RGBA图像，发现CPU占用率一下子达到90%多，经过测试发现主要是NV12图像 memcpy 给opencl占用了过多资源。无论采用writeBuf的形式还是mmapHostMem的方式都不会降低CPU占用。 解决偶然间看到一个帖子说可以开启高性能GPU模式，遂尝试，有效：开启高性能模式 1echo performance | tee $(find /sys |grep governor$) 不等待vsync，貌似这个只有使用kmssink的时候才有用。 1export KMSSINK_DISABLE_VSYNC=1 打开硬件解码Debug 1echo 0x100 &gt; /sys/module/rk_vcodec/parameters/mpp_dev_debug","categories":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/categories/armLinux/"}],"tags":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/tags/armLinux/"}]},{"title":"QProcess未退出对主程序的影响","slug":"Qt/QProcess未退出对主程序的影响","date":"2024-11-26T01:13:44.000Z","updated":"2024-11-26T02:05:40.345Z","comments":true,"path":"2024/11/26/Qt/QProcess未退出对主程序的影响/","link":"","permalink":"http://example.com/2024/11/26/Qt/QProcess%E6%9C%AA%E9%80%80%E5%87%BA%E5%AF%B9%E4%B8%BB%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BD%B1%E5%93%8D/","excerpt":"","text":"现象主程序使用QProcess启动外部程序，在这种情况下QProcess会占用主程序的资源。具体例子：主程序打开&#x2F;dev&#x2F;video0视频设备，并使用QProcess启动外部程序。当pkill主程序的时候，外部程序不会退出，这时当主程序重启后无法打开&#x2F;dev&#x2F;video0设备。但只要kill掉外部程序 设备打开正常。 解决1、如果主副程序是平行的，那么应该在更外一层并行管理主副程序。2、在主程序的析构函数中，退出的时候即使调用QProcess-&gt;kill() 去主动关闭外部程序。","categories":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"gsteamer pipeline在不同线程创建对显示延迟的影响","slug":"gstreamer/gsteamer-pipeline在不同线程创建对显示延迟的影响","date":"2024-11-22T08:09:12.000Z","updated":"2024-11-22T08:35:54.128Z","comments":true,"path":"2024/11/22/gstreamer/gsteamer-pipeline在不同线程创建对显示延迟的影响/","link":"","permalink":"http://example.com/2024/11/22/gstreamer/gsteamer-pipeline%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E6%98%BE%E7%A4%BA%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%BD%B1%E5%93%8D/","excerpt":"","text":"背景使用gstreamer-rtsp-server推流时遇到一个比较有趣的事情：在不同的线程中初始化rtsp-server最后的显示延迟的结果会不一样。 测试测试1：在Run线程中初始化，延迟大创建和推流都是在成员函数中实现，由父类调用。而在run函数，即另外一个线程中创建pipeline， 12345678910111213141516171819202122232425262728293031//hppclass GstLive : public QThread &#123; ...public: void createStream(); void pushStream(); protected: void run() override; gstStream *mgstStream;&#125;;//cppvoid GstLive::createStream()&#123; gstStream = new mgstStream();&#125;void GstLive::run() &#123; gstStream-&gt;createPipeline();&#125;void GstLive::pushStream()&#123; ...&#125; 测试结果：延迟约 4秒 测试2：在主线程中初始化，延迟小创建对象，初始化pipelin和推流都是在成员函数中实现，由父类调用。 1234567891011121314151617181920212223242526272829303132//hppclass GstLive : public QThread &#123; ...public: void createStream(); void pushStream(); protected: void run() override; gstStream *mgstStream;&#125;;//cppvoid GstLive::createStream()&#123; gstStream = new mgstStream(); gstStream-&gt;createPipeline();&#125;void GstLive::run() &#123; &#125;void GstLive::pushStream()&#123; ...&#125; 测试结果：内网测试下才100多毫秒 附件：","categories":[{"name":"gstreamer","slug":"gstreamer","permalink":"http://example.com/categories/gstreamer/"}],"tags":[{"name":"gstreamer","slug":"gstreamer","permalink":"http://example.com/tags/gstreamer/"}]},{"title":"vmware ubuntu共享主机的梯子","slug":"ubuntu/vmware-ubuntu共享主机的梯子","date":"2024-11-07T02:25:55.000Z","updated":"2024-11-07T02:42:13.452Z","comments":true,"path":"2024/11/07/ubuntu/vmware-ubuntu共享主机的梯子/","link":"","permalink":"http://example.com/2024/11/07/ubuntu/vmware-ubuntu%E5%85%B1%E4%BA%AB%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%A2%AF%E5%AD%90/","excerpt":"","text":"主机端梯子要打开 LAN 查看 VMnet8 的ip 虚拟机端和正常ubuntu设置梯子差不多","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"树莓派编译gcc","slug":"armLinux/树莓派编译gcc","date":"2024-10-30T01:16:56.000Z","updated":"2024-10-30T01:35:28.691Z","comments":true,"path":"2024/10/30/armLinux/树莓派编译gcc/","link":"","permalink":"http://example.com/2024/10/30/armLinux/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%BC%96%E8%AF%91gcc/","excerpt":"","text":"背景由于新版本的树莓派系统自带的gcc是10.2，并且没找到arm64版本的gcc。在为树莓派交叉编译Qt时使用的是linrao release版本的gcc-7.5。由于gcc版本不同，编译的库文件不兼容。 过程下载gcc连接 1https://ftp.gnu.org/gnu/gcc/ 123tar xvf gcc-7.5.0.tar.gzcd gcc-7.5.0./contrib/download_prerequisites &#x2F;* 下载依赖 *&#x2F; 1./contrib/download_prerequisites 但是如果没有梯子，一般下载失败，可以直接迅雷下载相应的源码。gmp-6.1.0.tar.bz2mpfr-3.1.4.tar.gzmpc-1.0.3.tar.gzisl-0.16.1.tar.bz2 配置注意树莓派4的CPU是a72 1../configure -v --enable-languages=c,c++ --with-cpu=cortex-a72 --build=arm-linux-gnueabihf--host=arm-linux-gnueabihf --target=arm-linux-gnueabihf --prefix=/usr/local/gcc-7.5.0 编译12make -j16sudo make install","categories":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/categories/armLinux/"}],"tags":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/tags/armLinux/"}]},{"title":"编译ASSIMP的Android库","slug":"android/编译ASSIMP的Android库","date":"2024-10-25T01:10:36.000Z","updated":"2024-10-25T01:19:50.446Z","comments":true,"path":"2024/10/25/android/编译ASSIMP的Android库/","link":"","permalink":"http://example.com/2024/10/25/android/%E7%BC%96%E8%AF%91ASSIMP%E7%9A%84Android%E5%BA%93/","excerpt":"","text":"版本assimp-5.0.1.zip 配置及编译12unzip assimp-5.0.1.zipcd assimp-5.0.1 123456mkdir buildAndroidcd buildAndroidmdkir assimp./autoConfig.shmake -j16make install 1234567891011121314151617181920cmake \\-DCMAKE_TOOLCHAIN_FILE=/home/lufahai/deepLearning/qt4android/android-ndk-r19c/build/cmake/android.toolchain.cmake \\-DCMAKE_INSTALL_PREFIX=./assimp \\-DANDROID_ABI=arm64-v8a \\-DANDROID_NATIVE_API_LEVEL=android-14 \\-DANDROID_FORCE_ARM_BUILD=TRUE \\-DANDROID_STL=c++_shared \\-DASSIMP_BUILD_ALL_IMPORTERS_BY_DEFAULT=FALSE \\-DASSIMP_BUILD_OBJ_IMPORTER=TRUE \\-DASSIMP_BUILD_FBX_IMPORTER=TRUE \\-DANDROID_NDK=/home/lufahai/deepLearning/qt4android/android-ndk-r19c \\-DCMAKE_BUILD_TYPE=Release \\-DCMAKE_CXX_FLAGS=-Wno-c++11-narrowing \\-DANDROID_TOOLCHAIN=clang \\-DASSIMP_BUILD_TESTS=OFF \\-DASSIMP_NO_EXPORT=TRUE \\-DASSIMP_BUILD_ASSIMP_TOOLS=FALSE \\-DASSIMP_BUILD_SAMPLES=FALSE \\..","categories":[{"name":"Qt4Android","slug":"Qt4Android","permalink":"http://example.com/categories/Qt4Android/"}],"tags":[{"name":"Qt4Android","slug":"Qt4Android","permalink":"http://example.com/tags/Qt4Android/"}]},{"title":"cuda 高效访问24位RGB图像","slug":"cuda/cuda-高效访问24位RGB图像","date":"2024-10-08T07:04:42.000Z","updated":"2024-10-08T07:11:51.547Z","comments":true,"path":"2024/10/08/cuda/cuda-高效访问24位RGB图像/","link":"","permalink":"http://example.com/2024/10/08/cuda/cuda-%E9%AB%98%E6%95%88%E8%AE%BF%E9%97%AE24%E4%BD%8DRGB%E5%9B%BE%E5%83%8F/","excerpt":"","text":"问题来源利用GPU进行图像处理加速时，图像格式一般是RGB 3通道图像，每个通占用一个字节，即24位像素图像． 而cuda访问数据元素时，若每个线程访问8bit,16bit,32bit,64bit时，对应数据段长可以是32Byte,64Byte,128Byte,128Byte，可以达到全局内存合并访问的要求，提高访问访问全局内存性能．若每个线程访问24bit将无法达到全局内存合并访问的要求，影响全局内存访问的性能． 解决方案将24bit数据当成32bit数据访问，处理时再从32bit数据获取对应24bit数据． 以将rgb图像转换为rgba图像为例，具体kernel代码如下： 96个32位的数据，相当于128个24位的数据，利用前96个线程将读取96个32位数据，读取时满足全局内存合并访问，再利用128个线程来处理128个24位数据，利用共享内存作为中间过渡","categories":[{"name":"cuda","slug":"cuda","permalink":"http://example.com/categories/cuda/"}],"tags":[{"name":"cuda","slug":"cuda","permalink":"http://example.com/tags/cuda/"}]},{"title":"ubuntu将/var作为内存文件并修改权限","slug":"ubuntu/ubuntu将-var作为内存文件并修改权限","date":"2024-09-01T01:14:54.000Z","updated":"2024-09-03T05:56:02.265Z","comments":true,"path":"2024/09/01/ubuntu/ubuntu将-var作为内存文件并修改权限/","link":"","permalink":"http://example.com/2024/09/01/ubuntu/ubuntu%E5%B0%86-var%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6%E5%B9%B6%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90/","excerpt":"","text":"前言设置内存文件系统由于Linux运行过程中，系统会在&#x2F;var&#x2F;log目录中频发输入日志，长期如此会导致该分区损坏，特别是安装系统的时候如果没有将&#x2F;var作为独立分区，可能会损坏根文件系统。为了避免这一问题，可以将频繁读写的&#x2F;var&#x2F;log目录挂在到内存文件系统，这样实际读写的是内存而不是硬盘分区。方法，在&#x2F;etc&#x2F;fstab中增加以下： 1tmpfs /var/log tmpfs defaults,size=2G 0 0 出现的问题描述如此挂载之后，手动在&#x2F;var&#x2F;log目录中创建文件或目录在下次开机后都会被清除，因为创建的时候是在内存中读写的。另一个问题：有些程序或系统服务需在&#x2F;var&#x2F;log目录中创建对应的目录，但是挂载到内存系统中后存在没有权限的情况，需要手动sudo 权限创建，但是手动创建又无法保存。 解决1sudo nano /usr/lib/tmpfiles.d/var.conf 把如下图的权限改为0777，保存退出即可","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"linux修复ssh及ftp等漏洞","slug":"ubuntu/linux修复ssh及ftp等漏洞","date":"2024-08-14T07:45:05.000Z","updated":"2024-08-14T08:32:48.187Z","comments":true,"path":"2024/08/14/ubuntu/linux修复ssh及ftp等漏洞/","link":"","permalink":"http://example.com/2024/08/14/ubuntu/linux%E4%BF%AE%E5%A4%8Dssh%E5%8F%8Aftp%E7%AD%89%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"问题描述问题来由： 客户使用绿盟科技”工控漏洞扫描系统”对设备进行扫面的时出现SSH 和 FTP存在漏洞，这些漏洞都是软件版本比较老导致的，因此解决方案就是升级相应的软件。 解决方式升级FTP1234567891011121314151617wget https://security.appspot.com/downloads/vsftpd-3.0.5.tar.gztar -zxvf vsftpd-3.0.5.tar.gzmake &amp;&amp; make installcd /usr/sbin/mv vsftpd vsftpd_bakcp /usr/local/sbin/vsftpd vsftpd问题： vsftpd: 500 OOPS: config file not owned by correct user, or not a file解决： sudo cp /etc/vsftpd.conf /etc/vsftpd.conf.bak 把编译出来的conf替换系统原先的 sudo cp vsftpd.conf /etc/vsftpd.conf sudo chown root vsftpd.conf 升级SSH由于openssh需要依赖openssl，因此需升级ssl 1、升级openssl 1234567891011121314151617wget --no-check-certificate https://www.openssl.org/source/openssl-3.2.0.tar.gztar -zxvf openssl-3.2.0.tar.gzcd openssl-3.2.0/./config --prefix=/usr/local/openssl sharedmakemake installsudo cp /usr/sbin/openssl /usr/sbin/openssl.baksudo cp /usr/local/openssl/sbin/openssl /usr/sbin/openssl 替换库文件ln -s /usr/local/openssl/lib64/libssl.so.3 /usr/lib/ln -s /usr/local/openssl/lib64/libcrypto.so.3 /usr/lib//usr/sbin/openssl verison 确认版本没问题 2、升级openssh 12345678910111213141516171819wget --no-check-certificate https://mirrors.aliyun.com/pub/OpenBSD/OpenSSH/portable/openssh-9.8p1.tar.gztar -zxvf openssh-9.8p1.tar.gz./configure --prefix=/usr/local/openssh --sysconfdir=/etc/ssh --with-ssl-dir=/usr/local/openssl --without-openssl-header-checkmake &amp;&amp; make install替换/usr/sbin/sshd替换/uer/bin/ssh-keygen替换/usr/bin/ssh出现问题：sshd: no hostkeys available -- exiting.解决: 1、先移除备份原先的sshkey sudo mv /etc/ssh/ssh_host* oldKey 2、重新生成 sudo ssh-keygen -A 注意，ssh-keygen是新版本编译出来的。","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"获取X11显示器的插拔信号","slug":"ubuntu/获取X11显示器的插拔信号","date":"2024-08-07T09:13:34.000Z","updated":"2024-08-07T09:19:10.018Z","comments":true,"path":"2024/08/07/ubuntu/获取X11显示器的插拔信号/","link":"","permalink":"http://example.com/2024/08/07/ubuntu/%E8%8E%B7%E5%8F%96X11%E6%98%BE%E7%A4%BA%E5%99%A8%E7%9A%84%E6%8F%92%E6%8B%94%E4%BF%A1%E5%8F%B7/","excerpt":"","text":"使用Xev1234567891011121314for (int i = 0; i &lt; 4; ++i) &#123; QString display = &quot;:1.&quot; + QString::number(i); QProcess *process = new QProcess (this); process-&gt;setObjectName(display); connect(process, &amp;QProcess::readyRead, this, &amp;Task::slotReadyRead); QString args = QString(&quot;/usr/bin/xev -d %1 -root | &quot; &quot;grep --line-buffered &#x27;connection&#x27;&quot;).arg(display); process-&gt;start(&quot;sh&quot;, QStringList() &lt;&lt; &quot;-c&quot; &lt;&lt; args); process-&gt;waitForStarted(); mProcessList.append(process);&#125; 槽函数1234567891011121314151617 void Task::slotReadyRead()&#123; QProcess* process = qobject_cast&lt;QProcess*&gt;(sender()); QString name = process-&gt;objectName(); QString msg(process-&gt;readAllStandardOutput().trimmed()); if (msg.contains(&quot;RR_Connected&quot;)) &#123; qDebug() &lt;&lt; name &lt;&lt; &quot; connected&quot;; &#125; else if (msg.contains(&quot;RR_Disconnected&quot;)) &#123; qDebug() &lt;&lt; name &lt;&lt; &quot; Disconnected&quot;; &#125;&#125;","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"QProcess 启动外部程序并通讯","slug":"Qt/QProcess-启动外部程序并通讯","date":"2024-08-05T07:54:36.000Z","updated":"2024-08-05T08:23:58.014Z","comments":true,"path":"2024/08/05/Qt/QProcess-启动外部程序并通讯/","link":"","permalink":"http://example.com/2024/08/05/Qt/QProcess-%E5%90%AF%E5%8A%A8%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F%E5%B9%B6%E9%80%9A%E8%AE%AF/","excerpt":"","text":"主程序创建及接收123mProcess = new QProcess(this);connect(mProcess, &amp;QProcess::readyRead, this, &amp;Task::readReady);mProcess-&gt;start(&quot;subProcess&quot;); 写入12345if (mProcess-&gt;isOpen()) &#123; QString msg = QString(&quot;cnt = %1&quot;).arg(cnt++); qDebug() &lt;&lt; &quot;main send: &quot; &lt;&lt; msg; mProcess-&gt;write(msg.toLatin1());&#125; 外部程序创建使用QFile 和 QSocketNotifier接受stdin消息 123456789QFile mFileRead;QSocketNotifier *mNotifier;mFileRead.open(stdin, QFile::ReadOnly);if (mFileRead.isOpen()) &#123; mNotifier = new QSocketNotifier(mFileRead.handle(), QSocketNotifier::Read, this); connect(mNotifier, SIGNAL(activated(int)), this, SLOT(readyRead(int)));&#125; 接收12345678910if (handle == mFileRead.handle()) &#123; char mRec[128]; int ret = read(mFileRead.handle(), mRec, sizeof(mRec)); mRec[ret] = 0; QString msg = QString::fromLatin1(mRec); qDebug() &lt;&lt; &quot;sub receive: &quot; &lt;&lt; msg; write(1, msg.toLatin1(), msg.length());&#125; 注意事项process 创建的问题QProcess 最好定义成成员指针变量，然后new 方法传入的父类是this, 如果直接定义QProcess为成员变量，则在有些外部程序可能收不到stdin的消息。 外部进程写的问题外部程序写入stdout的时候，QFile不能再构造函数中open一次，然后在其他函数write，这样主进程接收不到。如果要使用QFile, 则应该创建内部变量QFile，然后每次都要open后再write。不过这种方法比较繁琐，可以直接调用Linux环境自带的write函数写入stdout","categories":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"Qt TimeEdit的处理技巧","slug":"Qt/Qt-TimeEdit的处理技巧","date":"2024-06-21T01:04:26.000Z","updated":"2024-06-21T01:16:22.322Z","comments":true,"path":"2024/06/21/Qt/Qt-TimeEdit的处理技巧/","link":"","permalink":"http://example.com/2024/06/21/Qt/Qt-TimeEdit%E7%9A%84%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/","excerpt":"","text":"现象描述timeEdit有的槽函数 on_timeEdit_userTimeChanged(const QTime &amp;time)，无论是用户修改的还是系统自动更新的，只要显示的时间改变就会执行此函数。 一般会在这个槽函数中同步系统的时间，但是测试同时观察到一个现象，如果每分钟系统时间改变的话，时间会变慢一点。 应该是和秒数有关，观察过几次秒数，显示都是0。 而正确的用法是忽略系统自动更新的时间，只在用户修改的时候做同步。 步骤timeEdit控件先注册个事件过滤。 1ui-&gt;timeEdit-&gt;installEventFilter(this); 在其父类的事件过滤函数中对这个控件的焦点做判断，确认是否是用户编辑。 12345678910111213bool Parent::eventFilter(QObject *obj, QEvent *event)&#123; if (obj == ui-&gt;timeEdit) &#123; if (event-&gt;type() == QEvent::FocusIn) &#123; mTimeChangedByManual = true; &#125; else if (event-&gt;type() == QEvent::FocusOut) &#123; mTimeChangedByManual = false; &#125; &#125; return QWidget::eventFilter(obj, event);&#125; 然后在它的槽函数中同步时间 1234567891011121314void Parent::on_timeEdit_userTimeChanged(const QTime &amp;time)&#123; if ( !mTimeChangedByManual) return; QString command; command = QString(&quot;date +%T -s %1:%2:%3&quot;) .arg(time.hour()) .arg(time.minute()) .arg(time.second()); runLinuxCommand(command); syncTimeSysToHw();&#125;","categories":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"debian12解决安装搜狗拼音的问题","slug":"ubuntu/debian12解决安装搜狗拼音的问题","date":"2024-06-20T01:14:18.000Z","updated":"2024-06-20T01:21:52.256Z","comments":true,"path":"2024/06/20/ubuntu/debian12解决安装搜狗拼音的问题/","link":"","permalink":"http://example.com/2024/06/20/ubuntu/debian12%E8%A7%A3%E5%86%B3%E5%AE%89%E8%A3%85%E6%90%9C%E7%8B%97%E6%8B%BC%E9%9F%B3%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题描述https://shurufa.sogou.com/linux/guide 跟着搜狗官方的教程安装好搜狗输入法后，可以切换到搜狗输入法，可以打出中文标点。但是候选框中没有中文字符。 解决方式参考 https://blog.csdn.net/wesleyflagon/article/details/131564216使用ldd &#x2F;opt&#x2F;sogoupinyin&#x2F;files&#x2F;bin&#x2F;sogoupinyin-service出现 &#x2F;opt&#x2F;sogoupinyin&#x2F;files&#x2F;bin&#x2F;..&#x2F;lib&#x2F;qt5&#x2F;lib&#x2F;libQt5Gui.so.5: no version information 最简单的办法，把安装的qt 直接复制到 &#x2F;opt&#x2F;sogoupinyin&#x2F;files&#x2F;lib&#x2F;qt5&#x2F;lib重新ldd就可以，输入中文也可以 记录Debian12 中可能需要安装im-config 来配置input method 为fcitx框架。 不要使用fcitx5，它和搜狗不兼容。","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"linux plymouth开机动画--终极版","slug":"armLinux/linux-plymouth开机动画-终极版","date":"2024-06-18T11:50:00.000Z","updated":"2024-10-30T01:41:26.403Z","comments":true,"path":"2024/06/18/armLinux/linux-plymouth开机动画-终极版/","link":"","permalink":"http://example.com/2024/06/18/armLinux/linux-plymouth%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB-%E7%BB%88%E6%9E%81%E7%89%88/","excerpt":"","text":"前言以前的开机动画是一张静态的图片, 可以多张图片做成动态。 主要参考： https://github.com/krishnan793/PlymouthTheme-Cat https://github.com/jcklpe/Plymouth-Animated-Boot-Screen-Creator 问题记录在老机器上试的时候，发现只有开机的时候显示动画，关机的时候会出现命令行，提示某些服务关闭。gpt的回答是： 修改&#x2F;etc&#x2F;default&#x2F;grub 找到 GRUB_CMDLINE_LINUX_DEFAULT 行，将其中的 quiet splash 替换为 quiet splash plymouth.ignore-serial-consoles 验证后发现关机的时候不显示命令行了，暂时满足需求。 后续由于plymouth需要依赖exim4邮件服务，但是apt install 安装了exim4软件后它需要在&#x2F;var&#x2F;log中创建自己的日志目录，但是由于已经把&#x2F;var&#x2F;log设为tmpfs，使得exim4没有权限创建目录。如何修改参考另一篇文章。","categories":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/categories/armLinux/"}],"tags":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/tags/armLinux/"}]},{"title":"使用cuda将各种YUV转为RGBA","slug":"cuda/使用cuda将各种YUV转为RGBA","date":"2024-06-14T06:17:54.000Z","updated":"2024-06-14T07:34:35.040Z","comments":true,"path":"2024/06/14/cuda/使用cuda将各种YUV转为RGBA/","link":"","permalink":"http://example.com/2024/06/14/cuda/%E4%BD%BF%E7%94%A8cuda%E5%B0%86%E5%90%84%E7%A7%8DYUV%E8%BD%AC%E4%B8%BARGBA/","excerpt":"","text":"YUV420以下是YUV420常见的格式，图中的颜色对应关系说明了Y U V三个分量之间的关系。总体的思路是分解出YUV三个分量，然后再转为RGBA I420 &amp; YV12I420在内存中的存储方式为先存储 width * height 个 Y 分量，然后在存储 width * height &#x2F; 4 个 U 分量，最后是 width * height &#x2F; 4 个 V 分量； 而YV12 是 先 V 后 Y， 存储方式一样。 根据图中颜色对应关系，可以写出如下cuda代码，核心是要理解stepUV的计算： int stepUV &#x3D; (dy &#x2F; 2 * iWidth + dx) &#x2F; 2;由于 Y1 Y2 Y7 Y8共用一组 U1 和 V1， 因此 dy 方向要除以2，而x方向上两个Y对应一组UV, 因此需要括号内的部分除以2.idx1 和 idx2 分别是UV分量，可以根据I420或YV12 决定谁先谁后。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#define NUM_THREAD_X 32#define NUM_THREAD_Y 8static int DivUp(int a, int b)&#123; return ((a % b) != 0) ? (a / b + 1) : (a / b);&#125;__global__ void cuI420_YV12_to_rgba8(const unsigned char *pSrc, unsigned char *pDst, int iWidth, int iHeight, bool isI420)&#123; const int dx = blockIdx.x * blockDim.x + threadIdx.x; const int dy = blockIdx.y * blockDim.y + threadIdx.y; if (dx &lt; iWidth &amp;&amp; dy &lt; iHeight) &#123; unsigned char y, u, v; int indexY = dy * iWidth + dx; y = pSrc[indexY]; int idx1 = iWidth * iHeight; int idx2 = iWidth * iHeight * 5 / 4; int idxU = isI420 ? idx1 : idx2; int idxV = isI420 ? idx2 : idx1; /* core */ int stepUV = (dy / 2 * iWidth + dx) / 2; u = pSrc[stepUV + idxU]; v = pSrc[stepUV + idxV]; int r = y + 1.402 * (v - 128); int g = y - 0.344136 * (u - 128) - 0.714136 * (v - 128); int b = y + 1.772 * (u - 128); r = min(max(r, 0), 255); g = min(max(g, 0), 255); b = min(max(b, 0), 255); int idxRgba = (dy * iWidth + dx) * 4; pDst[idxRgba] = r; pDst[idxRgba + 1] = g; pDst[idxRgba + 2] = b; pDst[idxRgba + 3] = 255; &#125;&#125;extern &quot;C&quot;void i420_yv12_to_rgba8(const unsigned char *pSrc, unsigned char *pDst, int iWidth, int iHeight, bool isI420)&#123; dim3 blockSize(NUM_THREAD_X, NUM_THREAD_Y); dim3 gridSize(DivUp(iWidth, blockSize.x), DivUp(iHeight, blockSize.y)); cuI420_YV12_to_rgba8&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;(pSrc, pDst, iWidth, iHeight, isI420);&#125; NV12 &amp;&amp; NV21NV12在内存中的存储方式为先存储 width * height 个 Y 分量，然后UV交替存储，长度为width * height &#x2F; 2NV21与之的区别在于UV谁先谁后。 根据图中颜色对应关系，可以写出如下cuda代码，核心是要理解uvStep的计算： int uvStep &#x3D; dy &#x2F; 2 * iWidth + dx;由于 Y1 Y2 Y7 Y8共用一组 U1 和 V1， 因此 dy 方向要除以2；可以根据dx为奇数还是偶数，确定出UV分量，举个例子，对于NV12来说，当dx&#x3D;0，为偶数时，取到的时U分量，而与之对应的V分量为 dx+1; 当dx&#x3D;1，为奇数时，取到的时V分量，但是这个时候与之对应的U分量是前一个即dx-1,而不是后一个dx+1。 而对于NV21来说UV的顺序刚好相反，可以根据NV12或NV21决定谁先谁后。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#define NUM_THREAD_X 32#define NUM_THREAD_Y 8static int DivUp(int a, int b)&#123; return ((a % b) != 0) ? (a / b + 1) : (a / b);&#125;__global__ void cuNV12_21_to_rgba8(const unsigned char *pSrc, int uvIndex, unsigned char *pDst, int iWidth, int iHeight, bool isNv12)&#123; const int dx = blockIdx.x * blockDim.x + threadIdx.x; const int dy = blockIdx.y * blockDim.y + threadIdx.y; if (dx &lt; iWidth &amp;&amp; dy &lt; iHeight) &#123; unsigned char y, u, v; int idxY, idxU, idxV; idxY = dy * iWidth + dx; y = pSrc[idxY]; int idx1, idx2; int uvStep = dy / 2 * iWidth + dx; if (dx % 2) &#123; //column odd idx1 = uvStep - 1; idx2 = uvStep; &#125; else &#123; //column even idx1 = uvStep; idx2 = uvStep + 1; &#125; idxU = isNv12 ? idx1 : idx2; idxV = isNv12 ? idx2 : idx1; u = pSrc[uvIndex + idxU]; v = pSrc[uvIndex + idxV]; int r = y + 1.402 * (v - 128); int g = y - 0.344136 * (u - 128) - 0.714136 * (v - 128); int b = y + 1.772 * (u - 128); r = min(max(r, 0), 255); g = min(max(g, 0), 255); b = min(max(b, 0), 255); int idxRgba = (dy * iWidth + dx) * 4; pDst[idxRgba] = r; pDst[idxRgba + 1] = g; pDst[idxRgba + 2] = b; pDst[idxRgba + 3] = 255; &#125;&#125;extern &quot;C&quot;void nv12_21_to_rgba8(const unsigned char *pSrc, int uvIndex, unsigned char *pDst, int iWidth, int iHeight, bool isNv12)&#123; dim3 blockSize(NUM_THREAD_X, NUM_THREAD_Y); dim3 gridSize(DivUp(iWidth, blockSize.x), DivUp(iHeight, blockSize.y)); cuNV12_21_to_rgba8&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;(pSrc, uvIndex, pDst, iWidth, iHeight, isNv12);&#125; YUYVYUYV422是USB摄像头中上传的数据之一，格式以及在内存中的存储方式如图。 同理，两组Y共用一组UV，根据上图可以写出对应的代码，主要理解yuyvIdx的计算。思路是确定起始Y，由于每个起始Y的间隔为2(Y之间的间隔)，因此只需遍历width &#x2F;2，根据idx * 2 就能确定每一个Y而每两组Y之间有带着一组UV，因此每组YUYV之间的间隔 (dy * width + dx * 2) * 2; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#define NUM_THREAD_X 32#define NUM_THREAD_Y 8static int DivUp(int a, int b)&#123; return ((a % b) != 0) ? (a / b + 1) : (a / b);&#125;__global__ void cuYUYV422_to_rgba8(const unsigned char *yuvImage, unsigned char *rgbaImage, int width, int height)&#123; const int dx = blockIdx.x * blockDim.x + threadIdx.x; const int dy = blockIdx.y * blockDim.y + threadIdx.y; // 2 pixels per process unit if (dx &lt; width/2 &amp;&amp; dy &lt; height) &#123; int index = dy * width + dx * 2; int yuyvIdx = index * 2; int rgbaIdx = index * 4; // fetch unsigned char y0 = yuvImage[yuyvIdx]; unsigned char u = yuvImage[yuyvIdx + 1]; unsigned char y1 = yuvImage[yuyvIdx + 2]; unsigned char v = yuvImage[yuyvIdx + 3]; // YUYV to RGB int r0 = y0 + 1.402 * (v - 128); int g0 = y0 - 0.344136 * (u - 128) - 0.714136 * (v - 128); int b0 = y0 + 1.772 * (u - 128); int r1 = y1 + 1.402 * (v - 128); int g1 = y1 - 0.344136 * (u - 128) - 0.714136 * (v - 128); int b1 = y1 + 1.772 * (u - 128); // clamp r0 = min(max(r0, 0), 255); g0 = min(max(g0, 0), 255); b0 = min(max(b0, 0), 255); r1 = min(max(r1, 0), 255); g1 = min(max(g1, 0), 255); b1 = min(max(b1, 0), 255); // assign rgbaImage[rgbaIdx ] = r0; rgbaImage[rgbaIdx + 1] = g0; rgbaImage[rgbaIdx + 2] = b0; rgbaImage[rgbaIdx + 3] = 255; rgbaImage[rgbaIdx + 4] = r1; rgbaImage[rgbaIdx + 5] = g1; rgbaImage[rgbaIdx + 6] = b1; rgbaImage[rgbaIdx + 7] = 255; &#125;&#125;extern &quot;C&quot;void YUYV422_to_rgba8(const unsigned char *yuvImage, unsigned char *rgbaImage, int iWidth, int iHeight)&#123; dim3 blockSize(NUM_THREAD_X, NUM_THREAD_Y); dim3 gridSize(DivUp(iWidth, blockSize.x), DivUp(iHeight, blockSize.y)); cuYUYV422_to_rgba8&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;(yuvImage, rgbaImage, iWidth, iHeight);&#125;__global__ void cuYUYV422_to_rgba10A2(const unsigned char *yuvImage, unsigned int *rgbaImage, int width, int height)&#123; const int dx = blockIdx.x * blockDim.x + threadIdx.x; const int dy = blockIdx.y * blockDim.y + threadIdx.y; // 2 pixels per process unit if (dx &lt; width/2 &amp;&amp; dy &lt; height) &#123; int index = dy * width + dx * 2; int yuyvIdx = index * 2; int rgbaIdx = index; // fetch unsigned char y0 = yuvImage[yuyvIdx]; unsigned char u = yuvImage[yuyvIdx + 1]; unsigned char y1 = yuvImage[yuyvIdx + 2]; unsigned char v = yuvImage[yuyvIdx + 3]; // YUYV to RGB int r0 = y0 + 1.402 * (v - 128); int g0 = y0 - 0.344136 * (u - 128) - 0.714136 * (v - 128); int b0 = y0 + 1.772 * (u - 128); int r1 = y1 + 1.402 * (v - 128); int g1 = y1 - 0.344136 * (u - 128) - 0.714136 * (v - 128); int b1 = y1 + 1.772 * (u - 128); // clamp unsigned int ur0 = min(max(r0, 0), 255); unsigned int ug0 = min(max(g0, 0), 255); unsigned int ub0 = min(max(b0, 0), 255); unsigned int ur1 = min(max(r1, 0), 255); unsigned int ug1 = min(max(g1, 0), 255); unsigned int ub1 = min(max(b1, 0), 255); // assign rgbaImage[rgbaIdx ] = ur0 &lt;&lt; 24 | ug0 &lt;&lt; 14 | ub0 &lt;&lt; 4 | 3; rgbaImage[rgbaIdx + 1] = ur1 &lt;&lt; 24 | ug1 &lt;&lt; 14 | ub1 &lt;&lt; 4 | 3; &#125;&#125;extern &quot;C&quot;void YUYV422_to_rgba10A2(const unsigned char *yuvImage, unsigned int *rgbaImage, int iWidth, int iHeight)&#123; dim3 blockSize(NUM_THREAD_X, NUM_THREAD_Y); dim3 gridSize(DivUp(iWidth, blockSize.x), DivUp(iHeight, blockSize.y)); cuYUYV422_to_rgba10A2&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;(yuvImage, rgbaImage, iWidth, iHeight);&#125;","categories":[{"name":"cuda","slug":"cuda","permalink":"http://example.com/categories/cuda/"}],"tags":[{"name":"cuda","slug":"cuda","permalink":"http://example.com/tags/cuda/"}]},{"title":"OpenGL--PBO","slug":"OpenGl/OpenGL-PBO","date":"2024-06-08T09:23:21.000Z","updated":"2024-06-08T10:14:22.353Z","comments":true,"path":"2024/06/08/OpenGl/OpenGL-PBO/","link":"","permalink":"http://example.com/2024/06/08/OpenGl/OpenGL-PBO/","excerpt":"","text":"一、概述一图理清PBO Framebuffer和Texture之间的关系在上图中，PBO是Texture和FrameBuffer之间的重要桥梁，PBO中的图像数据可以直接unpack给Texture用于渲染； 而FrameBuffer中的数据(渲染后的图像)也可以直接pack回PBO。要使用这两种功能，之前应该注意，在定义PBO的时候指定它的用途。GL_PIXEL_UNPACK_BUFFER代表这个PBO用于将图像数据从PBO传给TextureGL_PIXEL_PACK_BUFFER代表这个PBO用于从FrameBuffer将渲染后的图像回读到此PBO。需要说明的是，PBO到Framebuffer或Texture之间的数据传输是有DMA在后台执行，也就是CPU可以立即返回，无需阻塞等待。并且传输速度是非常快的 。 unpack操作：glDrawPixels(), glTexImage2D() glTexSubImage2D()，这几个函数都是unpack，目的是将PBO中的数据传给Texture其中glTexSubImage2D效率是三者中最高的。 pack操作glReadPixels() and glGetTexImage() 这两个是pack操作，也就是将渲染后的图像数据回读到PBO中 ，一般glReadPixels的效率高一些。 二、使用PBO绘制对比如上图所示，如果不使用PBO,则需要调用glTexImage2D传入图片的指针地址，进而传给Texture，这个过程是在CPU内存中完成的。需要消耗CPU的资源。效率不高。 如上图所示，如果使用PBO，则只需要将图像帧指针地址与PBO绑定一次，需要传输的时候，只需调用一次glTexSubImage2D()，图像数据就能通过DMA传给Texture，cpu立即返回，并且DMA的传输效率很高。 使用多个PBO在高帧率的场合，可以使用多个PBO来向Texture传输图像数据，前提是显示器的刷新率要能处理得过来。 cuda绑定上面说的图像指针与PBO绑定指的是CPU指针地址。其实cuda提供了与opengl互动的接口，只需要将cuda内存地址与PBO绑定，那么GPU内存中的图像数据就能直接在OpenGL上渲染，无需经过cpu的memcpy，提高效率。demo可以参考gitalab上的例子。 三、使用PBO回读如果不使用PBO，那么调用一次glReadPixels读取一个4K的图像数据，需要花费大约30ms的时间，严重影响性能，导致掉帧。 为了保证程序的鲁棒性，使用PBO回读的时候一般是两个PBO一起使用，在第n次的循环中，调用glReadPixels把图像传给PBO2, 此时PBO1在第n-1次中已经获得图像数据，这时候就可以从PBO1中取数据。在下一个循环中两个PBO调换一下角色，把图像跟新到PBO1，此时在第n次循环中，图像数据早已存在PBO2中，可以直接读取。 同理可以直接与cuda内存指针绑定，用于cuda内部硬件编码。 需要注意的是，在测试的过程中发现，在x11窗口中，如果xorg.conf配置文件不正确，则无法与cuda绑定，读取图片是会阻塞等待30ms，具体情况参考另外一篇博客。 具体例子可以参考gitlab中的示例代码。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://example.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://example.com/tags/OpenGL/"}]},{"title":"OpenGL--VBO","slug":"OpenGl/OpenGL-VBO","date":"2024-06-08T07:38:07.000Z","updated":"2024-06-08T10:14:24.669Z","comments":true,"path":"2024/06/08/OpenGl/OpenGL-VBO/","link":"","permalink":"http://example.com/2024/06/08/OpenGl/OpenGL-VBO/","excerpt":"","text":"一、概述GL_ARB_vertex_buffer_object扩展提供了顶点数组和显示列表等功能，这些功能可以在opengl渲染的时候避免重复的数据传输，提高opengl的性能。VBO允许一系列的顶点数据保存显存中，如果这个显存是用来存储像素数据，那么它被称为PBO。使用顶点数组可以减少调用相关的函数，并且增加顶点数据的重复利用。 一、创建PBO步骤1: 使用glGenBuffers()创建一个顶点缓冲区。1void glGenBuffers(GLsizei n, GLuint* ids) 步骤2: 使用glBindBuffer()绑定这个顶点缓冲区。1void glBindBuffer(GLenum target, GLuint id) Target参数是为了告诉VBO所要保存的数据是顶点数据GL_ARRAY_BUFFER还是顶点偏移数据GL_ELEMENT_ARRAY_BUFFER。一旦调用glBindBuffer，VBO就会将这个buffer初始化为空的缓冲区(大小为0)。 步骤3: 使用glBindBuffer()传入顶点数据1void glBufferData(GLenum target, GLsizei size, const void* data, GLenum usage) 前3个参数指的是数据的类型、大小和数据指针，最后一个参数代表这些数据是如何被使用的，可选的参数如下： 123456789GL_STATIC_DRAWGL_STATIC_READGL_STATIC_COPYGL_DYNAMIC_DRAWGL_DYNAMIC_READGL_DYNAMIC_COPYGL_STREAM_DRAWGL_STREAM_READGL_STREAM_COPY 在上面这9中使用标志中，带有Staic静态标识的说明VBO中的data是无法被修改的，带有Dynamic动态标识的说明数据在使用的过程中会被经常修改。而带有Draw后缀的说明这个顶点数据是为了给OpenGL用来渲染，而带有Read后缀的说明这个顶点数据是为了从OpenGL中回读，而Copy后缀代表既可以用作Draw也可以用做Read.值得注意的是，Draw这个标识仅仅在VBO中才生效，而Read和copy标识一般是用在PBO和FBO中，用于从OpenGL中回读渲染后的场景。 glBufferSubData()和glBufferData()一样，glBufferSubData用来将数据传给VBO,但是它仅更新buffer中现有的数据，用被指定的数据偏移开始。因此在使用glBufferSubData之前一定要使用glBufferData设定整个buffer的大小。 glDeleteBuffers()用于删除不再使用的VBO VBO的使用例子1234567891011121314151617181920GLuint vboId; // ID of VBOGLfloat* vertices = new GLfloat[vCount*3]; // create vertex array...// generate a new VBO and get the associated IDglGenBuffers(1, &amp;vboId);// bind VBO in order to useglBindBuffer(GL_ARRAY_BUFFER, vboId);// upload data to VBOglBufferData(GL_ARRAY_BUFFER, dataSize, vertices, GL_STATIC_DRAW);// it is safe to delete after copying data to VBOdelete [] vertices;...// delete VBO when program terminatedglDeleteBuffers(1, &amp;vboId); 二、绘制PBO123456789101112131415161718192021222324// bind VBOs for vertex array and index arrayglBindBuffer(GL_ARRAY_BUFFER, vboId1); // for vertex attributesglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboId2); // for indicesglEnableClientState(GL_VERTEX_ARRAY); // activate vertex position arrayglEnableClientState(GL_NORMAL_ARRAY); // activate vertex normal arrayglEnableClientState(GL_TEXTURE_COORD_ARRAY); // activate texture coord array// do same as vertex array except pointerglVertexPointer(3, GL_FLOAT, stride, offset1); // last param is offset, not ptrglNormalPointer(GL_FLOAT, stride, offset2);glTexCoordPointer(2, GL_FLOAT, stride, offset3);// draw 6 faces using offset of index arrayglDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_BYTE, 0);glDisableClientState(GL_VERTEX_ARRAY); // deactivate vertex position arrayglDisableClientState(GL_NORMAL_ARRAY); // deactivate vertex normal arrayglDisableClientState(GL_TEXTURE_COORD_ARRAY); // deactivate vertex tex coord array// bind with 0, so, switch back to normal pointer operationglBindBuffer(GL_ARRAY_BUFFER, 0);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); 从OpenGL 2.0开始就提供了glVertexAttribPointer(), glEnableVertexAttribArray() 和glDisableVertexAttribArray() 函数来传入多种顶点数据，只需要指定偏移即可 12345678910111213141516171819202122232425// bind VBOs for vertex array and index arrayglBindBuffer(GL_ARRAY_BUFFER, vboId1); // for vertex coordinatesglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboId2); // for indicesglEnableVertexAttribArray(attribVertex); // activate vertex position arrayglEnableVertexAttribArray(attribNormal); // activate vertex normal arrayglEnableVertexAttribArray(attribTexCoord); // activate texture coords array// set vertex arrays with generic APIglVertexAttribPointer(attribVertex, 3, GL_FLOAT, false, stride, offset1);glVertexAttribPointer(attribNormal, 3, GL_FLOAT, false, stride, offset2);glVertexAttribPointer(attribTexCoord, 2, GL_FLOAT, false, stride, offset3);// draw 6 faces using offset of index arrayglDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_BYTE, 0);glDisableVertexAttribArray(attribVertex); // deactivate vertex positionglDisableVertexAttribArray(attribNormal); // deactivate vertex normalglDisableVertexAttribArray(attribTexCoord); // deactivate texture coords// bind with 0, so, switch back to normal pointer operationglBindBuffer(GL_ARRAY_BUFFER, 0);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://example.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://example.com/tags/OpenGL/"}]},{"title":"nvidia cuglInter PBO获取opengl总结","slug":"OpenGl/nvidia-cuglInter-PBO获取opengl的问题记录","date":"2024-05-30T02:42:51.000Z","updated":"2024-07-11T07:38:41.526Z","comments":true,"path":"2024/05/30/OpenGl/nvidia-cuglInter-PBO获取opengl的问题记录/","link":"","permalink":"http://example.com/2024/05/30/OpenGl/nvidia-cuglInter-PBO%E8%8E%B7%E5%8F%96opengl%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"问题描述需要根据xorg配置的是10位屏幕还是8位屏幕来确定读取，如歌对应不上，虽然也能获取到视频，但是会占用很多CPU资源，导致严重掉帧。 解决方法8位12 glBindBuffer(GL_PIXEL_PACK_BUFFER, mBufId);glReadPixels(0, 0, mScreenSize.width(), mScreenSize.height(), GL_RGBA, GL_UNSIGNED_BYTE, 0); 重新写入给另外一个Texture: 1glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL); 10位12 glBindBuffer(GL_PIXEL_PACK_BUFFER, mBufId);glReadPixels(0, 0, mScreenSize.width(), mScreenSize.height(), GL_RGBA, GL_UNSIGNED_INT_2_10_10_10_REV, 0); 重新写入给另外一个Texture: 1glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_INT_2_10_10_10_REV, NULL);","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://example.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://example.com/tags/OpenGL/"}]},{"title":"Intel xorg播放视频踩坑记录","slug":"ubuntu/Intel-xorg播放视频踩坑记录","date":"2024-05-17T05:44:08.000Z","updated":"2024-05-17T06:23:27.355Z","comments":true,"path":"2024/05/17/ubuntu/Intel-xorg播放视频踩坑记录/","link":"","permalink":"http://example.com/2024/05/17/ubuntu/Intel-xorg%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"问题由来踩坑1intel默认使用的是SNA作为硬件加速，但是在某些触摸屏上出现QT虚拟键盘花屏的情况。 因此把加速方式改为uax。 可以解决Qt虚拟键盘花屏的问题。 踩坑2但是把加速方式改为uax会带来第二个问题，就是xvideo扩展无法使用，当执行xvinfo查询时，显示no adapter, 这也就导致了无法使用gstreamer 插件xvimagesink，造成很多视频播放的问题。 12xvinfo -display :0返回： no adaptor present 但是把加速方式改回sna时就能支持xvideo，只需要解决虚拟键盘花屏的问题。 解决如下： 把DRI 设为1，注意如果DRI设为3，虚拟键盘虽不花屏，但效果不好。 完整的xorg配置如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475Section &quot;ServerFlags&quot; Option &quot;AllowMouseOpenFail&quot; &quot;FALSE&quot; Option &quot;AutoAddDevices&quot; &quot;TRUE&quot; Option &quot;AutoEnableDevices&quot; &quot;TRUE&quot; Option &quot;AutoAddGPU&quot; &quot;FALSE&quot; Option &quot;DontZap&quot; &quot;ON&quot; Option &quot;DontZoom&quot; &quot;ON&quot; Option &quot;DontVTSwitch&quot; &quot;ON&quot; Option &quot;BlankTime&quot; &quot;0&quot; Option &quot;StandbyTime&quot; &quot;0&quot; Option &quot;SuspendTime&quot; &quot;0&quot; Option &quot;OffTime&quot; &quot;0&quot;EndSectionSection &quot;ServerLayout&quot; Identifier &quot;Touch&quot; Screen 0 &quot;Screen.Touch&quot; 0 0 InputDevice &quot;Mouse0&quot; &quot;CorePointer&quot; InputDevice &quot;Keyboard0&quot; &quot;CoreKeyboard&quot;EndSectionSection &quot;InputDevice&quot; Identifier &quot;Keyboard0&quot; Driver &quot;kbd&quot;EndSectionSection &quot;InputDevice&quot; Identifier &quot;Mouse0&quot; Driver &quot;mouse&quot; Option &quot;Protocol&quot; &quot;auto&quot; Option &quot;Device&quot; &quot;/dev/psaux&quot; Option &quot;Emulate3Buttons&quot; &quot;no&quot; Option &quot;ZAxisMapping&quot; &quot;4 5&quot;EndSectionSection &quot;Monitor&quot; Identifier &quot;Monitor.Touch&quot; #Option &quot;Rotate&quot; &quot;inverted&quot;EndSectionSection &quot;Module&quot; Load &quot;dri3&quot;EndSectionSection &quot;Device&quot; Identifier &quot;Device.Intel&quot; Driver &quot;intel&quot; BusID &quot;PCI:0:2:0&quot; Option &quot;monitor-eDP1&quot; &quot;Monitor.Touch&quot; Option &quot;TearFree&quot; &quot;true&quot; Option &quot;XvPreferOverlay&quot; &quot;true&quot; Option &quot;AccelMethod&quot; &quot;sna&quot; Option &quot;DRI&quot; &quot;1&quot;EndSectionSection &quot;Screen&quot; Identifier &quot;Screen.Touch&quot; Device &quot;Device.Intel&quot; Monitor &quot;Monitor.Touch&quot; SubSection &quot;Display&quot; Depth 24 EndSubSectionEndSectionSection &quot;Screen&quot; Identifier &quot;TouchScreen&quot; Device &quot;IntelGPU&quot; Monitor &quot;Monitor1&quot; SubSection &quot;Display&quot; Depth 24 EndSubSectionEndSection","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"gstreamer截取视频局部区域并放大播放","slug":"gstreamer/gstreamer截取视频局部区域并放大播放","date":"2024-05-16T11:17:14.000Z","updated":"2024-05-16T11:45:11.403Z","comments":true,"path":"2024/05/16/gstreamer/gstreamer截取视频局部区域并放大播放/","link":"","permalink":"http://example.com/2024/05/16/gstreamer/gstreamer%E6%88%AA%E5%8F%96%E8%A7%86%E9%A2%91%E5%B1%80%E9%83%A8%E5%8C%BA%E5%9F%9F%E5%B9%B6%E6%94%BE%E5%A4%A7%E6%92%AD%E6%94%BE/","excerpt":"","text":"配置过程方法需求来源：一个4K 3D top-down格式的视频，只需要全屏播放上半部分。思路：使用插件videocrop截取视频的上半部分，其分辨率为3840x1080，然后使用videoscale重新放大为4K视频。 测试pipeline为： 1gst-launch-1.0 videotestsrc ! video/x-raw,width=3840,height=2160 ! videocrop bottom=1080 ! videoscale add-borders=false ! video/x-raw,width=3840,height=2160 ! glimagesink 但是这样全屏播放的视频，视频的真正部分还是只有3840x1080，尽管我们已经色设置了 videoscale 的add-borders&#x3D;false 效果如下： 优化只需要对glimagesink的像素比例重新设定即可，可根据实际情况调整。 1gst-launch-1.0 videotestsrc ! video/x-raw,width=3840,height=2160 ! videocrop bottom=1080 ！videoscale ! video/x-raw,width=3840,height=2160 ! glimagesink pixel-aspect-ratio=1920/976 效果如下：","categories":[{"name":"gstreamer","slug":"gstreamer","permalink":"http://example.com/categories/gstreamer/"}],"tags":[{"name":"gstreamer","slug":"gstreamer","permalink":"http://example.com/tags/gstreamer/"}]},{"title":"jetsonNano将DP和HDMI配置成独立的xorg screen","slug":"armLinux/jetsonNano将DP和HDMI配置成独立的xorg-screen","date":"2024-05-09T11:51:58.000Z","updated":"2024-10-30T01:41:26.411Z","comments":true,"path":"2024/05/09/armLinux/jetsonNano将DP和HDMI配置成独立的xorg-screen/","link":"","permalink":"http://example.com/2024/05/09/armLinux/jetsonNano%E5%B0%86DP%E5%92%8CHDMI%E9%85%8D%E7%BD%AE%E6%88%90%E7%8B%AC%E7%AB%8B%E7%9A%84xorg-screen/","excerpt":"","text":"xorg.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 # cat /etc/X11/xorg.conf# Copyright (c) 2011-2015 NVIDIA CORPORATION. All Rights Reserved.## This is the minimal configuration necessary to use the Tegra driver.# Please refer to the xorg.conf man page for more configuration# options provided by the X server, including display-related options# provided by RandR 1.2 and higher.# Disable extensions not useful on Tegra.Section &quot;Module&quot; Disable &quot;dri&quot; SubSection &quot;extmod&quot; Option &quot;omit xfree86-dga&quot; EndSubSectionEndSectionSection &quot;Device&quot; Identifier &quot;Device0&quot; Driver &quot;nvidia&quot; Screen 0 Option &quot;UseDisplayDevice&quot; &quot;HDMI-0&quot; Option &quot;AllowEmptyInitialConfiguration&quot; &quot;true&quot; Option &quot;AddARGBGLXVisuals&quot; &quot;true&quot; Option &quot;ConnectToAcpid&quot; &quot;false&quot; Option &quot;TegraReserveDisplayBandwidth&quot; &quot;false&quot;EndSectionSection &quot;Device&quot; Identifier &quot;Device1&quot; Driver &quot;nvidia&quot; Screen 1 Option &quot;UseDisplayDevice&quot; &quot;DP-0&quot; Option &quot;AllowEmptyInitialConfiguration&quot; &quot;true&quot; Option &quot;AddARGBGLXVisuals&quot; &quot;true&quot; Option &quot;ConnectToAcpid&quot; &quot;false&quot; Option &quot;TegraReserveDisplayBandwidth&quot; &quot;false&quot;EndSectionSection &quot;Monitor&quot; Identifier &quot;Monitor0&quot; HorizSync 18.0 - 99.0 VertRefresh 23.0 - 62.0EndSectionSection &quot;Screen&quot; Identifier &quot;Screen0&quot; Device &quot;Device0&quot; Monitor &quot;Monitor0&quot;EndSectionSection &quot;Monitor&quot; Identifier &quot;Monitor1&quot; HorizSync 18.0 - 99.0 VertRefresh 23.0 - 62.0EndSectionSection &quot;Screen&quot; Identifier &quot;Screen1&quot; Device &quot;Device1&quot; Monitor &quot;Monitor1&quot;EndSectionSection &quot;ServerLayout&quot; Identifier &quot;ServerLayout0&quot; Screen 0 &quot;Screen0&quot; 0 0 Screen 1 &quot;Screen1&quot; 0 0 Option &quot;Xinerama&quot; &quot;0&quot;EndSection url:https://forums.developer.nvidia.com/t/multi-screen-configuration-puts-second-monitor-on-first-screen-if-not-initially-connected/143823","categories":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/categories/armLinux/"}],"tags":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/tags/armLinux/"}]},{"title":"nvidia显卡xorg多种配置方案","slug":"ubuntu/nvidia显卡xorg多种配置方案","date":"2024-05-09T11:50:57.000Z","updated":"2025-05-09T08:39:12.855Z","comments":true,"path":"2024/05/09/ubuntu/nvidia显卡xorg多种配置方案/","link":"","permalink":"http://example.com/2024/05/09/ubuntu/nvidia%E6%98%BE%E5%8D%A1xorg%E5%A4%9A%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88/","excerpt":"","text":"两个显示器同一个screenDISPLAY都是 1，显示器为扩展方式，坐标分别为3840x2160+0+0 和 3840x2160+3840+0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Section &quot;ServerFlags&quot; Option &quot;AllowMouseOpenFail&quot; &quot;TRUE&quot; Option &quot;AutoAddDevices&quot; &quot;TRUE&quot; Option &quot;AutoEnableDevices&quot; &quot;TRUE&quot; Option &quot;AutoAddGPU&quot; &quot;FALSE&quot; Option &quot;DontZap&quot; &quot;ON&quot; Option &quot;DontZoom&quot; &quot;ON&quot; Option &quot;DontVTSwitch&quot; &quot;ON&quot; Option &quot;BlankTime&quot; &quot;0&quot; Option &quot;StandbyTime&quot; &quot;0&quot; Option &quot;SuspendTime&quot; &quot;0&quot; Option &quot;OffTime&quot; &quot;0&quot;EndSectionSection &quot;ServerLayout&quot; Identifier &quot;Main&quot; Screen 0 &quot;Screen.Main&quot; 0 0 Screen 1 &quot;Screen.1&quot; RightOf &quot;Screen.Main&quot;EndSectionSection &quot;Monitor&quot; Identifier &quot;Monitor.Main&quot;EndSectionSection &quot;Device&quot; Identifier &quot;Device.Nvidia&quot; Driver &quot;nvidia&quot; BusID &quot;PCI:1:0:0&quot;EndSectionSection &quot;Screen&quot; Identifier &quot;Screen.Main&quot; Device &quot;Device.Nvidia&quot; Monitor &quot;Monitor.Main&quot; DefaultDepth 30 SubSection &quot;Display&quot; Depth 30 EndSubSectionEndSectionSection &quot;Monitor&quot; Identifier &quot;Monitor.1&quot;EndSectionSection &quot;Screen&quot; Identifier &quot;Screen.1&quot; Device &quot;Device.Nvidia&quot; Monitor &quot;Monitor.1&quot; DefaultDepth 30 SubSection &quot;Display&quot; Depth 30 EndSubSectionEndSection 两个显示器独立screenDISPLAY分别是1.0 1.1 1.2 和1.3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112Section &quot;ServerFlags&quot; Option &quot;AllowMouseOpenFail&quot; &quot;FALSE&quot; Option &quot;AutoAddDevices&quot; &quot;TRUE&quot; Option &quot;AutoEnableDevices&quot; &quot;TRUE&quot; Option &quot;AutoAddGPU&quot; &quot;FALSE&quot; Option &quot;DontZap&quot; &quot;ON&quot; Option &quot;DontZoom&quot; &quot;ON&quot; Option &quot;DontVTSwitch&quot; &quot;ON&quot; Option &quot;BlankTime&quot; &quot;0&quot; Option &quot;StandbyTime&quot; &quot;0&quot; Option &quot;SuspendTime&quot; &quot;0&quot; Option &quot;OffTime&quot; &quot;0&quot;EndSectionSection &quot;ServerLayout&quot; Identifier &quot;Main&quot; Screen 0 &quot;Screen.Main1&quot; 0 0 Screen 1 &quot;Screen.2&quot; RightOf &quot;Screen.Main1&quot; Screen 2 &quot;Screen.3&quot; RightOf &quot;Screen.2&quot; Screen 3 &quot;Screen.4&quot; RightOf &quot;Screen.3&quot;EndSectionSection &quot;Monitor&quot; Identifier &quot;Monitor.Main1&quot;EndSectionSection &quot;Device&quot; Identifier &quot;Device.Nvidia1&quot; Driver &quot;nvidia&quot; BusID &quot;PCI:1:0:0&quot; Screen 0EndSectionSection &quot;Screen&quot; Identifier &quot;Screen.Main1&quot; Device &quot;Device.Nvidia1&quot; Monitor &quot;Monitor.Main1&quot; DefaultDepth 30 SubSection &quot;Display&quot; Depth 30 EndSubSectionEndSectionSection &quot;Monitor&quot; Identifier &quot;Monitor.2&quot;EndSectionSection &quot;Device&quot; Identifier &quot;Device.Nvidia2&quot; Driver &quot;nvidia&quot; BusID &quot;PCI:1:0:0&quot; Screen 1EndSectionSection &quot;Screen&quot; Identifier &quot;Screen.2&quot; Device &quot;Device.Nvidia2&quot; Monitor &quot;Monitor.2&quot; DefaultDepth 30 SubSection &quot;Display&quot; Depth 30 EndSubSectionEndSectionSection &quot;Monitor&quot; Identifier &quot;Monitor.3&quot;EndSectionSection &quot;Device&quot; Identifier &quot;Device.Nvidia3&quot; Driver &quot;nvidia&quot; BusID &quot;PCI:1:0:0&quot; Screen 2EndSectionSection &quot;Screen&quot; Identifier &quot;Screen.3&quot; Device &quot;Device.Nvidia3&quot; Monitor &quot;Monitor.3&quot; DefaultDepth 30 SubSection &quot;Display&quot; Depth 30 EndSubSectionEndSectionSection &quot;Monitor&quot; Identifier &quot;Monitor.4&quot;EndSectionSection &quot;Device&quot; Identifier &quot;Device.Nvidia4&quot; Driver &quot;nvidia&quot; BusID &quot;PCI:1:0:0&quot; Screen 3EndSectionSection &quot;Screen&quot; Identifier &quot;Screen.4&quot; Device &quot;Device.Nvidia4&quot; Monitor &quot;Monitor.4&quot; DefaultDepth 30 SubSection &quot;Display&quot; Depth 30 EndSubSectionEndSection 两种方式说明第一种扩展方式优点：使用简单，只需要管理一个X server, 然后通过坐标的方式来寻址每个显示器。 缺点：多个屏幕存在时，openGl渲染延迟大，将近100ms(单屏约为70ms); 并且使用xlib提供的共享内存方式 获取屏幕内容时，多个屏幕下会占用较高的CPU，有可能和坐标寻址方式相关。 结论：只适合简单的UI应用程序，不适合渲染等对性能高的需求。 第二种独立屏幕优点：多个屏幕都会被视为单个独立屏幕，因此渲染延迟和管理与单屏无明显差异。 缺点：要动态管理多个display,尤其是在多个显示器热插拔的时候可能会有点问题，详情看下文。 结论：无论单屏还是多屏，性能方面表现较好，推荐用于实际项目。 显示器热插拔测试平台nvidia 4070显卡，有1个HDMI 和 3个DP。 测试1：所有接口均连接，再启动X每个视频输出口都能正确分配到 1.x的display, 并且无论怎么热插拔，display不会变。 测试2：只接1个或全不接，直接启动X这种情况下再依次接入显示器，可能会导致其中的两个接口公用一个display, 即两个屏幕组成了一个扩展屏。并且多次热插拔也无法改变。 解决方式为了解决热插拔导致的扩展屏问题，可以在后台开一个xev检测，如果发现新接入的display已被使用，则可以重启X，这就回到了测试1的情况，可以解决问题。具体步骤：1、先修改启动X的权限： 123456789sudo nano /etc/X11/Xwrapper.config将 allowed_users=console 改为 anybodyCannot open /dev/tty0 (Permission denied)它只接受三个值: root console 和 anybody不修改的话会报错： only console users are allowed to run the x server 2、用户加到tty组 123456sudo usermod -aG tty lufahai不然Qprocess启动xinit的时候报错: Cannot open /dev/tty0 (Permission denied)顺便加到video组sudo usermod -aG video lufahai 3、写个Qprocess管理xinit，有需要的时候重启X.可以参考gitlab的例程。 进一步优化：用Xorg取代xinit原先的方案是要创建两个用户并分别自动登录，在自家home目录下的.bash_profile通过xinit启动Xorg;xinit被启动后会自动执行home目录下的.xinitrc脚本，在这个脚本启动应用程序，并且最终的要的是脚本末尾还要while(1) sleep, 不能让这个脚本退出，否则xinit和Xorg也随之退出。 这就是为什么要两个用户分别启动不同的Xorg，因为都会while(1)死循环。启动不了另一个。 其实xinit也只是一个套壳程序，真正要启动的是Xorg，因此有更简单的方法，直接写两个后台程序,将命令 1xinit -- -config xorg.conf.main -novtswitch -sharevts -nocursor -layout Main :1 改为： 1/usr/lib/xorg/Xorg -config xorg.conf.main -novtswitch -sharevts -nocursor -layout Main :1 这就避免了需要创建.xinitrc并且还要while(1)的问题，更避免了多创建一个用户的问题。只需在同一个后台中开两个QProcess各自根据配置文件启动&#x2F;usr&#x2F;lib&#x2F;xorg&#x2F;Xorg 即可。","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"QComboBox自定义下拉框高度","slug":"Qt/QComboBox自定义下拉框高度","date":"2024-04-24T11:35:13.000Z","updated":"2024-04-24T11:41:03.083Z","comments":true,"path":"2024/04/24/Qt/QComboBox自定义下拉框高度/","link":"","permalink":"http://example.com/2024/04/24/Qt/QComboBox%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8B%E6%8B%89%E6%A1%86%E9%AB%98%E5%BA%A6/","excerpt":"","text":"下拉框子项的高度：12345setStyleSheet(&quot;QComboBox &#123; min-height: 40px; min-width: 60px; font:20pt; &#125;&quot; &quot;QComboBox QAbstractItemView &#123; font:20pt; &#125;&quot; &quot;QComboBox QAbstractItemView::item &#123; min-height: 40px; min-width: 60px; &#125;&quot;); QComboBox *combo = new QComboBox(this); combo-&gt;setView(new QListView()); 主要是通过QComboBox QAbstractItemView::item的styleSheet来定义子项高度。并且一定要使用setView(new QListView())，否则不生效。 下拉框下拉列表的高度：12ui-&gt;m_qcombxType-&gt;setEditable(true);ui-&gt;m_qcombxType-&gt;setMaxVisibleItems(10); setEditable 为true一定要放在前面，否则QComboBox是不可编辑的，后面的设置不生效。","categories":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"Qt自定义虚拟键盘高度","slug":"Qt/Qt自定义虚拟键盘高度","date":"2024-04-24T05:19:08.000Z","updated":"2024-04-24T05:30:19.434Z","comments":true,"path":"2024/04/24/Qt/Qt自定义虚拟键盘高度/","link":"","permalink":"http://example.com/2024/04/24/Qt/Qt%E8%87%AA%E5%AE%9A%E4%B9%89%E8%99%9A%E6%8B%9F%E9%94%AE%E7%9B%98%E9%AB%98%E5%BA%A6/","excerpt":"","text":"现象默认情况下qtvirtualkeyboard占据了半个屏幕，可以根据实际需求调整。 方法修改虚拟键盘源码修改源码下的文件./src/virtualkeyboard/desktopinputpanel.cpp 123456789101112131415void DesktopInputPanel::show()&#123; AppInputPanel::show(); Q_D(DesktopInputPanel); if (d-&gt;view) &#123; QRect rc = QGuiApplication::primaryScreen()-&gt;geometry(); rc.moveTo(0, rc.height()*48/100); rc.setHeight(rc.height()*62/100); repositionView(rc); //repositionView(QGuiApplication::primaryScreen()-&gt;availableGeometry()); d-&gt;view-&gt;show(); &#125;&#125; 编译和链接直接使用qmake &amp;&amp; make 编译生成动态库文件，然后替换到Qt安装目录中对应的库文件。","categories":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"解决QListWidget删除item导致崩溃的问题","slug":"Qt/解决QListWidget删除item导致崩溃的问题","date":"2024-04-23T09:54:16.000Z","updated":"2024-04-23T10:00:06.367Z","comments":true,"path":"2024/04/23/Qt/解决QListWidget删除item导致崩溃的问题/","link":"","permalink":"http://example.com/2024/04/23/Qt/%E8%A7%A3%E5%86%B3QListWidget%E5%88%A0%E9%99%A4item%E5%AF%BC%E8%87%B4%E5%B4%A9%E6%BA%83%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题QListWidge 调用clear或删除item的时候，程序直接崩溃 原因从网上看到有人分析是由于访问连接到信号itemSelectionChanged()的时隙方法中的选定项引起的 解决QListWidget在执行删除或清空前，应该把信号槽关闭，清空结束后再重新连接。 123ui-&gt;listWidget-&gt;blockSignals(true);ui-&gt;listWidget-&gt;clear();ui-&gt;listWidget-&gt;blockSignals(false);","categories":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"debian12自定义plymouth开机画面","slug":"ubuntu/debian12自定义plymouth开机画面","date":"2024-04-19T05:49:27.000Z","updated":"2024-04-19T09:07:26.207Z","comments":true,"path":"2024/04/19/ubuntu/debian12自定义plymouth开机画面/","link":"","permalink":"http://example.com/2024/04/19/ubuntu/debian12%E8%87%AA%E5%AE%9A%E4%B9%89plymouth%E5%BC%80%E6%9C%BA%E7%94%BB%E9%9D%A2/","excerpt":"","text":"配置plymonth安装plymonth及其主题1sudo apt install plymonth plymonth-themes 配置plymonth选中script作为主题 1sudo plymonth-set-default-theme script 修改script主题 1sudo nano /usr/share/plymouth/themes/script.script 可以根据实际情况修改，本次测试只是为了显示一张图片，所以把所有function都注释掉。 默认显示的debian-logo.png在&#x2F;usr&#x2F;share&#x2F;plymouth路径下，替换成需要显示的图片 1sudo cp yourPicture.png /usr/share/plymouth/debian-logo.png script主题还是会将其文件夹下的icon显示出来，简单的做法就是把其目录下的icon备份到一个新的目录下 123cd /usr/share/plymouth/themes/scriptsudo mkdir iconssudo mv ./*.png icons rebuild plymonth1sudo plymonth-set-default-theme -R script","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"Linux实时监测外接设备的插拔情况","slug":"ubuntu/Linux实时监测外接设备的插拔情况","date":"2024-04-15T11:39:54.000Z","updated":"2024-04-15T11:43:15.735Z","comments":true,"path":"2024/04/15/ubuntu/Linux实时监测外接设备的插拔情况/","link":"","permalink":"http://example.com/2024/04/15/ubuntu/Linux%E5%AE%9E%E6%97%B6%E7%9B%91%E6%B5%8B%E5%A4%96%E6%8E%A5%E8%AE%BE%E5%A4%87%E7%9A%84%E6%8F%92%E6%8B%94%E6%83%85%E5%86%B5/","excerpt":"","text":"实现过程识别在&#x2F;etc&#x2F;udev&#x2F;rules.d目录下增加 60-usb-audio.rules文件 内容如下： 123456789101112131415161718SUBSYSTEM==&quot;sound&quot;, SUBSYSTEMS==&quot;usb&quot;, DRIVERS==&quot;snd-usb-audio&quot;, ACTION==&quot;add&quot;, RUN+=&quot;/home/lufahai/ubuntu22.04/60-usb-audio.sh&quot;SUBSYSTEM==&quot;sound&quot;, ACTION==&quot;remove&quot;, RUN+=&quot;/home/lufahai/ubuntu22.04/60-usb-audio.sh&quot;UBSYSTEMS==&quot;usb&quot;, ATTRS&#123;product&#125;==&quot;USB*Keyboard&quot;, ACTION==&quot;add&quot;, RUN+=&quot;/home/lufahai/ubuntu/usb-device-status.sh 0&quot;SUBSYSTEMS==&quot;usb&quot;, ATTRS&#123;product&#125;==&quot;USB*Keyboard&quot;, ACTION==&quot;remove&quot;, RUN+=&quot;/home/lufahai/ubuntu/usb-device-status.sh 1&quot;SUBSYSTEMS==&quot;usb&quot;, ATTRS&#123;product&#125;==&quot;USB Receiver&quot;, ACTION==&quot;add&quot;, RUN+=&quot;/home/lufahai/ubuntu/usb-device-status.sh 0&quot;SUBSYSTEMS==&quot;usb&quot;, ATTRS&#123;product&#125;==&quot;USB Receiver&quot;, ACTION==&quot;remove&quot;, RUN+=&quot;/home/lufahai/ubuntu/usb-device-status.sh 1&quot;SUBSYSTEM==&quot;leds&quot;, ACTION==&quot;add&quot;, RUN+=&quot;/home/lufahai/ubuntu/usb-device-status.sh 0&quot;SUBSYSTEM==&quot;leds&quot;, ACTION==&quot;remove&quot;, RUN+=&quot;/home/lufahai/ubuntu/usb-device-status.sh 1&quot;SUBSYSTEMS==&quot;usb&quot;, ENV&#123;ID_VENDOR_ID&#125;=&quot;16c0&quot;, ENV&#123;ID_MODEL_ID&#125;=&quot;05e1&quot;, ACTION==&quot;add&quot;, RUN+=&quot;/home/lufahai/ubuntu/usb-device-status.sh 2&quot;SUBSYSTEMS==&quot;usb&quot;, ENV&#123;ID_VENDOR_ID&#125;=&quot;16c0&quot;, ENV&#123;ID_MODEL_ID&#125;=&quot;05e1&quot;, ACTION==&quot;remove&quot;, RUN+=&quot;/home/lufahai/ubuntu/usb-device-status.sh 3&quot;KERNEL==&quot;ttyUSB[0-9]*&quot;, SUBSYSTEM==&quot;tty&quot;, ATTRS&#123;idProduct&#125;==&quot;7523&quot;, ATTRS&#123;idVendor&#125;==&quot;1a86&quot;, ACTION==&quot;add&quot;, RUN+=&quot;/home/lufahai/ubuntu/usb-device-status.sh 4&quot;KERNEL==&quot;ttyUSB[0-9]*&quot;, SUBSYSTEM==&quot;tty&quot;, ATTRS&#123;idProduct&#125;==&quot;7523&quot;, ATTRS&#123;idVendor&#125;==&quot;1a86&quot;, ACTION==&quot;remove&quot;, RUN+=&quot;/home/lufahai/ubuntu/usb-device-status.sh 5&quot; 根据idProduct和idVendor等设备信息识别ACTION，然后实现具体的RUN 脚本，一般脚本发送一个dbus消息。 dbus脚本1/usr/bin/dbus-send --system /System System.DBus.USB.Interface.UsbKeyboardConnected boolean:true","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"Linux触摸屏显示和触摸点反转","slug":"armLinux/Linux触摸屏显示和触摸点反转","date":"2024-04-15T11:26:53.000Z","updated":"2024-10-30T01:41:26.395Z","comments":true,"path":"2024/04/15/armLinux/Linux触摸屏显示和触摸点反转/","link":"","permalink":"http://example.com/2024/04/15/armLinux/Linux%E8%A7%A6%E6%91%B8%E5%B1%8F%E6%98%BE%E7%A4%BA%E5%92%8C%E8%A7%A6%E6%91%B8%E7%82%B9%E5%8F%8D%E8%BD%AC/","excerpt":"","text":"显示反转在xorg.conf中的Monitor字段中增加翻转功能 1234Section &quot;Monitor&quot;Identifier &quot;Monitor.Touch&quot;Option &quot;Rotate&quot; &quot;inverted&quot;EndSection 完整的xorg.conf 参考见附录 触摸点反转查找驱动首先查找对应的名字，grep 后面是厂商品牌，可以根据实际修改。 1TOUCH=$(xinput list --name-only | grep wch) 建立映射然后建立映射，这里采用的是eDP1连接 1xinput map-to-output &quot;$TOUCH&quot; eDP1 坐标反转1xinput set-prop &quot;$TOUCH&quot; &#x27;Coordinate Transformation Matrix&#x27; -1 0 1 0 -1 1 0 0 1 附录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Section &quot;ServerFlags&quot; Option &quot;AllowMouseOpenFail&quot; &quot;FALSE&quot; Option &quot;AutoAddDevices&quot; &quot;TRUE&quot; Option &quot;AutoEnableDevices&quot; &quot;TRUE&quot; Option &quot;AutoAddGPU&quot; &quot;FALSE&quot; Option &quot;DontZap&quot; &quot;ON&quot; Option &quot;DontZoom&quot; &quot;ON&quot; Option &quot;DontVTSwitch&quot; &quot;ON&quot; Option &quot;BlankTime&quot; &quot;0&quot; Option &quot;StandbyTime&quot; &quot;0&quot; Option &quot;SuspendTime&quot; &quot;0&quot; Option &quot;OffTime&quot; &quot;0&quot;EndSectionSection &quot;ServerLayout&quot; Identifier &quot;Touch&quot; Screen 0 &quot;Screen.Touch&quot; 0 0 InputDevice &quot;Mouse0&quot; &quot;CorePointer&quot; InputDevice &quot;Keyboard0&quot; &quot;CoreKeyboard&quot;EndSectionSection &quot;InputDevice&quot; Identifier &quot;Keyboard0&quot; Driver &quot;kbd&quot;EndSectionSection &quot;InputDevice&quot; Identifier &quot;Mouse0&quot; Driver &quot;mouse&quot; Option &quot;Protocol&quot; &quot;auto&quot; Option &quot;Device&quot; &quot;/dev/psaux&quot; Option &quot;Emulate3Buttons&quot; &quot;no&quot; Option &quot;ZAxisMapping&quot; &quot;4 5&quot;EndSectionSection &quot;Monitor&quot; Identifier &quot;Monitor.Touch&quot; #Option &quot;Rotate&quot; &quot;inverted&quot;EndSectionSection &quot;Device&quot; Identifier &quot;Device.Intel&quot; Driver &quot;intel&quot; BusID &quot;PCI:0:2:0&quot; Option &quot;monitor-eDP1&quot; &quot;Monitor.Touch&quot; Option &quot;TearFree&quot; &quot;true&quot;EndSectionSection &quot;Screen&quot; Identifier &quot;Screen.Touch&quot; Device &quot;Device.Intel&quot; Monitor &quot;Monitor.Touch&quot; SubSection &quot;Display&quot; Depth 24 EndSubSectionEndSectionSection &quot;Screen&quot; Identifier &quot;TouchScreen&quot; Device &quot;IntelGPU&quot; Monitor &quot;Monitor1&quot; SubSection &quot;Display&quot; Depth 24 EndSubSectionEndSection","categories":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/categories/armLinux/"}],"tags":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/tags/armLinux/"}]},{"title":"QCheckBox扩大操作范围","slug":"Qt/QCheckBox扩大操作范围","date":"2024-04-15T11:23:15.000Z","updated":"2024-04-15T11:24:59.852Z","comments":true,"path":"2024/04/15/Qt/QCheckBox扩大操作范围/","link":"","permalink":"http://example.com/2024/04/15/Qt/QCheckBox%E6%89%A9%E5%A4%A7%E6%93%8D%E4%BD%9C%E8%8C%83%E5%9B%B4/","excerpt":"","text":"方法原理QCheckBox使用时发现只能点击文本或者中间的小白框才能改变选中状态，想要点击控件的范围内都能改变选中状态 步骤重写mousePressEvent1234567891011121314151617void PCheckBox::mousePressEvent(QMouseEvent *e)&#123; Qt::CheckState state = this-&gt;checkState(); switch (state) &#123; case Qt::Unchecked: this-&gt;setCheckState(Qt::Checked); break; case Qt::Checked: this-&gt;setCheckState(Qt::Unchecked); break; default: break; &#125;&#125;","categories":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"QSlider扩大滑块的操作范围","slug":"Qt/QSlider扩大滑块的操作范围","date":"2024-04-15T11:18:44.000Z","updated":"2024-04-15T11:21:27.387Z","comments":true,"path":"2024/04/15/Qt/QSlider扩大滑块的操作范围/","link":"","permalink":"http://example.com/2024/04/15/Qt/QSlider%E6%89%A9%E5%A4%A7%E6%BB%91%E5%9D%97%E7%9A%84%E6%93%8D%E4%BD%9C%E8%8C%83%E5%9B%B4/","excerpt":"","text":"方法原理可以把Slider的滑条handle 设置为一个较小的图标，但是handle的实际尺寸比较大。 步骤设置sytleSheet1234567891011121314151617181920212223242526272829303132333435363738394041QSlider::groove:horizontal &#123; border: 1px solid gray; height: 0px; left: 15px; right: 15px;&#125;QSlider::handle:horizontal &#123;/* border: 1px solid gray;*/ border-radius: 30px; width: 60px; height: 60px; margin: -30px; image: url(:/root/resources/icons/slider-handle.png);&#125;QSlider::handle:horizontal:disabled &#123; border-radius: 30px; width: 60px; height: 60px; margin: -30px; image: url(:/root/resources/icons/slider-handle_gray.png);&#125;QSlider::add-page:horizontal&#123; background: rgb(80,80,80);&#125;QSlider::sub-page:horizontal&#123; background: qlineargradient(x1:0,y1:0,x2:1,y2:0,stop:0 rgb(255,255,255) ,stop:1 rgb(70,95,240));&#125;QSlider::add-page:horizontal:disabled&#123; background: rgb(80,80,80);&#125;QSlider::sub-page:horizontal:disabled&#123; background: rgb(80,80,80);&#125; 效果由于图片尺寸较小，看起来滑块不大，但是滑动的实际大小是外框，也就是有效的操作范围是外框圆部分。","categories":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"ubuntu20交叉编译树莓派64bit_OS Qt,包括eglfs","slug":"armLinux/ubuntu20交叉编译树莓派64bit-OS-Qt-包括eglfs","date":"2023-10-14T16:51:12.000Z","updated":"2024-12-18T01:43:14.148Z","comments":true,"path":"2023/10/15/armLinux/ubuntu20交叉编译树莓派64bit-OS-Qt-包括eglfs/","link":"","permalink":"http://example.com/2023/10/15/armLinux/ubuntu20%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E6%A0%91%E8%8E%93%E6%B4%BE64bit-OS-Qt-%E5%8C%85%E6%8B%ACeglfs/","excerpt":"","text":"一、事先准备1、ubuntu PC1) 下载Qt5.15.2源码 2) 下载文件系统 直接新建一个sysroot空目录即可，等会再同步树莓派的库文件 2、jetson Nano1) 安装依赖选项 12sudo apt-get install libx11-dev libxcb1-dev libxkbcommon-x11-dev libx11-xcb-dev libxext-dev flex bison gperf libicu-dev libxslt1-dev ruby libssl-dev libxcursor-dev libxcomposite-dev libxdamage-dev libxrandr-dev libfontconfig1-dev libcap-dev libxtst-dev libpulse-dev libudev-dev libpci-dev libnss3-dev libasound2-dev libxss-dev libegl1-mesa-dev gperf bison libbz2-dev libdrm-dev libcups2-dev libatkmm-1.6-dev libasound2-dev libudev-dev libinput-dev libts-dev libmtdev-dev libjpeg-dev libfontconfig1-dev libssl-dev libdbus-1-dev libglib2.0-dev libxkbcommon-dev libgles2-mesa-dev libgbm-dev gdbserver 二、编译及安装1、同步文件系统注意，可以把usr 和lib的着整个目录都同步过来。可以解决交叉编译的很多问题。 12rsync -avz lufahai@192.168.10.201:/lib sysrootrsync -avz lufahai@192.168.10.201:/usr sysroot 2、修复损坏的链接文件123wget https://raw.githubusercontent.com/Kukkimonsuta/rpi-buildqt/master/scripts/utils/sysroot-relativelinks.pychmod -x sysroot-relativelinks.py./sysroot-relativelinks.py sysroot 文件内容如下: 12345678910111213141516171819202122232425262728293031323334#!/usr/bin/env pythonimport sysimport os# source: https://raw.githubusercontent.com/riscv/riscv-poky/master/scripts/sysroot-relativelinks.py# Take a sysroot directory and turn all the absolute symlinks and turn them into# relative ones such that the sysroot is usable within another system.if len(sys.argv) != 2: print(&quot;Usage is &quot; + sys.argv[0] + &quot;&lt;directory&gt;&quot;) sys.exit(1)topdir = sys.argv[1]topdir = os.path.abspath(topdir)def handlelink(filePath, subdir): link = os.readlink(filePath) if link[0] != &quot;/&quot;: return if link.startswith(topdir): return newLink = os.path.relpath(topdir+link, subdir) print(&quot;\\t%s replacing %s =&gt; %s&quot; % (filePath, link, newLink)) os.unlink(filePath) os.symlink(newLink, filePath)for subdir, dirs, files in os.walk(topdir): for file in files: filePath = os.path.join(subdir, file) if os.path.islink(filePath): handlelink(filePath, subdir) 将上面的文件保存到sysroot-relativelinks.py，并且赋予+x权限如何使用: 1./sysroot-relativelinks.py sysroot 3、修改QT配置文件修改该配置文件: qt-everywhere-src-5.15.2&#x2F;qtbase&#x2F;mkspecs&#x2F;devices&#x2F;linux-rasp-pi4-v3d-g++&#x2F;qmake.conf主要是添加链接库和头文件，从而识别openGL的相关库文件，修改如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# qmake configuration for the Raspberry Pi 4 (32-bit) using the Mesa V3D# graphics stack. (not the Broadcom stack)## This supports accelerated OpenGL both for X11 and DRM/KMS. Perhaps# Wayland too.## Tested with a sysroot created from Raspbian Buster and a gcc 7.4# toolchain from Linaro.## Example configure command line, assuming installation to# /usr/local/qt5pi on device and ~/rpi/qt5 on the host:## ./configure -release -opengl es2 -device linux-rasp-pi4-v3d-g++ -device-option CROSS_COMPILE=~/rpi/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf- \\# -sysroot ~/rpi/sysroot -opensource -confirm-license -make libs -prefix /usr/local/qt5pi -extprefix ~/rpi/qt5 -v## Check the configure output carefully. EGLFS, EGLFS GBM, and EGL on X11# should all be &#x27;yes&#x27;. Otherwise something is wrong.## If getting linker errors like &quot;undefined reference to `_dl_stack_flags&#x27;&quot; check the# symlinks in the sysroot, they were probably not adjusted# correctly. F.ex. sysroot/usr/lib/arm-linux-gnueabihf/libpthread.so must point to# sysroot/lib/arm-linux-gnueabihf/libpthread.so.0. If it is a broken link instead, bad# things will happen.include(../common/linux_device_pre.conf)QMAKE_INCDIR_POST += \\ $$[QT_SYSROOT]/usr/include \\ $$[QT_SYSROOT]/usr/include/aarch64-linux-gnu QMAKE_LIBDIR_POST += \\ $$[QT_SYSROOT]/usr/lib \\ $$[QT_SYSROOT]/lib/aarch64-linux-gnu \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu QMAKE_RPATHLINKDIR_POST += \\ $$[QT_SYSROOT]/usr/lib \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu \\ $$[QT_SYSROOT]/lib/aarch64-linux-gnuQMAKE_RPATHLINKDIR_POST += \\ $$[QT_SYSROOT]/usr/lib \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu \\ $$[QT_SYSROOT]/lib/aarch64-linux-gnu QMAKE_INCDIR_OPENGL[_ES2] += \\ $$[QT_SYSROOT]/usr/include \\ $$[QT_SYSROOT]/usr/include/EGL \\ $$[QT_SYSROOT]/usr/include/GLES2 \\ $$[QT_SYSROOT]/usr/include/GLES3 \\ $$[QT_SYSROOT]/usr/include/KHRQMAKE_LIBDIR_OPENGL[_ES2] += \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu/tegra \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu QMAKE_LIBS_OPENGL[_ES2] += -lGLESv2 -lEGL#QMAKE_INCDIR_EGL += $$QMAKE_INCDIR_OPENGL[_ES2]QMAKE_INCDIR_POST += \\ $$[QT_SYSROOT]/usr/include \\ $$[QT_SYSROOT]/usr/include/aarch64-linux-gnuQMAKE_LIBDIR_POST += \\ $$[QT_SYSROOT]/usr/lib \\ $$[QT_SYSROOT]/lib/aarch64-linux-gnu \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnuQMAKE_RPATHLINKDIR_POST += \\ $$[QT_SYSROOT]/usr/lib \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu \\ $$[QT_SYSROOT]/lib/aarch64-linux-gnuQMAKE_LIBS_EGL += -lEGLQMAKE_LIBS_OPENGL_ES2 += -lGLESv2 -lEGLDISTRO_OPTS += aarch64QMAKE_CFLAGS = -march=armv8-a -mtune=cortex-a72QMAKE_CXXFLAGS = $$QMAKE_CFLAGS#DISTRO_OPTS += hard-float#DISTRO_OPTS += deb-multi-archEGLFS_DEVICE_INTEGRATION = eglfs_x11include(../common/linux_arm_device_post.conf)load(qt_config) 3、配置及编译进入Qt源码目录，创建build目录并在其下建立配置脚本autoConfig.sh根据实际情况修改路径。 1234567891011121314151617181920212223../configure \\-prefix /home/lufahai/workspace/rpi/qt5.15.2 \\-extprefix /home/lufahai/workspace/rpi/qt5.15.2 \\-hostprefix /home/lufahai/workspace/rpi/hostQt5.15.2 \\-confirm-license \\-opensource \\-device-option CROSS_COMPILE=/opt/aarch64-linux-gcc/bin/aarch64-linux-gnu- \\-device linux-rasp-pi4-v3d-g++ \\-sysroot /home/lufahai/workspace/rpi/sysroot \\-opengl es2 \\-skip qtscript \\-skip wayland \\-skip qtwebengine \\-force-debug-info \\-skip qtdatavis3d \\-skip qtlocation \\-nomake examples \\-make libs -pkg-config -no-use-gold-linker -v \\-no-openssl -shared -release -pch -no-cups \\-no-glib -no-dbus -no-xcb \\-no-separate-debug-info \\-no-fontconfig \\-nomake tests -no-iconv -no-tslib 配置出现的结果如下,主要是openGL的选项识别为yes 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248Build options: Mode ................................... release (with debug info) Optimize release build for size ........ no Building shared libraries .............. yes Using C standard ....................... C11 Using C++ standard ..................... C++17 Using ccache ........................... no Using new DTAGS ........................ yes Generating GDB index ................... no Relocatable ............................ yes Using precompiled headers .............. yes Using LTCG ............................. no Target compiler supports: NEON ................................. yes Build parts ............................ libsQt modules and options: Qt Concurrent .......................... yes Qt D-Bus ............................... no Qt D-Bus directly linked to libdbus .... no Qt Gui ................................. yes Qt Network ............................. yes Qt Sql ................................. yes Qt Testlib ............................. yes Qt Widgets ............................. yes Qt Xml ................................. yesSupport enabled for: Using pkg-config ....................... yes udev ................................... yes Using system zlib ...................... yes Zstandard support ...................... noQt Core: DoubleConversion ....................... yes Using system DoubleConversion ........ no GLib ................................... no iconv .................................. no ICU .................................... yes Built-in copy of the MIME database ..... yes Tracing backend ........................ &lt;none&gt; Logging backends: journald ............................. no syslog ............................... no slog2 ................................ no PCRE2 .................................. yes Using system PCRE2 ................... yesQt Network: getifaddrs() ........................... yes IPv6 ifname ............................ yes libproxy ............................... no Linux AF_NETLINK ....................... yes OpenSSL ................................ no Qt directly linked to OpenSSL ........ no OpenSSL 1.1 ............................ no DTLS ................................... no OCSP-stapling .......................... no SCTP ................................... no Use system proxies ..................... yes GSSAPI ................................. noQt Gui: Accessibility .......................... yes FreeType ............................... yes Using system FreeType ................ yes HarfBuzz ............................... yes Using system HarfBuzz ................ no Fontconfig ............................. no Image formats: GIF .................................. yes ICO .................................. yes JPEG ................................. yes Using system libjpeg ............... yes PNG .................................. yes Using system libpng ................ yes Text formats: HtmlParser ........................... yes CssParser ............................ yes OdfWriter ............................ yes MarkdownReader ....................... yes Using system libmd4c ............... no MarkdownWriter ....................... yes EGL .................................... yes OpenVG ................................. no OpenGL: Desktop OpenGL ....................... no OpenGL ES 2.0 ........................ yes OpenGL ES 3.0 ........................ yes OpenGL ES 3.1 ........................ yes OpenGL ES 3.2 ........................ yes Vulkan ................................. no Session Management ..................... yesFeatures used by QPA backends: evdev .................................. yes libinput ............................... yes INTEGRITY HID .......................... no mtdev .................................. yes tslib .................................. no xkbcommon .............................. yes X11 specific: XLib ................................. yes XCB Xlib ............................. yes EGL on X11 ........................... yes xkbcommon-x11 ........................ yesQPA backends: DirectFB ............................... no EGLFS .................................. yes EGLFS details: EGLFS OpenWFD ........................ no EGLFS i.Mx6 .......................... no EGLFS i.Mx6 Wayland .................. no EGLFS RCAR ........................... no EGLFS EGLDevice ...................... yes EGLFS GBM ............................ yes EGLFS VSP2 ........................... no EGLFS Mali ........................... no EGLFS Raspberry Pi ................... yes EGLFS X11 ............................ yes LinuxFB ................................ yes VNC .................................... yesQt Sql: SQL item models ........................ yesQt Widgets: GTK+ ................................... no Styles ................................. Fusion WindowsQt PrintSupport: CUPS ................................... noQt Sql Drivers: DB2 (IBM) .............................. no InterBase .............................. no MySql .................................. no OCI (Oracle) ........................... no ODBC ................................... no PostgreSQL ............................. no SQLite2 ................................ no SQLite ................................. yes Using system provided SQLite ......... no TDS (Sybase) ........................... noQt Testlib: Tester for item models ................. yesSerial Port: ntddmodm ............................... noQt SerialBus: Socket CAN ............................. yes Socket CAN FD .......................... yes SerialPort Support ..................... yesFurther Image Formats: JasPer ................................. no MNG .................................... no TIFF ................................... yes Using system libtiff ................. yes WEBP ................................... yes Using system libwebp ................. noQt QML: QML network support .................... yes QML debugging and profiling support .... yes QML just-in-time compiler .............. yes QML sequence object .................... yes QML XML http request ................... yes QML Locale ............................. yesQt QML Models: QML list model ......................... yes QML delegate model ..................... yesQt Quick: Direct3D 12 ............................ no AnimatedImage item ..................... yes Canvas item ............................ yes Support for Qt Quick Designer .......... yes Flipable item .......................... yes GridView item .......................... yes ListView item .......................... yes TableView item ......................... yes Path support ........................... yes PathView item .......................... yes Positioner items ....................... yes Repeater item .......................... yes ShaderEffect item ...................... yes Sprite item ............................ yesQtQuick3D: Assimp ................................. yes System Assimp .......................... noQt Scxml: ECMAScript data model for QtScxml ...... yesQt Gamepad: SDL2 ................................... noQt 3D: Assimp ................................. yes System Assimp .......................... no Output Qt3D GL traces .................. no Use SSE2 instructions .................. no Use AVX2 instructions .................. no Aspects: Render aspect ........................ yes Input aspect ......................... yes Logic aspect ......................... yes Animation aspect ..................... yes Extras aspect ........................ yesQt 3D Renderers: OpenGL Renderer ........................ yes RHI Renderer ........................... noQt 3D GeometryLoaders: Autodesk FBX ........................... noQt Bluetooth: BlueZ .................................. no BlueZ Low Energy ....................... no Linux Crypto API ....................... no Native Win32 Bluetooth ................. no WinRT Bluetooth API (desktop &amp; UWP) .... no WinRT advanced bluetooth low energy API (desktop &amp; UWP) . noQt Sensors: sensorfw ............................... noQt Quick Controls 2: Styles ................................. Default Fusion Imagine Material UniversalQt Quick Templates 2: Hover support .......................... yes Multi-touch support .................... yesQtXmlPatterns: XML schema support ..................... yesQt Multimedia: ALSA ................................... yes GStreamer 1.0 .......................... no GStreamer 0.10 ......................... no Video for Linux ........................ yes OpenAL ................................. no PulseAudio ............................. yes Resource Policy (libresourceqt5) ....... no Windows Audio Services ................. no DirectShow ............................. no Windows Media Foundation ............... noQt TextToSpeech: Flite .................................. no Flite with ALSA ........................ no Speech Dispatcher ...................... noQt Tools: Qt Assistant ........................... yes Qt Designer ............................ yes Qt Distance Field Generator ............ yes kmap2qmap .............................. yes Qt Linguist ............................ yes Mac Deployment Tool .................... no makeqpf ................................ yes pixeltool .............................. yes qdbus .................................. yes qev .................................... yes Qt Attributions Scanner ................ yes qtdiag ................................. yes qtpaths ................................ yes qtplugininfo ........................... yes Windows deployment tool ................ no WinRT Runner Tool ...................... noQt Tools: QDoc ................................... no 接着就可以 make -j16 &amp;&amp; make install 3.1、重要事项qt支持多种后台插件，即便是eglfs也可以分为eglfs_x11 和 eglfs_kms，前者必须在一个X上运行。而kms是直接底层驱动图形接口，不需要依赖于其他桌面系统，渲染效率更高。 如何修改：在qmake.conf 增加-lgbm以及它对应的库文件和头文件路径(与glesv2一样)，并且下面的EGLFS_DEVICE_INTEGRATION &#x3D; eglfs_x11要改为 EGLFS_DEVICE_INTEGRATION &#x3D; eglfs_kms 如何确定是否可行：要保证EGLFS details中的EGLDevice 和 GBM为yes 1234567891011EGLFS details:EGLFS OpenWFD ........................ noEGLFS i.Mx6 .......................... noEGLFS i.Mx6 Wayland .................. noEGLFS RCAR ........................... noEGLFS EGLDevice ...................... yesEGLFS GBM ............................ yesEGLFS VSP2 ........................... noEGLFS Mali ........................... noEGLFS Raspberry Pi ................... noEGLFS X11 ............................ yes 4、出现编译问题一般情况下，EGLFS Raspberry Pi ………………. yes 这个选项要是识别为no的话，不会有什么问题。但是正是因为系统识别到树莓派的EGLFS库文件，就导致了编译.&#x2F;qtbase&#x2F;src&#x2F;plugins&#x2F;platforms&#x2F;eglfs&#x2F;deviceintegration&#x2F;eglfs_brcm&#x2F;qeglfsbrcmintegration.cpp这个文件时出现无法找到EGL_DISPMANX_WINDOW_T这个定义的问题。 解决如下，直接在它对应的头文件 .&#x2F;qtbase&#x2F;src&#x2F;plugins&#x2F;platforms&#x2F;eglfs&#x2F;deviceintegration&#x2F;eglfs_brcm&#x2F;qeglfsbrcmintegration.h中加入定义： 修改后的头文件如下： 12345678910111213141516171819202122232425262728#ifndef QEGLFSBRCMINTEGRATION_H#define QEGLFSBRCMINTEGRATION_H#include &quot;private/qeglfsdeviceintegration_p.h&quot;QT_BEGIN_NAMESPACEtypedef uint32_t DISPMANX_ELEMENT_HANDLE_T;typedef struct &#123; DISPMANX_ELEMENT_HANDLE_T element; int width; /* This is necessary because dispmanx elements are not queriable. */ int height;&#125; EGL_DISPMANX_WINDOW_T;class QEglFSBrcmIntegration : public QEglFSDeviceIntegration&#123;public: void platformInit() override; void platformDestroy() override; EGLNativeDisplayType platformDisplay() const override; QSize screenSize() const override; EGLNativeWindowType createNativeWindow(QPlatformWindow *window, const QSize &amp;size, const QSurfaceFormat &amp;format) override; void destroyNativeWindow(EGLNativeWindowType window) override; bool hasCapability(QPlatformIntegration::Capability cap) const override;&#125;;QT_END_NAMESPACE 紧接着，它的cpp文件出现了无法使用static_cast进行类型转换的报错，可以直接使用C语言强制转换。第一个函数 static EGLNativeWindowType createDispmanxLayer，直接在它的return处强制转换： 1234567891011121314151617181920212223242526272829303132333435static EGLNativeWindowType createDispmanxLayer(const QPoint &amp;pos, const QSize &amp;size, int z, DISPMANX_FLAGS_ALPHA_T flags)&#123; VC_RECT_T dst_rect; dst_rect.x = pos.x(); dst_rect.y = pos.y(); dst_rect.width = size.width(); dst_rect.height = size.height(); VC_RECT_T src_rect; src_rect.x = 0; src_rect.y = 0; src_rect.width = size.width() &lt;&lt; 16; src_rect.height = size.height() &lt;&lt; 16; DISPMANX_UPDATE_HANDLE_T dispman_update = vc_dispmanx_update_start(0); VC_DISPMANX_ALPHA_T alpha; alpha.flags = flags; alpha.opacity = 0xFF; alpha.mask = 0; DISPMANX_ELEMENT_HANDLE_T dispman_element = vc_dispmanx_element_add( dispman_update, dispman_display, z, &amp;dst_rect, 0, &amp;src_rect, DISPMANX_PROTECTION_NONE, &amp;alpha, (DISPMANX_CLAMP_T *)NULL, (DISPMANX_TRANSFORM_T)0); vc_dispmanx_update_submit_sync(dispman_update); EGL_DISPMANX_WINDOW_T *eglWindow = new EGL_DISPMANX_WINDOW_T; eglWindow-&gt;element = dispman_element; eglWindow-&gt;width = size.width(); eglWindow-&gt;height = size.height(); //return eglWindow; return (EGLNativeWindowType)eglWindow;&#125; 第二个函数 static void destroyDispmanxLayer(EGLNativeWindowType window)直接强制转换： 12345678910static void destroyDispmanxLayer(EGLNativeWindowType window)&#123; //EGL_DISPMANX_WINDOW_T *eglWindow = static_cast&lt;EGL_DISPMANX_WINDOW_T *&gt;(window); EGL_DISPMANX_WINDOW_T *eglWindow = (EGL_DISPMANX_WINDOW_T *)(window); DISPMANX_UPDATE_HANDLE_T dispman_update = vc_dispmanx_update_start(0); vc_dispmanx_element_remove(dispman_update, eglWindow-&gt;element); vc_dispmanx_update_submit_sync(dispman_update); delete eglWindow;&#125; 然后直接make &amp;&amp; make install 5、部署将编译并安装后的qt5.15.2放到jetson Nano中，并修改&#x2F;etc&#x2F;profile配置环境变量根据实际情况修改路径 1234export QTDIR=/home/lufahai/qt5.15.2export LD_LIBRARY_PATH=$QTDIR/lib:$LD_LIBRARY_PATHexport QT_QPA_PLATFORM_PLUGIN_PATH=$QTDIR/pluginsexport QT_QPA_PLATFORM=eglfs 6、测试QOpenGl测试例子widget.h文件如下 12345678910111213141516171819202122232425262728#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QOpenGLShaderProgram&gt;#include &lt;QOpenGLFunctions&gt;#include &lt;QOpenGLWidget&gt;#include &lt;QPushButton&gt;class Widget : public QOpenGLWidget , public QOpenGLFunctions&#123; Q_OBJECTpublic: Widget(QWidget *parent = nullptr); ~Widget();protected: void initializeGL() override; void resizeGL(int w, int h) override; void paintGL() override;private: QPushButton *button;&#125;;#endif // WIDGET_H widget.cpp文件如下 1234567891011121314151617181920212223242526272829303132333435#include &quot;widget.h&quot;#include &lt;QMessageBox&gt;Widget::Widget(QWidget *parent) : QOpenGLWidget(parent)&#123; button = new QPushButton(this); button-&gt;setGeometry(100, 100, 60, 40); button-&gt;setText(&quot;Button&quot;); connect(button, &amp;QPushButton::clicked, [this]() &#123; QMessageBox::information(this, &quot;Info&quot;, &quot;you have clicked this button&quot;); &#125;);&#125;Widget::~Widget()&#123; delete button;&#125;void Widget::initializeGL()&#123; this-&gt;initializeOpenGLFunctions();&#125;void Widget::resizeGL(int w, int h)&#123; glViewport(0.0f, 0.0f, w, h);&#125;void Widget::paintGL()&#123; glClearColor(1.0f, 1.0f, 0.0f, 0.0f); glClear(GL_COLOR_BUFFER_BIT);&#125; 然后直接在main.cpp中show就可以 6、显示补充1、控件没有文字:先下载一个wqy-MicroHei.ttf的中文字体，放到树莓派某个目录，例如&#x2F;home&#x2F;lufahai&#x2F;qt5.15.2&#x2F;fonts然后再main函数中声明: qputenv(“QT_QPA_FONTDIR”, “&#x2F;opt&#x2F;qt5.15.2&#x2F;fonts”); 123456789101112#include &quot;widget.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); qputenv(&quot;QT_QPA_FONTDIR&quot;, &quot;/opt/qt5.15.2/fonts&quot;); Widget w; w.show(); return a.exec();&#125; 2、按钮内部有一个虚线边框，可以直接设置: 1button-&gt;setFocusPolicy(Qt::NoFocus); 3、QT程序默认显示鼠标，如果不想在界面显示鼠标，可以在main函数设置 12QApplication a(argc, argv);a.setOverrideCursor(Qt::BlankCursor);","categories":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/categories/armLinux/"}],"tags":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/tags/armLinux/"}]},{"title":"ubuntu20交叉编译jetson Nano Qt,包括eglfs","slug":"armLinux/ubuntu20交叉编译jetson-Nano-Qt-包括eglfs","date":"2023-10-04T07:44:32.000Z","updated":"2024-12-18T01:41:11.794Z","comments":true,"path":"2023/10/04/armLinux/ubuntu20交叉编译jetson-Nano-Qt-包括eglfs/","link":"","permalink":"http://example.com/2023/10/04/armLinux/ubuntu20%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91jetson-Nano-Qt-%E5%8C%85%E6%8B%ACeglfs/","excerpt":"","text":"一、事先准备1、ubuntu PC1) 下载Qt5.15.2源码 2) 下载文件系统 直接新建一个sysroot空目录即可，等会再同步板子的库文件 2、jetson Nano1) 安装依赖选项 1sudo apt-get install &#x27;.*libxcb.*&#x27; libxrender-dev libxi-dev libfontconfig1-dev libudev-dev 2) 软连接opengl es库 12sudo ln -s libGLESv2_nvidia.so.2 libGLESv2.so sudo ln -s libEGL_nvidia.so.0 libEGL.so 二、编译及安装1、同步文件系统注意，可以把usr 和lib的着整个目录都同步过来。可以解决交叉编译的很多问题。 12rsync -avz lufahai@192.168.10.201:/lib sysrootrsync -avz lufahai@192.168.10.201:/usr sysroot 2、修复损坏的链接文件123wget https://raw.githubusercontent.com/Kukkimonsuta/rpi-buildqt/master/scripts/utils/sysroot-relativelinks.pychmod -x sysroot-relativelinks.py./sysroot-relativelinks.py sysroot 文件内容如下: 12345678910111213141516171819202122232425262728293031323334#!/usr/bin/env pythonimport sysimport os# source: https://raw.githubusercontent.com/riscv/riscv-poky/master/scripts/sysroot-relativelinks.py# Take a sysroot directory and turn all the absolute symlinks and turn them into# relative ones such that the sysroot is usable within another system.if len(sys.argv) != 2: print(&quot;Usage is &quot; + sys.argv[0] + &quot;&lt;directory&gt;&quot;) sys.exit(1)topdir = sys.argv[1]topdir = os.path.abspath(topdir)def handlelink(filePath, subdir): link = os.readlink(filePath) if link[0] != &quot;/&quot;: return if link.startswith(topdir): return newLink = os.path.relpath(topdir+link, subdir) print(&quot;\\t%s replacing %s =&gt; %s&quot; % (filePath, link, newLink)) os.unlink(filePath) os.symlink(newLink, filePath)for subdir, dirs, files in os.walk(topdir): for file in files: filePath = os.path.join(subdir, file) if os.path.islink(filePath): handlelink(filePath, subdir) 将上面的文件保存到sysroot-relativelinks.py，并且赋予+x权限如何使用: 1./sysroot-relativelinks.py sysroot 3、修改QT配置文件由于qt源码中没有 jetson Nano这个device配置文件，使用比较相近的tx1作为配置。修改该配置文件: qt-everywhere-src-5.15.2&#x2F;qtbase&#x2F;mkspecs&#x2F;devices&#x2F;linux-jetson-tx1-g++&#x2F;qmake.conf主要是添加链接库和头文件，从而识别openGL的相关库文件，修改如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859## qmake configuration for the Jetson TK1 boards running Linux For Tegra## Note that this environment has been tested with X11 only.## A typical configure line might look like:# configure \\# -device linux-jetson-tk1-g++ \\# -device-option CROSS_COMPILE=/opt/nvidia/toolchains/tegra-4.8.1-nv/usr/bin/arm-cortex_a15-linux-gnueabi/arm-cortex_a15-linux-gnueabi- \\# -sysroot /opt/nvidia/l4t/targetfsinclude(../common/linux_device_pre.conf)QMAKE_INCDIR_POST += \\ $$[QT_SYSROOT]/usr/include \\ $$[QT_SYSROOT]/usr/include/aarch64-linux-gnu QMAKE_LIBDIR_POST += \\ $$[QT_SYSROOT]/usr/lib \\ $$[QT_SYSROOT]/lib/aarch64-linux-gnu \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu QMAKE_RPATHLINKDIR_POST += \\ $$[QT_SYSROOT]/usr/lib \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu/tegra \\ $$[QT_SYSROOT]/lib/aarch64-linux-gnu QMAKE_INCDIR_OPENGL[_ES2] += \\ $$[QT_SYSROOT]/include \\ $$[QT_SYSROOT]/include/EGL \\ $$[QT_SYSROOT]/include/GLES2 \\ $$[QT_SYSROOT]/include/GLES3 \\ $$[QT_SYSROOT]/include/KHR \\ $$[QT_SYSROOT]/usr/include \\ $$[QT_SYSROOT]/usr/include/EGL \\ $$[QT_SYSROOT]/usr/include/GLES2 \\ $$[QT_SYSROOT]/usr/include/GLES3 \\ $$[QT_SYSROOT]/usr/include/KHR QMAKE_LIBDIR_OPENGL[_ES2] += \\ $$[QT_SYSROOT]/lib/aarch64-linux-gnu/tegra \\ $$[QT_SYSROOT]/lib/aarch64-linux-gnu/tegra-egl \\ $$[QT_SYSROOT]/lib/aarch64-linux-gnu \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu/tegra \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu/tegra-egl \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu QMAKE_LIBS_OPENGL[_ES2] += -lEGL -lGLESv2 DISTRO_OPTS += aarch64 COMPILER_FLAGS += -mtune=cortex-a57.cortex-a53 -march=armv8-a EGLFS_DEVICE_INTEGRATION = eglfs_x11 QMAKE_CXXFLAGS += -std=gnu++11QMAKE_CFLAGS_ISYSTEM=-Iinclude(../common/linux_arm_device_post.conf)load(qt_config) 3、配置及编译进入Qt源码目录，创建build目录并在其下建立配置脚本autoConfig.sh根据实际情况修改路径。 1234567891011121314151617181920212223../configure \\-prefix /home/lufahai/workspace/jetson/qt5.15.2 \\-extprefix /home/lufahai/workspace/jetson/qt5.15.2 \\-hostprefix /home/lufahai/workspace/jetson/hostQt5.15.2 \\-confirm-license \\-opensource \\-device-option CROSS_COMPILE=/opt/aarch64-linux-gcc/bin/aarch64-linux-gnu- \\-device linux-jetson-tx1-g++ \\-sysroot /home/lufahai/workspace/jetson/sysroot \\-opengl es2 \\-skip qtscript \\-skip wayland \\-skip qtwebengine \\-force-debug-info \\-skip qtdatavis3d \\-skip qtlocation \\-nomake examples \\-make libs -pkg-config -no-use-gold-linker -v \\-no-openssl -shared -release -pch -no-cups \\-no-glib -no-dbus -no-xcb \\-no-separate-debug-info \\-no-fontconfig \\-nomake tests -no-iconv -no-tslib 配置出现的结果如下,主要是openGL的选项识别为yes 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248Build options: Mode ................................... release (with debug info) Optimize release build for size ........ no Building shared libraries .............. yes Using C standard ....................... C11 Using C++ standard ..................... C++17 Using ccache ........................... no Using new DTAGS ........................ yes Generating GDB index ................... no Relocatable ............................ yes Using precompiled headers .............. yes Using LTCG ............................. no Target compiler supports: NEON ................................. yes Build parts ............................ libsQt modules and options: Qt Concurrent .......................... yes Qt D-Bus ............................... no Qt D-Bus directly linked to libdbus .... no Qt Gui ................................. yes Qt Network ............................. yes Qt Sql ................................. yes Qt Testlib ............................. yes Qt Widgets ............................. yes Qt Xml ................................. yesSupport enabled for: Using pkg-config ....................... yes udev ................................... no Using system zlib ...................... yes Zstandard support ...................... noQt Core: DoubleConversion ....................... yes Using system DoubleConversion ........ no GLib ................................... no iconv .................................. no ICU .................................... yes Built-in copy of the MIME database ..... yes Tracing backend ........................ &lt;none&gt; Logging backends: journald ............................. no syslog ............................... no slog2 ................................ no PCRE2 .................................. yes Using system PCRE2 ................... noQt Network: getifaddrs() ........................... yes IPv6 ifname ............................ yes libproxy ............................... no Linux AF_NETLINK ....................... yes OpenSSL ................................ no Qt directly linked to OpenSSL ........ no OpenSSL 1.1 ............................ no DTLS ................................... no OCSP-stapling .......................... no SCTP ................................... no Use system proxies ..................... yes GSSAPI ................................. noQt Gui: Accessibility .......................... yes FreeType ............................... yes Using system FreeType ................ no HarfBuzz ............................... yes Using system HarfBuzz ................ yes Fontconfig ............................. no Image formats: GIF .................................. yes ICO .................................. yes JPEG ................................. yes Using system libjpeg ............... no PNG .................................. yes Using system libpng ................ no Text formats: HtmlParser ........................... yes CssParser ............................ yes OdfWriter ............................ yes MarkdownReader ....................... yes Using system libmd4c ............... no MarkdownWriter ....................... yes EGL .................................... yes OpenVG ................................. no OpenGL: Desktop OpenGL ....................... no OpenGL ES 2.0 ........................ yes OpenGL ES 3.0 ........................ yes OpenGL ES 3.1 ........................ yes OpenGL ES 3.2 ........................ yes Vulkan ................................. no Session Management ..................... yesFeatures used by QPA backends: evdev .................................. yes libinput ............................... no INTEGRITY HID .......................... no mtdev .................................. no tslib .................................. no xkbcommon .............................. no X11 specific: XLib ................................. yes XCB Xlib ............................. yes EGL on X11 ........................... yes xkbcommon-x11 ........................ noQPA backends: DirectFB ............................... no EGLFS .................................. yes EGLFS details: EGLFS OpenWFD ........................ no EGLFS i.Mx6 .......................... no EGLFS i.Mx6 Wayland .................. no EGLFS RCAR ........................... no EGLFS EGLDevice ...................... yes EGLFS GBM ............................ no EGLFS VSP2 ........................... no EGLFS Mali ........................... no EGLFS Raspberry Pi ................... no EGLFS X11 ............................ yes LinuxFB ................................ yes VNC .................................... yesQt Sql: SQL item models ........................ yesQt Widgets: GTK+ ................................... no Styles ................................. Fusion WindowsQt PrintSupport: CUPS ................................... noQt Sql Drivers: DB2 (IBM) .............................. no InterBase .............................. no MySql .................................. no OCI (Oracle) ........................... no ODBC ................................... no PostgreSQL ............................. no SQLite2 ................................ no SQLite ................................. yes Using system provided SQLite ......... no TDS (Sybase) ........................... noQt Testlib: Tester for item models ................. yesSerial Port: ntddmodm ............................... noQt SerialBus: Socket CAN ............................. yes Socket CAN FD .......................... yes SerialPort Support ..................... yesFurther Image Formats: JasPer ................................. no MNG .................................... no TIFF ................................... yes Using system libtiff ................. no WEBP ................................... yes Using system libwebp ................. noQt QML: QML network support .................... yes QML debugging and profiling support .... yes QML just-in-time compiler .............. yes QML sequence object .................... yes QML XML http request ................... yes QML Locale ............................. yesQt QML Models: QML list model ......................... yes QML delegate model ..................... yesQt Quick: Direct3D 12 ............................ no AnimatedImage item ..................... yes Canvas item ............................ yes Support for Qt Quick Designer .......... yes Flipable item .......................... yes GridView item .......................... yes ListView item .......................... yes TableView item ......................... yes Path support ........................... yes PathView item .......................... yes Positioner items ....................... yes Repeater item .......................... yes ShaderEffect item ...................... yes Sprite item ............................ yesQtQuick3D: Assimp ................................. yes System Assimp .......................... noQt Scxml: ECMAScript data model for QtScxml ...... yesQt Gamepad: SDL2 ................................... noQt 3D: Assimp ................................. yes System Assimp .......................... no Output Qt3D GL traces .................. no Use SSE2 instructions .................. no Use AVX2 instructions .................. no Aspects: Render aspect ........................ yes Input aspect ......................... yes Logic aspect ......................... yes Animation aspect ..................... yes Extras aspect ........................ yesQt 3D Renderers: OpenGL Renderer ........................ yes RHI Renderer ........................... noQt 3D GeometryLoaders: Autodesk FBX ........................... noQt Bluetooth: BlueZ .................................. no BlueZ Low Energy ....................... no Linux Crypto API ....................... no Native Win32 Bluetooth ................. no WinRT Bluetooth API (desktop &amp; UWP) .... no WinRT advanced bluetooth low energy API (desktop &amp; UWP) . noQt Sensors: sensorfw ............................... noQt Quick Controls 2: Styles ................................. Default Fusion Imagine Material UniversalQt Quick Templates 2: Hover support .......................... yes Multi-touch support .................... yesQtXmlPatterns: XML schema support ..................... yesQt Multimedia: ALSA ................................... yes GStreamer 1.0 .......................... yes GStreamer 0.10 ......................... no Video for Linux ........................ yes OpenAL ................................. no PulseAudio ............................. no Resource Policy (libresourceqt5) ....... no Windows Audio Services ................. no DirectShow ............................. no Windows Media Foundation ............... noQt TextToSpeech: Flite .................................. no Flite with ALSA ........................ no Speech Dispatcher ...................... noQt Tools: Qt Assistant ........................... yes Qt Designer ............................ yes Qt Distance Field Generator ............ yes kmap2qmap .............................. yes Qt Linguist ............................ yes Mac Deployment Tool .................... no makeqpf ................................ yes pixeltool .............................. yes qdbus .................................. yes qev .................................... yes Qt Attributions Scanner ................ yes qtdiag ................................. yes qtpaths ................................ yes qtplugininfo ........................... yes Windows deployment tool ................ no WinRT Runner Tool ...................... noQt Tools: QDoc ................................... no 接着就可以 make -j16 &amp;&amp; make install 4、部署将编译并安装后的qt5.15.2放到jetson Nano中，并修改&#x2F;etc&#x2F;profile配置环境变量根据实际情况修改路径 1234export QTDIR=/home/lufahai/qt5.15.2export LD_LIBRARY_PATH=$QTDIR/lib:$LD_LIBRARY_PATHexport QT_QPA_PLATFORM_PLUGIN_PATH=$QTDIR/pluginsexport QT_QPA_PLATFORM=eglfs 5、测试QOpenGl测试例子widget.h文件如下 12345678910111213141516171819202122232425262728#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QOpenGLShaderProgram&gt;#include &lt;QOpenGLFunctions&gt;#include &lt;QOpenGLWidget&gt;#include &lt;QPushButton&gt;class Widget : public QOpenGLWidget , public QOpenGLFunctions&#123; Q_OBJECTpublic: Widget(QWidget *parent = nullptr); ~Widget();protected: void initializeGL() override; void resizeGL(int w, int h) override; void paintGL() override;private: QPushButton *button;&#125;;#endif // WIDGET_H widget.cpp文件如下 1234567891011121314151617181920212223242526272829303132333435#include &quot;widget.h&quot;#include &lt;QMessageBox&gt;Widget::Widget(QWidget *parent) : QOpenGLWidget(parent)&#123; button = new QPushButton(this); button-&gt;setGeometry(100, 100, 60, 40); button-&gt;setText(&quot;Button&quot;); connect(button, &amp;QPushButton::clicked, [this]() &#123; QMessageBox::information(this, &quot;Info&quot;, &quot;you have clicked this button&quot;); &#125;);&#125;Widget::~Widget()&#123; delete button;&#125;void Widget::initializeGL()&#123; this-&gt;initializeOpenGLFunctions();&#125;void Widget::resizeGL(int w, int h)&#123; glViewport(0.0f, 0.0f, w, h);&#125;void Widget::paintGL()&#123; glClearColor(1.0f, 1.0f, 0.0f, 0.0f); glClear(GL_COLOR_BUFFER_BIT);&#125; 然后直接在main.cpp中show就可以 三、交叉编译库1、解决cuda交叉编译的使用交叉编译出的qt无法直接编译cuda程序，可以写一个cmake小程序，在jetson上将cuda程序编译成一个动态库，然后QT直接链接这个库即可。样例:CmakeLists 1234567891011cmake_minimum_required(VERSION 3.10)project(CUDAProject)find_package(CUDA REQUIRED)set(CMAKE_CXX_COMPILER g++)set(CUDA_SOURCES cudaKernel.cu)set(CUDA_NVCC_FLAGS -arch=sm_30)include_directories(.)cuda_add_library(cudaKernel SHARED $&#123;CUDA_SOURCES&#125;) cuda程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &quot;cuda_runtime.h&quot;#include &quot;device_launch_parameters.h&quot;#include &lt;stdio.h&gt;#include &lt;cuda.h&gt;#define NUM_THREAD_X 32#define NUM_THREAD_Y 8static int DivUp(int a, int b)&#123; return ((a % b) != 0) ? (a / b + 1) : (a / b);&#125;__global__ void cuConvert_Rgb10A2_Rgba8(unsigned int *pSrc, unsigned char *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride)&#123; const int dx = blockIdx.x * blockDim.x + threadIdx.x; const int dy = blockIdx.y * blockDim.y + threadIdx.y; if (dx &gt;= iWidth || dy &gt;= iHeight) &#123; return; &#125; int idxSrc = dy * iSrcStride + dx; int idxDst = dy * iDstStride + dx * 4; uint r = pSrc[idxSrc] &gt;&gt; 22; uint g = pSrc[idxSrc] &gt;&gt; 12 &amp; 1023; uint b = pSrc[idxSrc] &gt;&gt; 2 &amp; 1023; b = b &gt;&gt; 2; g = g &gt;&gt; 2; r = r &gt;&gt; 2; pDst[idxDst] = r; pDst[idxDst + 1] = g; pDst[idxDst + 2] = b; pDst[idxDst + 3] = 255;&#125;extern &quot;C&quot;void Convert_Rgb10A2_Rgba8(unsigned int *pSrc, unsigned char *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride)&#123; dim3 numThreads(NUM_THREAD_X, NUM_THREAD_Y, 1); dim3 numBlocks(DivUp(iWidth, numThreads.x), DivUp(iHeight, numThreads.y)); cuConvert_Rgb10A2_Rgba8&lt;&lt;&lt;numBlocks, numThreads&gt;&gt;&gt;(pSrc, pDst, iWidth, iHeight, iSrcStride, iDstStride);&#125;__global__ void cuConvert_16UC3_Rgb10A2(unsigned short *pSrc, unsigned int *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride)&#123; const int dx = blockIdx.x * blockDim.x + threadIdx.x; const int dy = blockIdx.y * blockDim.y + threadIdx.y; if (dx &gt;= iWidth || dy &gt;= iHeight) &#123; return; &#125; int idxSrc = dy * iSrcStride + dx * 3; int idxDst = dy * iDstStride + dx; uint r = pSrc[idxSrc] &gt;&gt; 6; uint g = pSrc[idxSrc + 1] &gt;&gt; 6; uint b = pSrc[idxSrc + 2] &gt;&gt; 6; pDst[idxDst] = r &lt;&lt; 22 | g &lt;&lt; 12 | b &lt;&lt; 2 | 3;&#125;extern &quot;C&quot;void Convert_16UC3_Rgb10A2(unsigned short *pSrc, unsigned int *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride)&#123; dim3 numThreads(NUM_THREAD_X, NUM_THREAD_Y, 1); dim3 numBlocks(DivUp(iWidth, numThreads.x), DivUp(iHeight, numThreads.y)); cuConvert_16UC3_Rgb10A2&lt;&lt;&lt;numBlocks, numThreads&gt;&gt;&gt;(pSrc, pDst, iWidth, iHeight, iSrcStride, iDstStride);&#125;__global__ void cuConvert_16UC3_Rgba8(unsigned short *pSrc, unsigned char *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride)&#123; const int dx = blockIdx.x * blockDim.x + threadIdx.x; const int dy = blockIdx.y * blockDim.y + threadIdx.y; if (dx &gt;= iWidth || dy &gt;= iHeight) &#123; return; &#125; int idxSrc = dy * iSrcStride + dx * 3; int idxDst = dy * iDstStride + dx * 4; pDst[idxDst] = pSrc[idxSrc] &gt;&gt; 8; pDst[idxDst + 1] = pSrc[idxSrc + 1] &gt;&gt; 8; pDst[idxDst + 2] = pSrc[idxSrc + 2] &gt;&gt; 8; pDst[idxDst + 3] = 255;&#125;extern &quot;C&quot;void Convert_16UC3_Rgba8(unsigned short *pSrc, unsigned char *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride)&#123; dim3 numThreads(16, 16, 1); dim3 numBlocks(DivUp(iWidth, numThreads.x), DivUp(iHeight, numThreads.y)); cuConvert_16UC3_Rgba8&lt;&lt;&lt;numBlocks, numThreads&gt;&gt;&gt;(pSrc, pDst, iWidth, iHeight, iSrcStride, iDstStride);&#125; 头文件 1234567891011121314#ifndef CUDAKERNEL_H#define CUDAKERNEL_H#include &lt;stdio.h&gt;#include &quot;cuda_runtime.h&quot;#include &quot;device_launch_parameters.h&quot;extern &quot;C&quot; &#123;void Convert_Rgb10A2_Rgba8(unsigned int *pSrc, unsigned char *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride);void Convert_16UC3_Rgb10A2(unsigned short *pSrc, unsigned int *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride);void Convert_16UC3_Rgba8(unsigned short *pSrc, unsigned char *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride);&#125;#endif","categories":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/categories/armLinux/"}],"tags":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/tags/armLinux/"}]},{"title":"树莓派系统定制化","slug":"armLinux/树莓派系统定制化","date":"2023-09-17T08:21:33.000Z","updated":"2024-10-30T01:35:28.711Z","comments":true,"path":"2023/09/17/armLinux/树莓派系统定制化/","link":"","permalink":"http://example.com/2023/09/17/armLinux/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6%E5%8C%96/","excerpt":"","text":"自启动Xorg图形界面安装qt512sudo apt-get install qtbase5-dev qtchooser qt5-qmake qtbase5-dev-tools libqt5serialport5-dev qml-module-qtquick-controls2 qtdeclarative5-dev 安装xorg1sudo apt instll xserver-xorg xinit x11-xserver-utils 自启动图形界面及程序使用raspi-config设置console auto login在home目录创建.bash_profile脚本并赋予可执行权限，当用户从tty终端登陆时，该脚本会被自动执行。脚本内容如下：xset s off 表示屏蔽休眠xset -dpms 表示关闭电源管理 123if [ -z &quot;$DISPLAY&quot; ] &amp;&amp; [ -n &quot;$XDG_VTNR&quot; ] &amp;&amp; [ &quot;$XDG_VTNR&quot; -eq 1 ]; then startx -- -novtswitch -sharevts -nocursor :0 2&gt;/dev/nullfi 启动应用程序在home目录创建.xinitrc文件，并赋予可执行权限。当xinit执行执行成功后.xinitrc 会被自动执行，可在这个脚本中启动应用程序。在启动QT 程序之前 先要执行下面指令，屏蔽休眠和电源管理 123xset s off -dpms -display :0/path/to/qtApp -display :0 屏蔽系统信息屏蔽颜色检测1sudo nano /boot/config.txt 在最后添加： disable_splash&#x3D;1 屏蔽初始化中的代码流显示1sudo nano /boot/cmdline.txt 主要是把tty1改为tty3，以及增加logo.nologo loglevel&#x3D;3 修改如下： 1dwc_otg.lpm_enable=0 console=tty3 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait quiet splash plymouth.ignore-serial-consoles logo.nologo loglevel=3 disable_overscan=1 设置启动屏幕12sudo apt-get install fbisudo nano /etc/systemd/system/splashscreen.service 在打开的文件中填入一下内容 12345678910[Unit]Description=SplashscreenDefaultDependencies=noAfter=basic.target[Service]ExecStart=/usr/bin/fbi -d /dev/fb0 --noverbose -a /path/to/logo.pngStandardInput=ttyStandardOutput=tty[Install]WantedBy=sysinit.target 使其生效： 1systemctl enable splashscreen 屏蔽console登录信息只需在home目录下创建一个空文件 1touch .hushlogin 屏蔽自动登录时出现的提示sudo nano &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;&#x67;&#101;&#116;&#x74;&#x79;&#64;&#x74;&#116;&#121;&#x31;&#46;&#x73;&#x65;&#x72;&#118;&#x69;&#99;&#101;&#x2e;&#100;&#x2F;autologin.conf 123[Service]ExecStart=ExecStart=-/sbin/agetty --autologin proxinse --noissue --noclear --nohostname --nohints %I $TERM 软开关机在 &#x2F;boot&#x2F;config.txt 末尾增加：dtoverlay&#x3D;gpio-shutdown 然后BCM GPIO3(也就是SCL1) 的引脚与GND短接就能开关机。 如何屏蔽Boot Diagnostics这个诊断信息是写在EEPROM中到，因此需要修改配置，直接执行 1sudo -E rpi-eeprom-config --edit 执行后打开到文件如下，直接把DISABLE_HDMI&#x3D;0改为DISABLE_HDMI&#x3D;1并且按照nano方式保存退出即可。如下： 12345678910[all]BOOT_UART=0WAKE_ON_GPIO=1POWER_OFF_ON_HALT=0DHCP_TIMEOUT=45000DHCP_REQ_TIMEOUT=4000TFTP_FILE_TIMEOUT=30000ENABLE_SELF_UPDATE=1DISABLE_HDMI=1BOOT_ORDER=0xf41","categories":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/categories/armLinux/"}],"tags":[{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/tags/armLinux/"}]},{"title":"debian多显卡自定义图形界面","slug":"ubuntu/debian多显卡自定义图形界面","date":"2023-09-17T05:34:54.000Z","updated":"2023-09-17T05:35:58.215Z","comments":true,"path":"2023/09/17/ubuntu/debian多显卡自定义图形界面/","link":"","permalink":"http://example.com/2023/09/17/ubuntu/debian%E5%A4%9A%E6%98%BE%E5%8D%A1%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/","excerpt":"","text":"安装debian12及Nvidia驱动安装linux headers安装Nvidia驱动需要依赖linux-headers 123sudo apt install linux-headers-$(uname -r)sudo apt install build-essential 禁用nouveau驱动必须先禁用nouveau驱动才能安装Nvidia驱动 1sudo nano /etc/modprobe.d/blacklist.conf 新增以下两行： 12blacklist nouveauoptions nouveau modeset=0 更新内核配置使其生效 123sudo update-initramfs -ureboot 安装Nvidia驱动只有terminal终端才能装Nvidia驱动，因此先退出登录 123sudo telinit 3sudo ./NVIDIA-Linux-x86_64-530.30.02.run 根据提示安装即可，然后再安装cuda 1sudo ./cuda_12.1.0_530.30.02_linux.run 关闭桌面系统及用户自动登录关闭桌面系统1sudo systemctl set-default multi-user.target 如果想要恢复桌面系统就执行： 1sudo systemctl set-default graphical.target 新建用户系统启动后需要两个独立用户各自根据不同的配置文件，分别启动intel集显和Nvidia显卡的Xorg服务。按照如下方式新增用户： 1sudo useradd -d &quot;/home/stephen&quot; -m -s &quot;/bin/bash&quot; stephen 初始化密码 1sudo passwd stephen 加入相关的组 12sudo usermod -aG sudo stephensudo usermod -aG video stephen 要想启动xorg服务必须加入video组 自动登录新增配置文件 12sudo mkdir /etc/systemd/system/getty@tty1.service.dsudo nano /etc/systemd/system/getty@tty1.service.d/override.conf 在打开的文件中填入以下内容： 1234[Service]ExecStart=ExecStart=-/sbin/agetty --noissue --autologin stephenLu %I $TERMType=idle 同理为新增的stephen用户增加配置文件 12sudo mkdir /etc/systemd/system/getty@tty2.service.dsudo nano /etc/systemd/system/getty@tty2.service.d/override.conf 在打开的文件中填入以下内容： 12345[Service][Service]ExecStart=ExecStart=-/sbin/agetty --noissue --autologin stephen %I $TERMType=idle 开启自动登录服务 12sudo systemctl enable getty@tty1.servicesudo systemctl enable getty@tty2.service 启动Xorg在&#x2F;home&#x2F;stephenLu目录创建.bash_profile脚本并赋予可执行权限，当用户从tty终端登陆时，该脚本会被自动执行。脚本内容如下： 123if [ -z &quot;$DISPLAY&quot; ] &amp;&amp; [ -n &quot;$XDG_VTNR&quot; ] &amp;&amp; [ &quot;$XDG_VTNR&quot; -eq 1 ]; then xinit -- -config xorg.conf.touch -novtswitch -sharevts -layout Touch :0 vt1 &gt;/dev/null 2&gt;&amp;1fi 即脚本使用xinit 根据 xorg.conf.touch这一配置文件为intel集显触摸屏启动xorg服务，要保证 xorg.conf.touch存放于&#x2F;etc&#x2F;X11 目录下 同理在&#x2F;home&#x2F;prox目录下也创建.bash_profile脚本，内容如下： 123if [ -z &quot;$DISPLAY&quot; ] &amp;&amp; [ -n &quot;$XDG_VTNR&quot; ] &amp;&amp; [ &quot;$XDG_VTNR&quot; -eq 2 ]; then xinit -- -config xorg.conf.main -novtswitch -sharevts -nocursor -layout Main :1fi 启动应用程序在&#x2F;home&#x2F;stephenLu目录创建.xinitrc文件，并赋予可执行权限。当xinit执行执行成功后.xinitrc 会被自动执行，可在这个脚本中启动应用程序。 stephenLu用户home目录下的.xinitrc脚本内容如下： 123456DISPLAY_NO=0xset -display :$DISPLAY_NO -dpms &amp; # disable DPMS (Energy Star) featuresxset -display :$DISPLAY_NO s off &amp; # disable screensaverxset -display :$DISPLAY_NO s noblank &amp; # don&#x27;t blank the video devicewhile sleep 1h; do echo &quot;first xorg is aliving...&quot;; done stephen用户home目录下的.xinitrc脚本内容如下： 123456DISPLAY_NO=1xset -display :$DISPLAY_NO -dpms &amp; # disable DPMS (Energy Star) featuresxset -display :$DISPLAY_NO s off &amp; # disable screensaverxset -display :$DISPLAY_NO s noblank &amp; # don&#x27;t blank the video devicewhile sleep 1h; do echo &quot;second xorg is aliving...&quot;; done POST-INSTALL自定义开机按钮首先屏蔽默认的开机按键功能： 1sudo nano /etc/systemd/logind.conf 找到HandlePowerKey&#x3D;ignore，取消前面的#号注释，赋值为 ignore 安装acpid： 12sudo apt install acpidsudo systemctl enable acpid 然后配置自定义的按键指令： 1sudo nano /etc/acpi/events/powerbtn-acpi-support 把action选项改为所需要定义的脚本。 屏蔽开机logodebian12 默认使用emerald作为系统主题，开机的时候会显示logo，修改如下：首先更改主题： 1sudo nano /etc/plymouth/plymouthd.conf 取消文件内的选项注释，并且将Theme赋值为homeworld，修改主题是非必须的步骤，只是经过对比发现homeworld的配置文件方便修改。准备一张logo的png图片，把它复制到&#x2F;usr&#x2F;share&#x2F;plymounth&#x2F;themes&#x2F;homeworld 1sudo nano /usr/share/plymounth/themes/homeworld/homeworld.script 找到bg_image的赋值语句，把原先的背景图片改为刚才准备的logo名称。 为了屏蔽掉所有debian相关的信息，可以在debian 和 logo等Image赋值参数，写入 一个错误的图片名称，这样就不会加载logo图片。例如： 原先：logo &#x3D; Image(“logo.png”) 修改：logo &#x3D; Image(“logo1.png”) 保存更改： 1sudo update-initramfs -u 问题记录触摸屏花屏问题xorg.config.touch文件的Device Section中，如果不指定 Option “accelMethod”，那么会默 认使用SNA作为加速方法，这在有的触摸屏上是OK的。但是对于某些触摸屏，默认的SNA比较老，intel官方文档推荐使用uxa代替SNA。因此在xorg.config.touch 应该指定 Option “AccelMethod” “uxa”这个设定可以解决弹出虚拟键盘时，触摸屏花屏的问题。 12345678Section &quot;Device&quot; Identifier &quot;Device.Intel&quot; Driver &quot;intel&quot; BusID &quot;PCI:0:2:0&quot; Option &quot;monitor-eDP1&quot; &quot;Monitor.Touch&quot; Option &quot;TearFree&quot; &quot;true&quot; Option &quot;AccelMethod&quot; &quot;uxa&quot;EndSection","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"ubuntu20编译4.9内核时重定向错误的解决","slug":"servoCtrl/ubuntu20编译4-9内核时重定向错误的解决","date":"2022-12-19T05:15:55.000Z","updated":"2022-12-19T05:20:35.873Z","comments":true,"path":"2022/12/19/servoCtrl/ubuntu20编译4-9内核时重定向错误的解决/","link":"","permalink":"http://example.com/2022/12/19/servoCtrl/ubuntu20%E7%BC%96%E8%AF%914-9%E5%86%85%E6%A0%B8%E6%97%B6%E9%87%8D%E5%AE%9A%E5%90%91%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3/","excerpt":"","text":"一、现象RELOCS arch/x86/boot/compressed/vmlinux.relocs Unsupported relocation type: R_X86_64_PLT32 (4)、 二、解决手动依次修改以下三个文件 arch/x86/kernel/machine_kexec_64.c arch/x86/kernel/module.c arch/x86/tools/relocs.c 解决方法都是在这三个文件的switch目录下，增加对 R_X86_64_PLT32的支持 12case R_X86_64_PC32:case R_X86_64_PLT32:","categories":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]},{"title":"ubuntu使用Systemback备份系统","slug":"ubuntu/ubuntu使用Systemback备份系统","date":"2022-12-01T02:41:25.000Z","updated":"2022-12-01T03:01:15.127Z","comments":true,"path":"2022/12/01/ubuntu/ubuntu使用Systemback备份系统/","link":"","permalink":"http://example.com/2022/12/01/ubuntu/ubuntu%E4%BD%BF%E7%94%A8Systemback%E5%A4%87%E4%BB%BD%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"一、安装systemback首先删除原有的PPA 1sudo add-apt-repository --remove ppa:nemh/systemback 导入此PPA的GPG签名秘钥 1sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 382003C2C8B7B4AB813E915B14E4942973C62A1B 由于ubuntu18没有systemback的下载源，可以使用Ubuntu16的下载源 1sudo add-apt-repository &quot;deb http://ppa.launchpad.net/nemh/systemback/ubuntu xenial main&quot; 更新源 12sudo apt updatesudo apt install systemback 二、备份系统 三、打包镜像1、系统小于4G直接在软件上生成ISO镜像 2、系统大于4G1) 解压 .sblive文件 12mkdir sblivetar -xf /home/systemback_live_2016-04-27.sblive -C sblive 2) 重命名文件 12mv sblive/syslinux/syslinux.cfg sblive/syslinux/isolinux.cfgmv sblive/syslinux sblive/isolinux 3) 安装cdrtools 123456sudo gedit https://nchc.dl.sourceforge.net/project/cdrtools/alpha/cdrtools-3.02a07.tar.gztar -xzvf cdrtools-3.02a07.tar.gzcd cdrtools-3.02./configuremakesudo make install 4) 生成ISO文件 1/opt/schily/bin/mkisofs -iso-level 3 -r -V sblive -cache-inodes -J -l -b isolinux/isolinux.bin -no-emul-boot -boot-load-size 4 -boot-info-table -c isolinux/boot.cat -o sblive.iso sblive","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"将STM32的JTAG口(PA15,PB3,PB4)配置成gpio","slug":"stm32/将STM32的JTAG口-PA15-PB3-PB4-配置成gpio","date":"2022-11-15T01:25:03.000Z","updated":"2022-11-15T01:37:24.242Z","comments":true,"path":"2022/11/15/stm32/将STM32的JTAG口-PA15-PB3-PB4-配置成gpio/","link":"","permalink":"http://example.com/2022/11/15/stm32/%E5%B0%86STM32%E7%9A%84JTAG%E5%8F%A3-PA15-PB3-PB4-%E9%85%8D%E7%BD%AE%E6%88%90gpio/","excerpt":"","text":"一、寄存器代码1234567RCC-&gt;APB2ENR|=1&lt;&lt;2; //使能PORTA时钟 RCC-&gt;APB2ENR |= RCC_APB2ENR_AFIOEN; AFIO-&gt;MAPR = AFIO_MAPR_SWJ_CFG_JTAGDISABLE; //关闭JTAG 释放出PB3,PB4,PA15GPIOA-&gt;CRH&amp;=0X0FFFFFFF; //A15GPIOA-&gt;CRH|=0X20000000; //2MHz通用推挽输出 GPIOA-&gt;ODR|=0&lt;&lt;15; //PA15 输出低 注意: 1) 对寄存器AFIO_EVCR，AFIO_MAPR和AFIO_EXTICRX进行读写操作前，应当先打开AFIO的时钟 2) 必须以32位的方式操作这些外设寄存器 二、Hal库代码12RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOB, ENABLE);GPIO_PInRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE); 三、rtthread调用代码12__HAL_RCC_AFIO_CLK_ENABLE();__HAL_AFIO_REMAP_SWJ_NOJTAG();","categories":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/categories/STM32/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}]},{"title":"Linux驱动[实践]:15--使用内核现有驱动","slug":"linuxDrive/Linux驱动-实践-15-使用内核现有驱动","date":"2022-11-01T07:18:24.000Z","updated":"2022-11-01T07:21:32.548Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-15-使用内核现有驱动/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-15-%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E7%8E%B0%E6%9C%89%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:14--PDD与设备树","slug":"linuxDrive/Linux驱动-实践-14-PDD与设备树","date":"2022-11-01T07:18:05.000Z","updated":"2022-11-05T02:27:36.268Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-14-PDD与设备树/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-14-PDD%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91/","excerpt":"","text":"一、驱动-总线-设备模型1、功能职责1) 驱动部分：负责实现设备的控制逻辑及用户接口，并注册到内核 2) 设备部分：负责描述设备的硬件资源，并告知内核 3) 总线部分：负责实现设备与驱动之间的感知、识别、匹配规则 2、样例platform_bus(即总线部分)内核已经实现了，所以我们只需要实现两边的 platform_xxx_driver和platform_xxx_device即可，然后把它们挂到平台总线上去， 总线会自动进行匹配的。以下只是以led为例说明platform相关接口用法，并未真正实现led驱动。 1234567891011121314151617181920212223242526272829303132333435#include &lt;linux/module.h&gt;#include &lt;linux/platform_device.h&gt;// 当总线匹配到设备时调用该函数static int led_probe(struct platform_device* dev) &#123; printk(&quot;led %s probe\\n&quot;, dev-&gt;name); // todo: 字符设备注册、gpio申请之类的 return 0;&#125;// 当总线匹配到设备卸载时调用该函数static int led_remove(struct platform_device* dev) &#123; printk(&quot;led %s removed\\n&quot;, dev-&gt;name); // todo: 其他资源释放 return 0;&#125;// 平台驱动描述static struct platform_driver led_driver = &#123; .probe = led_probe, .remove = led_remove, .driver = &#123; .name = &quot;my_led&quot;, // 👈务必注意，platform是以name比对来匹配的 .owner = THIS_MODULE, &#125;,&#125;;// 【宏】将led驱动挂到平台总线上// 相当于同时定义了模块的入口和出口函数// module_init(platform_driver_register)// module_exit(platform_driver_unregister)module_platform_driver(led_driver);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); 12345678910111213141516171819202122232425262728293031#include &lt;linux/module.h&gt;#include &lt;linux/platform_device.h&gt;// 最好实现该接口，否则在设备释放的时候内核会报错static void led_release(struct device* pdev) &#123; printk(&quot;led release!\\n&quot;);&#125;// 平台设备描述static struct platform_device led_device = &#123; .name = &quot;my_led&quot;, // 👈要确保与led_driver的定义一致，否则匹配不上 .dev = &#123; .release = led_release, &#125;,&#125;;// 将设备注册到平台总线static int leddev_init(void) &#123; platform_device_register(&amp;led_device); return 0;&#125;module_init(leddev_init);static void leddev_exit(void) &#123; platform_device_unregister(&amp;led_device);&#125;module_exit(leddev_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); 简述一下代码的逻辑： 1) platform_bus监听到有device注册时，会查看它的device.name 2) platform_bus会查找所有的driver.name，找到之后将设备和驱动进行绑定 3) 绑定成功后，platform_driver.probe()将触发，刚才的设备作为参数传递进去 4) 剩下的事情，就看你如何实现platform_driver了 二、树莓派设备树1、用设备树注册设备led_driver.c 其他内容不变，仅仅是增加of_device_id属性。 12345678910111213141516// 首先用of_device_id声明了三种LED型号的表，支持设备树解析static const struct of_device_id of_leds_id[] = &#123; &#123; .compatible = &quot;led_type_a&quot; &#125;, &#123; .compatible = &quot;led_type_b&quot; &#125;, &#123; .compatible = &quot;led_type_c&quot; &#125;,&#125;;static struct platform_driver led_driver = &#123; .probe = led_probe, .remove = led_remove, .driver = &#123; .name = &quot;my_led&quot;, .of_match_table = of_leds_id, // 👈在驱动种添加对应属性 .owner = THIS_MODULE, &#125;,&#125;; 接着新建一个设备树文件，并定义一个led_type_a的LED设备，并将其命名为led_a1 12345678910111213/dts-v1/;/plugin/;/ &#123; fragment@0 &#123; target-path = &quot;/&quot;; __overlay__ &#123; led_a1 &#123; compatible = &quot;led_type_a&quot;; &#125;; &#125;; &#125;;&#125;; fragment和__overlay__非常重要！！如果不这么写会导致动态加载失败，但其实以上的代码转化为标准的设备树语法为： 123/led_a1 &#123; compatible = &quot;led_type_a&quot;;&#125;; 1linux-rpi-4.19.y/scripts/dtc/dtc -I dts -o myled.dtbo myled.dts 再来回顾下流程： 1) 首先驱动要支持of_device_id属性，并且以compatible作为匹配对象 2) 然后通过编写设备树定义相应的设备资源 3) 最后通过加载驱动和dtoverlay即可 2、让设备开机自动注册/boot/overlays其实是通过config.txt配置和使能的，所以我们只需要将myled.dtbo放到overlays目录下，并在config.txt添加一行使能即可。 123sudo cp myled.dtbo /boot/overlayssudo echo &quot;dtoverlay=myled&quot; | sudo tee -a /boot/config.txtsudo reboot 但是，设备树仅仅是定义了led_device，而led_driver.ko其实并没有开机加载，如果要更完善的话，应该把led_driver直接编译进内核！ 三、总结","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:13--USB 驱动开发","slug":"linuxDrive/Linux驱动-实践-13-USB-驱动开发","date":"2022-11-01T07:17:31.000Z","updated":"2022-11-01T07:21:22.456Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-13-USB-驱动开发/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-13-USB-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:12--USB HID驱动开发","slug":"linuxDrive/Linux驱动-实践-12-USB-HID驱动开发","date":"2022-11-01T07:17:04.000Z","updated":"2022-11-01T07:21:19.544Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-12-USB-HID驱动开发/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-12-USB-HID%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:11--framebuff驱动学习","slug":"linuxDrive/Linux驱动-实践-11-framebuff驱动学习","date":"2022-11-01T07:16:42.000Z","updated":"2022-11-01T07:21:17.064Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-11-framebuff驱动学习/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-11-framebuff%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:10--SPI驱动","slug":"linuxDrive/Linux驱动-实践-10-SPI驱动","date":"2022-11-01T07:16:20.000Z","updated":"2022-11-01T07:21:14.424Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-10-SPI驱动/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-10-SPI%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:09--输入子系统","slug":"linuxDrive/Linux驱动-实践-09-输入子系统","date":"2022-11-01T07:16:04.000Z","updated":"2022-11-17T06:19:24.412Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-09-输入子系统/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-09-%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"一、主要步骤及说明1、主要代码123456789101112131415161718192021222324252627282930313233343536static int vs1838_probe(struct platform_device *pdev)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); /* 1. 获得硬件信息 */ vs1838_data_pin = gpiod_get(&amp;pdev-&gt;dev, NULL, 0); if (IS_ERR(vs1838_data_pin)) &#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); &#125; irq = gpiod_to_irq(vs1838_data_pin); request_irq(irq, vs1838_isr, IRQF_TRIGGER_RISING|IRQF_TRIGGER_FALLING, &quot;vs1838&quot;, NULL); /* 输入系统的代码 */ /* 参考: drivers\\input\\keyboard\\gpio_keys.c */ /* A. 分配input_dev */ vs1838_input_dev = devm_input_allocate_device(&amp;pdev-&gt;dev); /* B. 设置input_dev */ vs1838_input_dev-&gt;name = &quot;vs1838&quot;; vs1838_input_dev-&gt;phys = &quot;vs1838&quot;; /* B.1 能产生哪类事件 */ __set_bit(EV_KEY, vs1838_input_dev-&gt;evbit); __set_bit(EV_REP, vs1838_input_dev-&gt;evbit); /* B.2 能产生哪些事件 */ //__set_bit(KEY_0, vs1838_input_dev-&gt;keybit); memset(vs1838_input_dev-&gt;keybit, 0xff, sizeof(vs1838_input_dev-&gt;keybit)); /* C. 注册input_dev */ input_register_device(vs1838_input_dev); return 0;&#125; 2、说明1) 分配input_dev 并设置参数 1234vs1838_input_dev = devm_input_allocate_device(&amp;pdev-&gt;dev);vs1838_input_dev-&gt;name = &quot;vs1838&quot;;vs1838_input_dev-&gt;phys = &quot;vs1838&quot;; 2) 分配input_dev 并设置参数 设备驱动通过set_bit()告诉input子系统它支持哪些事件 12set_bit(EV_KEY, vs1838_input_dev-&gt;evbit);set_bit(EV_REP, vs1838_input_dev-&gt;evbit); 主要的事件类型主要包括： 3) 能产生那些事件 0xff类似于掩码，表示按键值可以0x00 - 0xFF 1memset(vs1838_input_dev-&gt;keybit, 0xff, sizeof(vs1838_input_dev-&gt;keybit)); 4) 注册input_dev 这些操作完成后，就会存在一个新的event文件。存在于/dev/input路径下 1input_register_device(vs1838_input_dev); 5) 产生通知 1234input_event(vs1838_input_dev, EV_KEY, val, 1);input_event(vs1838_input_dev, EV_KEY, val, 0);input_sync(vs1838_input_dev); 二、完整实例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261#include &lt;linux/module.h&gt;#include &lt;linux/poll.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/miscdevice.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/major.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/seq_file.h&gt;#include &lt;linux/stat.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/tty.h&gt;#include &lt;linux/kmod.h&gt;#include &lt;linux/gfp.h&gt;#include &lt;linux/gpio/consumer.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/of_gpio.h&gt;#include &lt;linux/of_irq.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/irq.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/fcntl.h&gt;#include &lt;linux/timer.h&gt;#include &lt;linux/workqueue.h&gt;#include &lt;asm/current.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/ktime.h&gt;#include &lt;linux/version.h&gt;#include &lt;linux/input.h&gt;static struct gpio_desc *vs1838_data_pin;static int irq;static unsigned int vs1838_data = 0; static u64 vs1838_edge_time[100];static int vs1838_edge_cnt = 0;static struct input_dev *vs1838_input_dev;/* 0 : 成功, *val中记录数据* -1: 没接收完毕* -2: 解析错误*/int vs1838_parse_data(unsigned int *val)&#123; u64 tmp; unsigned char data[4]; int i, j, m; /* 判断是否重复码 */ if (vs1838_edge_cnt == 4) &#123; tmp = vs1838_edge_time[1] - vs1838_edge_time[0]; if (tmp &gt; 8000000 &amp;&amp; tmp &lt; 10000000) &#123; tmp = vs1838_edge_time[2] - vs1838_edge_time[1]; if (tmp &lt; 3000000) &#123; /* 获得了重复码 */ *val = vs1838_data; return 0; &#125; &#125; &#125; /* 接收到了66次中断 */ m = 3; if (vs1838_edge_cnt &gt;= 68) &#123; /* 解析到了数据 */ for (i = 0; i &lt; 4; i++) &#123; data[i] = 0; /* 先接收到bit0 */ for (j = 0; j &lt; 8; j++) &#123; /* 数值: 1 */ if (vs1838_edge_time[m+1] - vs1838_edge_time[m] &gt; 1000000) data[i] |= (1&lt;&lt;j); m += 2; &#125; &#125; /* 检验数据 */ data[1] = ~data[1]; if (data[0] != data[1]) &#123; printk(&quot;%s %s line %d, %x, %x, %x\\n&quot;, __FILE__, __FUNCTION__, __LINE__, data[0], data[1], ~data[1]); return -2; &#125; data[3] = ~data[3]; if (data[2] != data[3]) &#123; printk(&quot;%s %s line %d, %x, %x, %x\\n&quot;, __FILE__, __FUNCTION__, __LINE__, data[2], data[3], ~data[3]); return -2; &#125; vs1838_data = (data[0] &lt;&lt; 8) | (data[2]); *val = vs1838_data; return 0; &#125; else &#123; /* 数据没接收完毕 */ return -1; &#125; &#125; static irqreturn_t vs1838_isr(int irq, void *dev_id)&#123; unsigned int val; int ret; //printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__);#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 0, 0)) vs1838_edge_time[vs1838_edge_cnt++] = ktime_get_boottime_ns();#else vs1838_edge_time[vs1838_edge_cnt++] = ktime_get_boot_ns();#endif /* 判断超时 */ if (vs1838_edge_cnt &gt;= 2) &#123; if (vs1838_edge_time[vs1838_edge_cnt-1] - vs1838_edge_time[vs1838_edge_cnt-2] &gt; 30000000) &#123; /* 超时 */ vs1838_edge_time[0] = vs1838_edge_time[vs1838_edge_cnt-1]; vs1838_edge_cnt = 1; return IRQ_HANDLED; // IRQ_WAKE_THREAD; &#125; &#125; ret = vs1838_parse_data(&amp;val); if (!ret) &#123; /* 解析成功 */ vs1838_edge_cnt = 0; //printk(&quot;get ir code = 0x%x\\n&quot;, val); val=val&amp;0xff; /* D. 输入系统: 上报数据 */ input_event(vs1838_input_dev, EV_KEY, val, 1); input_event(vs1838_input_dev, EV_KEY, val, 0); input_sync(vs1838_input_dev); //input_event(vs1838_input_dev, EV_SYN, 0, 0); &#125; else if (ret == -2) &#123; /* 解析失败 */ vs1838_edge_cnt = 0; &#125; return IRQ_HANDLED; // IRQ_WAKE_THREAD;&#125;/* 1. 从platform_device获得GPIO* 2. gpio=&gt;irq* 3. request_irq*/static int vs1838_probe(struct platform_device *pdev)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); /* 1. 获得硬件信息 */ vs1838_data_pin = gpiod_get(&amp;pdev-&gt;dev, NULL, 0); if (IS_ERR(vs1838_data_pin)) &#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); &#125; irq = gpiod_to_irq(vs1838_data_pin); request_irq(irq, vs1838_isr, IRQF_TRIGGER_RISING|IRQF_TRIGGER_FALLING, &quot;vs1838&quot;, NULL); /* 输入系统的代码 */ /* 参考: drivers\\input\\keyboard\\gpio_keys.c */ /* A. 分配input_dev */ vs1838_input_dev = devm_input_allocate_device(&amp;pdev-&gt;dev); /* B. 设置input_dev */ vs1838_input_dev-&gt;name = &quot;vs1838&quot;; vs1838_input_dev-&gt;phys = &quot;vs1838&quot;; /* B.1 能产生哪类事件 */ set_bit(EV_KEY, vs1838_input_dev-&gt;evbit); set_bit(EV_REP, vs1838_input_dev-&gt;evbit); /* B.2 能产生哪些事件 */ //__set_bit(KEY_0, vs1838_input_dev-&gt;keybit); memset(vs1838_input_dev-&gt;keybit, 0xff, sizeof(vs1838_input_dev-&gt;keybit)); /* C. 注册input_dev */ input_register_device(vs1838_input_dev); return 0;&#125;static int vs1838_remove(struct platform_device *pdev)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); input_unregister_device(vs1838_input_dev); free_irq(irq, NULL); gpiod_put(vs1838_data_pin); return 0;&#125;static const struct of_device_id ask100_vs1838[] = &#123; &#123; .compatible = &quot;pgg,vs1838&quot; &#125;, &#123; &#125;,&#125;;/* 1. 定义platform_driver */static struct platform_driver vs1838_driver = &#123; .probe = vs1838_probe, .remove = vs1838_remove, .driver = &#123; .name = &quot;myvs1883_drv&quot;, .of_match_table = ask100_vs1838, &#125;,&#125;;/* 2. 在入口函数注册platform_driver */static int __init vs1838_init(void)&#123; int err; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); err = platform_driver_register(&amp;vs1838_driver); return err;&#125;/* 3. 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数* 卸载platform_driver*/static void __exit vs1838_exit(void)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); platform_driver_unregister(&amp;vs1838_driver);&#125;/* 7. 其他完善：提供设备信息，自动创建设备节点 */module_init(vs1838_init);module_exit(vs1838_exit);MODULE_LICENSE(&quot;GPL&quot;);","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:08--I2C设备驱动","slug":"linuxDrive/Linux驱动-实践-08-I2C设备驱动","date":"2022-11-01T07:15:44.000Z","updated":"2022-11-14T09:49:45.756Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-08-I2C设备驱动/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-08-I2C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"一、设备树的编写1、设备树增加i2c设备123456789101112131415161718192021222324&amp;i2c1 &#123; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;i2c1_pins&gt;; clock-frequency = &lt;100000&gt;; mpu6050@68&#123; compatible = &quot;stephen,mpu6050&quot;; reg = &lt;0x68&gt;; //设备地址 status = &quot;okay&quot;; &#125;; mcp23017@20 &#123; compatible = &quot;stephen,mcp23017_1&quot;; reg = &lt;0x20&gt;; status = &quot;okay&quot;; &#125;; mcp23017@27 &#123; compatible = &quot;stephen,mcp23017_2&quot;; reg = &lt;0x27&gt;; status = &quot;okay&quot;; &#125;;&#125;; 2、启用树莓派系统i2c 二、MPU6050例子1、系统驱动程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/mod_devicetable.h&gt;#include &lt;linux/log2.h&gt;#include &lt;linux/bitops.h&gt;#include &lt;linux/jiffies.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/acpi.h&gt;#include &lt;linux/i2c.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/miscdevice.h&gt;#include &quot;mpu6050.h&quot;#define SMPLRT_DIV 0x19#define CONFIG 0x1A#define GYRO_CONFIG 0x1B#define ACCEL_CONFIG 0x1C#define ACCEL_XOUT_H 0x3B#define ACCEL_XOUT_L 0x3C#define ACCEL_YOUT_H 0x3D#define ACCEL_YOUT_L 0x3E#define ACCEL_ZOUT_H 0x3F#define ACCEL_ZOUT_L 0x40#define TEMP_OUT_H 0x41#define TEMP_OUT_L 0x42#define GYRO_XOUT_H 0x43#define GYRO_XOUT_L 0x44#define GYRO_YOUT_H 0x45#define GYRO_YOUT_L 0x46#define GYRO_ZOUT_H 0x47#define GYRO_ZOUT_L 0x48#define PWR_MGMT_1 0x6Bstatic int major;static struct class *mpu6050_class;// struct mpu6050_device &#123;// struct cdev cdev;// struct i2c_client *client;// &#125;;struct i2c_client *mpu6050_client; static int mpu6050_read_byte(struct i2c_client *client, unsigned char reg)&#123; int ret; char txbuf[1] = &#123; reg &#125;; char rxbuf[1]; struct i2c_msg msg[2] = &#123; &#123;client-&gt;addr, 0, 1, txbuf&#125;, &#123;client-&gt;addr, I2C_M_RD, 1, rxbuf&#125; &#125;; ret = i2c_transfer(client-&gt;adapter, msg, ARRAY_SIZE(msg)); if (ret &lt; 0) &#123; printk(&quot;ret = %d\\n&quot;, ret); return ret; &#125; // printk(&quot;%s,%d\\n&quot;,__func__,__LINE__); return rxbuf[0];&#125;static int mpu6050_write_byte(struct i2c_client *client, unsigned char reg, unsigned char val)&#123; char txbuf[2] = &#123;reg, val&#125;; // addr, write , len , data struct i2c_msg msg[2] = &#123; &#123;client-&gt;addr, 0, 2, txbuf&#125;, &#125;; // 给从机发送消息 i2c_transfer(client-&gt;adapter, msg, ARRAY_SIZE(msg)); // printk(&quot;%s,%d\\n&quot;,__func__,__LINE__); return 0;&#125;static int mpu6050_open(struct inode *inode, struct file *file) &#123; return 0;&#125;static int mpu6050_release(struct inode *inode, struct file *file) &#123; return 0;&#125;static long mpu6050_ioctl(struct file *file, unsigned int cmd, unsigned long arg)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); union mpu6050_data data; struct i2c_client *client = mpu6050_client; switch (cmd) &#123; case GET_ACCEL: data.accel.x = mpu6050_read_byte(client, ACCEL_XOUT_L); data.accel.x |= mpu6050_read_byte(client, ACCEL_XOUT_H) &lt;&lt; 8; data.accel.y = mpu6050_read_byte(client, ACCEL_YOUT_L); data.accel.y |= mpu6050_read_byte(client, ACCEL_YOUT_H) &lt;&lt; 8; data.accel.z = mpu6050_read_byte(client, ACCEL_ZOUT_L); data.accel.z |= mpu6050_read_byte(client, ACCEL_ZOUT_H) &lt;&lt; 8; break; case GET_GYRO: data.gyro.x = mpu6050_read_byte(client, GYRO_XOUT_L); data.gyro.x |= mpu6050_read_byte(client, GYRO_XOUT_H) &lt;&lt; 8; data.gyro.y = mpu6050_read_byte(client, GYRO_YOUT_L); data.gyro.y |= mpu6050_read_byte(client, GYRO_YOUT_H) &lt;&lt; 8; data.gyro.z = mpu6050_read_byte(client, GYRO_ZOUT_L); data.gyro.z |= mpu6050_read_byte(client, GYRO_ZOUT_H) &lt;&lt; 8; break; case GET_TEMP: data.temp = mpu6050_read_byte(client, TEMP_OUT_L); data.temp |= mpu6050_read_byte(client, TEMP_OUT_H) &lt;&lt; 8; break; default: printk(&quot;invalid argument\\n&quot;); return -EINVAL; break; &#125; if (copy_to_user((void *)arg, &amp;data, sizeof(data))) return -EFAULT; return sizeof(data);;&#125;static struct file_operations mpu6050_fops = &#123; .owner = THIS_MODULE, .open = mpu6050_open, .release = mpu6050_release, .unlocked_ioctl = mpu6050_ioctl,&#125;;static int mpu6050_probe(struct i2c_client *client, const struct i2c_device_id *id)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); mpu6050_client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL); if (mpu6050_client == NULL) &#123; return -ENOMEM; &#125; mpu6050_client = client; major = register_chrdev(0, &quot;mpu6050&quot;, &amp;mpu6050_fops); mpu6050_class = class_create(THIS_MODULE, &quot;mpu6050_class&quot;); device_create(mpu6050_class, NULL, MKDEV(major, 0), NULL, &quot;mympu6050&quot;); // 初始化mpu6050 mpu6050_write_byte(client, PWR_MGMT_1, 0x00); mpu6050_write_byte(client, SMPLRT_DIV, 0x07); mpu6050_write_byte(client, CONFIG, 0x06); mpu6050_write_byte(client, GYRO_CONFIG, 0xF8); mpu6050_write_byte(client, ACCEL_CONFIG, 0x19); return 0;&#125;static int mpu6050_remove(struct i2c_client *client)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); device_destroy(mpu6050_class, MKDEV(major, 0)); class_destroy(mpu6050_class); unregister_chrdev(major, &quot;mpu6050&quot;); kfree(mpu6050_client); return 0;&#125;static const struct of_device_id mpu6050_of_match[] = &#123; &#123;.compatible = &quot;stephen,mpu6050&quot;&#125;, &#123;&#125;&#125;;static struct i2c_driver mpu6050_drv = &#123; .driver = &#123; .name = &quot;mympu6050_drv&quot;, .of_match_table = mpu6050_of_match, &#125;, .probe = mpu6050_probe, .remove = mpu6050_remove,&#125;;static int mpu6050_init(void)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); return i2c_add_driver(&amp;mpu6050_drv);&#125;static void mpu6050_exit(void)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); i2c_del_driver(&amp;mpu6050_drv);&#125;module_init(mpu6050_init);module_exit(mpu6050_exit);MODULE_LICENSE(&quot;GPL&quot;); 2、用户测试程序12345678910111213141516171819202122232425262728293031323334353637#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;mpu6050.h&quot;int main(int argc, char **argv)&#123; int fd; union mpu6050_data data; fd = open(&quot;/dev/mympu6050&quot;, O_RDWR); if (fd &lt; 0) &#123; printf(&quot; can not open %s\\n&quot;, argv[1]); return -1; &#125; while(1) &#123; ioctl(fd, GET_ACCEL, &amp;data); printf(&quot;acceleration data: x = %04x, y = %04x, z = %04x\\n&quot;, data.accel.x, data.accel.y, data.accel.z); ioctl(fd, GET_GYRO, &amp;data); printf(&quot;gyroscope data: x = %04x, y = %04x, z = %04x\\n&quot;, data.accel.x, data.accel.y, data.accel.z); sleep(1); &#125; close(fd); return 0;&#125; 3、公共头文件1234567891011121314151617181920212223242526272829#ifndef MPU6050_H#define MPU6050_H#include &lt;asm-generic/ioctl.h&gt;#define MPU6050_MAGIC &#x27;K&#x27;union mpu6050_data &#123; struct &#123; unsigned short x; unsigned short y; unsigned short z; &#125; accel; struct &#123; unsigned short x; unsigned short y; unsigned short z; &#125; gyro; signed short temp;&#125;;#define GET_ACCEL _IOR(MPU6050_MAGIC, 0, union mpu6050_data)#define GET_GYRO _IOR(MPU6050_MAGIC, 1, union mpu6050_data) #define GET_TEMP _IOR(MPU6050_MAGIC, 2, union mpu6050_data)#endif 三、MCP23017扩展IO例子1、系统驱动程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/mod_devicetable.h&gt;#include &lt;linux/log2.h&gt;#include &lt;linux/bitops.h&gt;#include &lt;linux/jiffies.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/acpi.h&gt;#include &lt;linux/i2c.h&gt;S&#x27;s#include &lt;asm/uaccess.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/miscdevice.h&gt;#define DIRE_CONFIG_A 0x00#define DIRE_CONFIG_B 0x01#define PORT_A 0x12#define PORT_B 0x13static int major;static struct class *mcp23017_class;struct i2c_client *mcp23017_client; static int mcp23017_read_byte(struct i2c_client *client, unsigned char reg)&#123; int ret; char txbuf[1] = &#123; reg &#125;; char rxbuf[1]; struct i2c_msg msg[2] = &#123; &#123;client-&gt;addr, 0, 1, txbuf&#125;, &#123;client-&gt;addr, I2C_M_RD, 1, rxbuf&#125; &#125;; ret = i2c_transfer(client-&gt;adapter, msg, ARRAY_SIZE(msg)); if (ret &lt; 0) &#123; printk(&quot;ret = %d\\n&quot;, ret); return ret; &#125; // printk(&quot;%s,%d\\n&quot;,__func__,__LINE__); return rxbuf[0];&#125;static int mcp23017_write_byte(struct i2c_client *client, unsigned char reg, unsigned char val)&#123; char txbuf[2] = &#123;reg, val&#125;; // addr, write , len , data struct i2c_msg msg[2] = &#123; &#123;client-&gt;addr, 0, 2, txbuf&#125;, &#125;; // 给从机发送消息 i2c_transfer(client-&gt;adapter, msg, ARRAY_SIZE(msg)); // printk(&quot;%s,%d\\n&quot;,__func__,__LINE__); return 0;&#125;static int mcp23017_open(struct inode *inode, struct file *file) &#123; return 0;&#125;static int mcp23017_release(struct inode *inode, struct file *file) &#123; return 0;&#125;static long mcp23017_ioctl(struct file *file, unsigned int val, unsigned long arg)&#123; printk(&quot;%s, value: %d\\n&quot;, __FUNCTION__, val); mcp23017_write_byte(mcp23017_client, PORT_A, val); mcp23017_write_byte(mcp23017_client, PORT_B, val); return 0;&#125;static struct file_operations mcp23017_fops = &#123; .owner = THIS_MODULE, .open = mcp23017_open, .release = mcp23017_release, .unlocked_ioctl = mcp23017_ioctl,&#125;;static int mcp23017_probe(struct i2c_client *client, const struct i2c_device_id *id)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); mcp23017_client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL); if (mcp23017_client == NULL) &#123; return -ENOMEM; &#125; mcp23017_client = client; major = register_chrdev(0, &quot;mcp23017&quot;, &amp;mcp23017_fops); mcp23017_class = class_create(THIS_MODULE, &quot;mcp23017_class&quot;); device_create(mcp23017_class, NULL, MKDEV(major, 0), NULL, &quot;mymcp23017&quot;); //设置引脚方向，0x00:输出， 0xFF:输入(默认) mcp23017_write_byte(client, DIRE_CONFIG_A, 0x00); mcp23017_write_byte(client, DIRE_CONFIG_B, 0x00); return 0;&#125;static int mcp23017_remove(struct i2c_client *client)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); device_destroy(mcp23017_class, MKDEV(major, 0)); class_destroy(mcp23017_class); unregister_chrdev(major, &quot;mcp23017&quot;); kfree(mcp23017_client); return 0;&#125;static const struct of_device_id mcp23017_of_match[] = &#123; &#123;.compatible = &quot;stephen,mcp23017_1&quot;&#125;, &#123;&#125;&#125;;static struct i2c_driver mcp23017_drv = &#123; .driver = &#123; .name = &quot;mymcp23017_drv&quot;, .of_match_table = mcp23017_of_match, &#125;, .probe = mcp23017_probe, .remove = mcp23017_remove,&#125;;static int mcp23017_init(void)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); return i2c_add_driver(&amp;mcp23017_drv);&#125;static void mcp23017_exit(void)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); i2c_del_driver(&amp;mcp23017_drv);&#125;module_init(mcp23017_init);module_exit(mcp23017_exit);MODULE_LICENSE(&quot;GPL&quot;); 2、用户测试程序123456789101112131415161718192021222324252627282930#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv)&#123; int fd; fd = open(&quot;/dev/mymcp23017&quot;, O_RDWR); if (fd &lt; 0) &#123; printf(&quot; can not open %s\\n&quot;, argv[1]); return -1; &#125; unsigned int value = 0xFF; while(1) &#123; ioctl(fd, value, NULL); sleep(3); value = (value == 0) ? 0xFF : 0; &#125; close(fd); return 0;&#125;","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:07--树莓派设备IO访问","slug":"linuxDrive/Linux驱动-实践-07-树莓派设备IO访问","date":"2022-11-01T07:15:26.000Z","updated":"2022-11-19T03:25:51.827Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-07-树莓派设备IO访问/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-07-%E6%A0%91%E8%8E%93%E6%B4%BE%E8%AE%BE%E5%A4%87IO%E8%AE%BF%E9%97%AE/","excerpt":"","text":"1 一、GPIO子系统1、功能通过读取设备树信息，用来获取GPIO，配置GPIO的方向，设置高低电平等。 2、API函数 注：前缀devm_的含义是“设备资源管理”，这是一种自动释放资源的机制。它的思想是“资源是属于设备的，设备不存在时资源就可以自动释放”。 二、查询写法案例1、驱动代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 static int gpio_button_probe(struct platform_device *pdev)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); button_handle = gpiod_get(&amp;pdev-&gt;dev, NULL, 0); gpiod_direction_input(button_handle); /* 注册file_operations */ major = register_chrdev(0, &quot;pgg_button&quot;, &amp;gpio_button_drv); /* /dev/gpio_key */ gpio_button_class = class_create(THIS_MODULE, &quot;gpio_button_class&quot;); if (IS_ERR(gpio_button_class)) &#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); unregister_chrdev(major, &quot;pgg_button&quot;); return PTR_ERR(gpio_button_class); &#125; device_create(gpio_button_class, NULL, MKDEV(major, 0), NULL, &quot;pgg_button&quot;); return 0;&#125;static int gpio_button_remove(struct platform_device *pdev)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); device_destroy(gpio_button_class, MKDEV(major, 0)); class_destroy(gpio_button_class); unregister_chrdev(major, &quot;pgg_button&quot;); gpiod_put(button_handle); return 0;&#125;static ssize_t gpio_button_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); int val; int len =2; val = gpiod_get_value(button_handle); if(val == 1) &#123; copy_to_user(buf, &quot;1&quot;, 2); &#125; else &#123; copy_to_user(buf, &quot;0&quot;, 2); &#125; return len;&#125; 2、测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546 int main(int argc, char **argv)&#123; int fd; char buf[1024]; int len; int ret; /* 1. 判断参数 */ if (argc &lt; 2) &#123; printf(&quot;Usage: %s -w &lt;string&gt;\\n&quot;, argv[0]); printf(&quot; %s -r\\n&quot;, argv[0]); return -1; &#125; /* 2. 打开文件 */ fd = open(&quot;/dev/pgg_button&quot;, O_RDWR); if (fd == -1) &#123; printf(&quot;can not open file /dev/pgg_button\\n&quot;); return -1; &#125; printf(&quot;open file /dev/pgg_button ok\\n&quot;); /* 3. 写文件或读文件 */ if ((0 == strcmp(argv[1], &quot;-w&quot;)) &amp;&amp; (argc == 3)) &#123; len = strlen(argv[2]) + 1; len = len &lt; 1024 ? len : 1024; ret = write(fd, argv[2], len); printf(&quot;write driver: %d\\n&quot;, ret); &#125; else &#123; len = read(fd, buf, 1024); printf(&quot;read driver: %d\\n&quot;, len); buf[1023] = &#x27;\\0&#x27;; printf(&quot;APP read : %s\\n&quot;, buf); &#125; close(fd); return 0;&#125; 三、休眠唤醒法案例1、驱动代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 static int gpio_button_probe(struct platform_device *pdev)&#123; struct device_node *node = pdev-&gt;dev.of_node; enum of_gpio_flags flag; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); gpio_num = of_get_gpio_flags(node, 0, &amp;flag); button_handle = gpiod_get(&amp;pdev-&gt;dev, NULL, 0); gpiod_direction_input(button_handle); button_irq = gpio_to_irq(gpio_num); request_irq(button_irq, gpio_button_isr, IRQF_TRIGGER_RISING, &quot;pgg_button_irq&quot;, NULL);//IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING /* 注册file_operations */ major = register_chrdev(0, &quot;pgg_button&quot;, &amp;gpio_button_drv); /* /dev/gpio_key */ gpio_button_class = class_create(THIS_MODULE, &quot;gpio_button_class&quot;); if (IS_ERR(gpio_button_class)) &#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); unregister_chrdev(major, &quot;pgg_button&quot;); return PTR_ERR(gpio_button_class); &#125; device_create(gpio_button_class, NULL, MKDEV(major, 0), NULL, &quot;pgg_button&quot;); /* /dev/100ask_gpio_key */ return 0;&#125;static irqreturn_t gpio_button_isr(int irq, void *dev_id)&#123; int val; val = gpiod_get_value(button_handle); printk(&quot;key value %d\\n&quot;, val); g_button_value = val; wake_up_interruptible(&amp;gpio_key_wait); return IRQ_HANDLED;&#125;static ssize_t gpio_button_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); //printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); int err; wait_event_interruptible(gpio_key_wait, g_button_value); err = copy_to_user(buf, &amp;g_button_value, 4); g_button_value = 0; return 4;&#125; 2、测试代码12345678910111213141516 &#123; printf(&quot;can not open file %s\\n&quot;, argv[1]); return -1;&#125;while (1)&#123; /* 3. 读文件 */ read(fd, &amp;val, 4); printf(&quot;get button : 0x%x\\n&quot;, val);&#125;close(fd);return 0; 四、休眠唤醒POLL法案例1、驱动代码123456789101112static unsigned int gpio_button_drv_poll(struct file *fp, poll_table * wait)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); poll_wait(fp, &amp;gpio_key_wait, wait); if(g_button_value) return POLLIN | POLLRDNORM; else return 0;&#125; 2、测试代码1234567891011121314151617181920212223242526272829303132333435363738394041int main(int argc, char **argv)&#123; int fd; int val; struct pollfd fds[1]; int timeout_ms = 5000; int ret; /* 1. 判断参数 */ if (argc != 2) &#123; printf(&quot;Usage: %s &lt;dev&gt;\\n&quot;, argv[0]); return -1; &#125; /* 2. 打开文件 */ fd = open(argv[1], O_RDWR); if (fd == -1) &#123; printf(&quot;can not open file %s\\n&quot;, argv[1]); return -1; &#125; fds[0].fd = fd; fds[0].events = POLLIN; while (1) &#123; /* 3. 读文件 */ ret = poll(fds, 1, timeout_ms); if ((ret == 1) &amp;&amp; (fds[0].revents &amp; POLLIN)) &#123; read(fd, &amp;val, 4); printf(&quot;get button : 0x%x\\n&quot;, val); &#125; else &#123; printf(&quot;timeout\\n&quot;); &#125; &#125; close(fd); return 0;&#125; 五、异步通知案例1、驱动代码123456789101112131415161718192021222324252627static int gpio_button_drv_fasync(int fd, struct file *file, int on)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); if (fasync_helper(fd, file, on, &amp;button_fasync) &gt;= 0) return 0; else return -EIO;&#125;static irqreturn_t gpio_button_isr(int irq, void *dev_id)&#123; int val; val = gpiod_get_value(button_handle); printk(&quot;key value: %d\\n&quot;, val); if (val) &#123; g_button_value = val; wake_up_interruptible(&amp;gpio_key_wait); /* 发送中断给用户进程 */ kill_fasync(&amp;button_fasync, SIGIO, POLL_IN); &#125; return IRQ_HANDLED;&#125; 六、完整总结","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:06--树莓派GPIO驱动SR04超声模块","slug":"linuxDrive/Linux驱动-实践-06-树莓派GPIO驱动SR04超声模块","date":"2022-11-01T07:15:07.000Z","updated":"2022-11-05T03:17:05.182Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-06-树莓派GPIO驱动SR04超声模块/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-06-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E9%A9%B1%E5%8A%A8SR04%E8%B6%85%E5%A3%B0%E6%A8%A1%E5%9D%97/","excerpt":"","text":"一、超声模块原理1、工作原理1、Trig引脚接收至少10us的高电平信号，用于触发超声波模块工作； 2、模块会自动发送8个40KHz的方波信号，自动检测是否有信号返回； 3、有信号返回，通过Echo引脚连接单片机的I/O口输出一高电平，高电平持续时间T就是超声波从发射到返回的时间； 4、声音在空气中的传播速度为340米/秒，即可计算出所测的距离：D = 340*T/2。 2、驱动原理这里就需要用到两个GPIO，一个负责Trip，发出触发信号，一个负责Echo，接收Echo高电平信号，并计算高电平时间。 这里的Trip简单，持续一个大于10us的高电平即可，Echo引脚，我们需要监听上下边沿，然后计算出中间的时间，这里就需要用到中断。通过中断得到两个时间点，然后计算差值，传给用户。 二、驱动实现1、设备树编写123456mysr04 &#123; compatible = &quot;pgg, sr04&quot;; status = &quot;okay&quot;; sr-04-gpio = &lt;&amp;gpio, 17, GPIO_ACTIVE_HIGH&gt;, &lt;&amp;gpio, 18, GPIO_ACTIVE_HIGH&gt;, &#125; 2、引脚读取方式123struct gpio_desc *trip, *echo;trip= gpiod_get_index(dev, &quot;sr04&quot;, 0, GPIOD_OUT_HIGH);echo= gpiod_get_index(dev, &quot;sr04&quot;, 1, GPIOD_OUT_HIGH); 3、硬件及中断12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970struct sr04_gpios&#123; struct gpio_desc *trip; struct gpio_desc *echo; int echo_irq;&#125; ;struct sr04_gpios my_sr04_gpios;static int mysr04_probe(struct platform_device *pdev)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); //读取关键引脚描述信息 my_sr04_gpios.trip= gpiod_get_index(&amp;pdev-&gt;dev, &quot;sr04&quot;, 0, GPIOD_OUT_HIGH); my_sr04_gpios.echo= gpiod_get_index(&amp;pdev-&gt;dev, &quot;sr04&quot;, 1, GPIOD_OUT_HIGH); //配置方向 gpiod_direction_output(my_sr04_gpios.trip,0); gpiod_direction_input(my_sr04_gpios.echo); //获取中断 my_sr04_gpios.echo_irq = gpiod_to_irq(my_sr04_gpios.echo); //注册中断 request_irq(my_sr04_gpios.echo_irq, my_sr04_echo_isr, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, &quot;mysr04_irq&quot;, NULL);//IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING /* 注册file_operations */ major = register_chrdev(0, &quot;pgg_sr04&quot;, &amp;gpio_button_drv); mysr04_class = class_create(THIS_MODULE, &quot;mysr04_class&quot;); if (IS_ERR(mysr04_class)) &#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); unregister_chrdev(major, &quot;pgg_sr04&quot;); return PTR_ERR(mysr04_class); &#125; device_create(mysr04_class, NULL, MKDEV(major, 0), NULL, &quot;pgg_sr04&quot;); /* /dev/pgg_sr04 */ return 0;&#125;static int mysr04_remove(struct platform_device *pdev)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); device_destroy(mysr04_class, MKDEV(major, 0)); class_destroy(mysr04_class); unregister_chrdev(major, &quot;pgg_sr04&quot;); gpiod_put(my_sr04_gpios.trip); gpiod_put(my_sr04_gpios.echo); free_irq(my_sr04_gpios.echo_irq,NULL); return 0;&#125;static irqreturn_t my_sr04_echo_isr(int irq, void *dev_id)&#123; printk(&quot;revice irq %d\\n&quot;, irq); return IRQ_HANDLED;&#125;static ssize_t gpio_button_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); gpiod_set_value(my_sr04_gpios.trip,1); udelay(100); gpiod_set_value(my_sr04_gpios.trip,0); return 0;&#125; 测试程序： 1234567891011121314151617181920212223242526272829303132333435363738394041int main(int argc, char **argv)&#123; int fd; char buf[1024]; int len; int ret; /* 1. 判断参数 */ if (argc &lt; 2) &#123; printf(&quot;Usage: %s -w &lt;string&gt;\\n&quot;, argv[0]); printf(&quot; %s -r\\n&quot;, argv[0]); return -1; &#125; /* 2. 打开文件 */ fd = open(&quot;/dev/pgg_sr04&quot;, O_RDWR); if (fd == -1) &#123; printf(&quot;can not open file /dev/pgg_sr04\\n&quot;); return -1; &#125; printf(&quot;open file /dev/pgg_sr04 ok\\n&quot;); /* 3. 写文件或读文件 */ if ((0 == strcmp(argv[1], &quot;-w&quot;)) &amp;&amp; (argc == 3)) &#123; len = strlen(argv[2]) + 1; len = len &lt; 1024 ? len : 1024; ret = write(fd, argv[2], len); printf(&quot;write driver: %d\\n&quot;, ret); &#125; else &#123; len = read(fd, buf, 1024); printf(&quot;read driver: %d\\n&quot;, len); buf[1023] = &#x27;\\0&#x27;; printf(&quot;APP read : %s\\n&quot;, buf); &#125; close(fd); return 0;&#125; 4、计算时间差值12345678910111213141516171819202122static irqreturn_t my_sr04_echo_isr(int irq, void *dev_id)&#123; int val = gpiod_get_value(my_sr04_gpios.echo); if (val) /* 上升沿 */ &#123; /* 1. 记录数据 */ a = ktime_get_ns(); printk(&quot;revice irq up a=%llu\\n&quot;,a); &#125; else /* 下降沿 */ &#123; b = ktime_get_ns(); printk(&quot;revice irq down b=%llu\\n&quot;,b); printk(&quot;revice irq %llu\\n&quot;,b-a); &#125; return IRQ_HANDLED;&#125; 5、休眠唤醒12345678910111213141516static irqreturn_t my_sr04_echo_isr(int irq, void *dev_id)&#123; int val = gpiod_get_value(my_sr04_gpios.echo); /* 上升沿 */ if (val) &#123; a = ktime_get_ns(); &#125; else &#123; /* 下降沿 */ b = ktime_get_ns(); dataready = 1; wake_up_interruptible(&amp;mysr04_wait); &#125; return IRQ_HANDLED;&#125; 读取函数中，传出计算出来的时间差 1234567891011121314151617181920212223242526static ssize_t mysr0_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)&#123; char result[64]=&#123;0&#125;; int reslen=0; static u64 c=0; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); a=0; b=0; dataready = 0; gpiod_set_value(my_sr04_gpios.trip,1); udelay(100); gpiod_set_value(my_sr04_gpios.trip,0); wait_event_interruptible(mysr04_wait, dataready); dataready = 0; c = b-a; sprintf(result,&quot;%llu&quot;,c); reslen=strlen(result)+1; copy_to_user(buf, result, reslen); return reslen;&#125; 6、驱动测试12345678910111213141516171819202122232425262728293031323334353637383940int main(int argc, char **argv)&#123; int fd; char buf[1024]; int len; int ret; /* 1. 判断参数 */ if (argc &lt; 2) &#123; printf(&quot; %s -r\\n&quot;, argv[0]); return -1; &#125; /* 2. 打开文件 */ fd = open(&quot;/dev/pgg_sr04&quot;, O_RDWR); if (fd == -1) &#123; printf(&quot;can not open file /dev/pgg_sr04\\n&quot;); return -1; &#125; //printf(&quot;open file /dev/pgg_sr04 ok\\n&quot;); /* 3. 写文件或读文件 */ if ((0 == strcmp(argv[1], &quot;-r&quot;)) &amp;&amp; (argc == 2)) &#123; len = read(fd, buf, 1024); buf[1023] = &#x27;\\0&#x27;; printf(&quot;driver read : %s\\n&quot;, buf); long res= strtol(buf, NULL, 0); double resm=0.00000017*((double)res); printf(&quot;sr04 距离 : %lf 米\\n&quot;, resm); &#125; else &#123; printf(&quot; %s -r\\n&quot;, argv[0]); &#125; close(fd); return 0;&#125; 三、附录1、用户侧和内核用的字符串操作函数区别https://blog.csdn.net/qq_44710568/article/details/105382670 2、关键函数返回值判断1234567static inline int __must_checkrequest_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev)&#123; return request_threaded_irq(irq, handler, NULL, flags, name, dev);&#125; 如果你没有检查，编译的时候，会提醒 12warning: ignoring return value of ‘request_irq’, declared with attribute warn_unused_result [-Wunused-result]","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:05--树莓派GPIO驱动红外模块","slug":"linuxDrive/Linux驱动-实践-05-树莓派GPIO驱动红外模块","date":"2022-11-01T07:14:48.000Z","updated":"2022-11-03T09:01:25.182Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-05-树莓派GPIO驱动红外模块/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-05-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E9%A9%B1%E5%8A%A8%E7%BA%A2%E5%A4%96%E6%A8%A1%E5%9D%97/","excerpt":"","text":"一、NEC协议1、编码说明 2、编码小结1) 协议帧头总是以9ms的高电平和4.5ms的低电平为一个脉冲周期; 2) 协议内容的脉冲周期，‘-___’表示1，‘-_’表示0，且电平信号以560us为单位； 3) 9ms高电平和2.25ms的低电平表示重复码，即长按按键时触发; 4) 帧间间隔为110ms. 二、驱动实现1、流程1) 申请并注册GPIO18的中断，务必是双边沿触发; 2) 申请一个定时器用于超时断帧处理; 3) 每次中断触发，都记录上升或者下降沿的状态及时长; 4) 每当经过一个完整脉冲后，通过占空比判断数据类型; 5) 每当记录了32个数据(一帧)后，处理协议指令; 6) 我是直接把地址和指令推给用户层处理. 2、驱动代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/miscdevice.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/timer.h&gt;#include &lt;linux/wait.h&gt;static struct &#123; int gpio; int irq; wait_queue_head_t rwait; struct timer_list timer; u32 pulse; // 脉冲上升沿持续时长 u32 space; // 脉冲下降沿持续时长 size_t count; // 脉冲个数 u32 data; // 脉冲解码后的值&#125; ir;#define is_head(p, s) (p &gt; 8900 &amp;&amp; p &lt; 9100 &amp;&amp; s &gt; 4400 &amp;&amp; s &lt; 4600)#define is_repeat(p, s) (p &gt; 8900 &amp;&amp; p &lt; 9100 &amp;&amp; s &gt; 2150 &amp;&amp; s &lt; 2350)#define is_bfalse(p, s) (p &gt; 500 &amp;&amp; p &lt; 650 &amp;&amp; s &gt; 500 &amp;&amp; s &lt; 650)#define is_btrue(p, s) (p &gt; 500 &amp;&amp; p &lt; 650 &amp;&amp; s &gt; 1500 &amp;&amp; s &lt; 1750)// 红外接收函数(即GPIO18的双边沿中断处理函数)// 记录GPIO每次中断是“上升还是下降”，以及持续的时长static irqreturn_t ir_rx(int irq, void* dev) &#123; static ktime_t last = 0; u32 duration = (u32)ktime_to_us(ktime_get() - last); // ⚠️注意：1838红外头高低电平逻辑取反 if (!gpio_get_value(ir.gpio)) &#123; ir.space = duration; &#125; else &#123; // 切换下降沿时，脉冲只有高电平部分，所以不做处理 ir.pulse = duration; goto irq_out; &#125; if (is_head(ir.pulse, ir.space)) &#123; ir.count = ir.data = 0; &#125; else if (is_repeat(ir.pulse, ir.space)) &#123; ir.count = 32; &#125; else if (is_btrue(ir.pulse, ir.space)) &#123; ir.data |= 1 &lt;&lt; ir.count++; &#125; else if (is_bfalse(ir.pulse, ir.space)) &#123; ir.data |= 0 &lt;&lt; ir.count++; &#125; else &#123; goto irq_out; &#125; if (ir.count &gt;= 32) &#123; wake_up(&amp;ir.rwait); &#125;irq_out: mod_timer(&amp;ir.timer, jiffies + (HZ / 10)); last = ktime_get(); return IRQ_HANDLED;&#125;// 定时清除红外协议帧的相关信息，便于接收下一帧static void clear_flag(struct timer_list *timer) &#123; ir.pulse = 0; ir.space = 0; ir.count = 0; ir.data = 0;&#125;static ssize_t ir_read(struct file *filp, char __user *buf, size_t len, loff_t *off) &#123; int rc = 0; if ((filp-&gt;f_flags &amp; O_NONBLOCK) &amp;&amp; ir.count &lt; 32) &#123; return -EAGAIN; &#125; else &#123; DECLARE_WAITQUEUE(wq, current); add_wait_queue(&amp;ir.rwait, &amp;wq); wait_event(ir.rwait, ir.count == 32); remove_wait_queue(&amp;ir.rwait, &amp;wq); &#125; rc = copy_to_user(buf, &amp;ir.data, sizeof(u32)); if (rc &lt; 0) &#123; return rc; &#125; ir.count = 0; *off += sizeof(u32); return sizeof(u32);&#125;static const struct file_operations fops = &#123; .owner = THIS_MODULE, .read = ir_read,&#125;;static struct miscdevice irdev = &#123; .minor = MISC_DYNAMIC_MINOR, .name = &quot;IR1838-NEC&quot;, .fops = &amp;fops, .nodename = &quot;ir0&quot;, .mode = 0744,&#125;;static int __init ir_init(void) &#123; int rc = 0; // 初始化脉冲处理函数 init_waitqueue_head(&amp;ir.rwait); // 初始化定时器，用于断帧 timer_setup(&amp;ir.timer, clear_flag, 0); add_timer(&amp;ir.timer); // 申请GPIO及其双边沿中断 ir.gpio = 18; if ((rc = gpio_request_one(ir.gpio, GPIOF_IN, &quot;IR&quot;)) &lt; 0) &#123; printk(KERN_ERR &quot;ERROR%d: can not request gpio%d\\n&quot;, rc, ir.gpio); return rc; &#125; ir.irq = gpio_to_irq(ir.gpio); if ((rc = request_irq(ir.irq, ir_rx, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, &quot;IR&quot;, NULL)) &lt; 0) &#123; printk(KERN_ERR &quot;ERROR%d: can not request irq\\n&quot;, ir.irq); return rc; &#125; if ((rc = misc_register(&amp;irdev)) &lt; 0) &#123; return rc; &#125; return 0;&#125;module_init(ir_init);static void __exit ir_exit(void) &#123; misc_deregister(&amp;irdev); free_irq(ir.irq, NULL); gpio_free(ir.gpio); del_timer(&amp;ir.timer);&#125;module_exit(ir_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); 以上代码有个很大的风险，为了简化程序，IRQ中断并没有采取“底半部”来处理复杂的红外解码业务，如果业务逻辑进一步加大，可能会导致内核崩溃。 3、测试代码12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/fcntl.h&gt;// car-mp3遥控器指令码static const char* keyname[] = &#123;[0x45] = &quot;Channel-&quot;, [0x46] = &quot;Channel&quot;, [0x47] = &quot;Channel+&quot;,[0x44] = &quot;Speed-&quot;, [0x40] = &quot;Speed+&quot;, [0x43] = &quot;Play/Pause&quot;,[0x15] = &quot;Vol+&quot;, [0x07] = &quot;Vol-&quot;, [0x09] = &quot;EQ&quot;,[0x16] = &quot;No.0&quot;, [0x19] = &quot;100+&quot;, [0x0d] = &quot;200+&quot;,[0x0c] = &quot;No.1&quot;, [0x18] = &quot;No.2&quot;, [0x5e] = &quot;No.3&quot;,[0x08] = &quot;No.4&quot;, [0x1c] = &quot;No.5&quot;, [0x5a] = &quot;No.6&quot;,[0x42] = &quot;No.7&quot;, [0x52] = &quot;No.8&quot;, [0x4a] = &quot;No.9&quot;,&#125;;int main(int argc, char* argv[]) &#123; int ir = open(&quot;/dev/ir0&quot;, O_RDONLY); while (1) &#123; int frame = 0; if (read(ir, &amp;frame, sizeof(int)) &lt; 0) &#123; perror(&quot;read ir&quot;); break; &#125; int cmd = (frame &gt;&gt; 16) &amp; 0xFF; printf(&quot;%s\\n&quot;, keyname[cmd]); &#125; close(ir); return 0;&#125;","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:04--树莓派GPIO杂项驱动misc","slug":"linuxDrive/Linux驱动-实践-04-树莓派GPIO杂项驱动misc","date":"2022-11-01T07:14:15.000Z","updated":"2022-11-04T00:58:01.402Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-04-树莓派GPIO杂项驱动misc/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-04-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E6%9D%82%E9%A1%B9%E9%A9%B1%E5%8A%A8misc/","excerpt":"","text":"一、修改设备树1、查看io引脚信息 2、将io信息加入设备树123456789 pinCtrl: gpioCtrl&#123; compatible = &quot;raspberrypi,model-zero-w&quot;, &quot;brcm,bcm2835&quot;; label = &quot;2022&quot;; pinctrl-name =&quot;ledGpioCtrl&quot;; wodfa=&quot;null!&quot;; gpios = &lt;&amp;gpio 20 GPIO_ACTIVE_LOW &amp;gpio 21 GPIO_ACTIVE_LOW&gt;;&#125;; 3、编译并更新设备树1make dtbs 二、编写驱动与应用程序1、编写驱动程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;linux/kernel.h&gt;#include&lt;linux/module.h&gt;#include&lt;linux/miscdevice.h&gt;#include&lt;linux/fs.h&gt;#include&lt;linux/export.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_address.h&gt;#include &lt;linux/of_gpio.h&gt;#include &lt;linux/gpio.h&gt;#define LEDOFF 0 #define LEDON 1 struct gpioled_dev &#123; struct device_node *nd; int led_gpio; int led_gpio1;&#125;;struct gpioled_dev gpioled;static int misc_open(struct inode *node, struct file *fp)&#123; fp-&gt;private_data = &amp;gpioled; printk(KERN_DEBUG &quot;this dev is open\\n&quot;); return 0;&#125;static int misc_close(struct inode *node, struct file *fp)&#123; printk(KERN_DEBUG &quot;this dev is close\\n&quot;); return 0;&#125;ssize_t misc_read(struct file *fp, char __user *buf, size_t size, loff_t *loff)&#123; printk(KERN_DEBUG &quot;this dev is read\\n&quot;); return 0;&#125;ssize_t misc_write(struct file *fp, const char __user *buf, size_t size, loff_t *loff)&#123; int retvalue=0; unsigned char databuf[1]; unsigned char ledstat; struct gpioled_dev *dev = fp-&gt;private_data; printk(KERN_DEBUG &quot;this dev is write\\n&quot;); retvalue = copy_from_user(databuf, buf, size); if(retvalue &lt; 0) &#123; printk(KERN_DEBUG &quot;kernel write failed!\\r\\n&quot;); return -EFAULT; &#125; ledstat = databuf[0]; if(ledstat == LEDON) &#123; gpio_set_value(dev-&gt;led_gpio, 0); gpio_set_value(dev-&gt;led_gpio1, 1); printk(KERN_DEBUG &quot;driver: LED ON\\n&quot;); &#125; else if(ledstat == LEDOFF) &#123; gpio_set_value(dev-&gt;led_gpio, 1); gpio_set_value(dev-&gt;led_gpio1, 0); printk(KERN_DEBUG &quot;driver: LED OFF\\n&quot;); &#125; return 0;&#125;struct file_operations fops = &#123; .owner=THIS_MODULE, .open=misc_open, .read=misc_read, .write=misc_write, .release=misc_close,&#125;;struct miscdevice mymisc=&#123; .minor=MISC_DYNAMIC_MINOR, .name=&quot;mymisc&quot;, .fops=&amp;fops,&#125;;static int __init misc_init(void)&#123; int ret = 0; gpioled.nd = of_find_node_by_path(&quot;/gpioCtrl&quot;); if(gpioled.nd == NULL) &#123; printk(KERN_DEBUG &quot;gpioCtrl node not find!\\n&quot;); return -EINVAL; &#125; else &#123; printk(KERN_DEBUG &quot;gpioCtrl node find!\\n&quot;); &#125; gpioled.led_gpio = of_get_named_gpio(gpioled.nd, &quot;gpios&quot;, 0); gpioled.led_gpio1 = of_get_named_gpio(gpioled.nd, &quot;gpios&quot;, 1); if(gpioled.led_gpio &lt; 0) &#123; printk(KERN_DEBUG &quot;can&#x27;t get gpios&quot;); return -EINVAL; &#125; printk(KERN_DEBUG &quot;gpios num = %d\\n&quot;, gpioled.led_gpio); printk(KERN_DEBUG &quot;gpios num = %d\\n&quot;, gpioled.led_gpio1); ret = gpio_direction_output(gpioled.led_gpio, 1); gpio_direction_output(gpioled.led_gpio1, 1); if(ret &lt; 0) &#123; printk(KERN_DEBUG &quot;can&#x27;t set gpio!\\n&quot;); &#125; if(misc_register(&amp;mymisc)) &#123; printk(KERN_DEBUG &quot;this module is insmod fail\\n&quot;); return -1; &#125; printk(KERN_DEBUG &quot;this module is success\\n&quot;); return 0;&#125;static void __exit misc_exit(void)&#123; misc_deregister(&amp;mymisc); printk(&quot;this module is exit\\r\\n&quot;);&#125;module_init(misc_init);module_exit(misc_exit);MODULE_LICENSE(&quot;GPL&quot;); 2、编写应用程序123456789101112131415161718192021222324252627282930313233343536#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[])&#123; int fd , retvalue, j=0; char *filename = &quot;/dev/mymisc&quot;; fd = open(filename, O_RDWR); if(fd &lt; 0) &#123; printf(&quot;file %s open failed!\\n&quot;, filename); return -1; &#125; unsigned char on[1] = &#123;1&#125;, off[1] = &#123;0&#125;; int len = sizeof(unsigned char); while (1) &#123; write(fd, on, len); printf(&quot;led on!\\n&quot;); sleep(5); write(fd, off, len); printf(&quot;led off!\\n&quot;); sleep(5); &#125; close(fd); return 0;&#125; 3、编写Makefile123456789101112KDIR := /media/dataDisk/lufahai/raspberry/linux-5.10obj-m := misc.oappfile :=app.cbuild: kernel_moduleskernel_modules: make -C $(KDIR) M=$(PWD) modules ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- arm-linux-gnueabihf-gcc app.c -o appclean: rm -rf *.ko *.o *.mod.o *.mod.c *.symvers modul* .tmp_* .misc* *.mod 4、加载驱动并验证三、问题及解决1、app程序出现段错误issue： 在进行交叉编译后，直接把可执行文件放到树莓派上运行会出现段错误，应该和编译器版本有关。 solve： 将源文件放到树莓派上编译再执行。","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:03--树莓派GPIO驱动PWD呼吸灯","slug":"linuxDrive/Linux驱动-实践-03-树莓派GPIO驱动PWD呼吸灯","date":"2022-11-01T07:14:02.000Z","updated":"2022-11-03T01:41:22.907Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-03-树莓派GPIO驱动PWD呼吸灯/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-03-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E9%A9%B1%E5%8A%A8PWD%E5%91%BC%E5%90%B8%E7%81%AF/","excerpt":"","text":"一、树莓派上的PWM1、硬件资源树莓派扩展接口共有4个GPIO引出PWM，具体如下 2、启用pwm树莓派内核默认未启用pwm,也就是无法通过Linux内核获取到pwm资源，需要先启用： 123sudo vim /boot/config.txt 在最后一行加入： dtoverlay=pwmsudo reboot 重启后查看pwm确认已启用： 方法1： 1lsmod | grep pwm 方法2： 1ls /sys/class/pwm/ 3、pwm使用步骤1) 请求pwm0的资源 2) 设置脉冲周期 3) 设置占空比 4) 打开pwm0 4、指令控制pwm123456789cd /sys/class/pwm/pwmchip0/echo 0 &gt; export #load pwmecho 10000000 &gt; pwm0/period #set period as 10msecho 8000000 &gt; pwm0/duty_cycle #set duty as 8msecho 1 &gt; pwm0/enable #enable pwmecho 0 &gt; pwm0/enable #disable pwmecho 0 &gt; unexport #unload pwm 二、Linux驱动控制pwm1、pwm相关的API12345678910111213141516171819202122232425262728293031323334353637383940// PWM channel objectstruct pwm_device &#123; const char *label; // name of the PWM device unsigned long flags; // flags associated with the PWM device unsigned int hwpwm; // per-chip relative index of the PWM device unsigned int pwm; // global index of the PWM device struct pwm_chip *chip; // PWM chip providing this PWM device void *chip_data; // chip-private data associated with the PWM device struct pwm_args args; // PWM arguments struct pwm_state state; // curent PWM channel state&#125;;/*** 通过pwm通道号获取pwm通道对象* @pwm_id 通道号* @label pwm通道别名*/struct pwm_device *pwm_request(int pwm_id, const char *label);/*** 释放pwm通道对象*/void pwm_free(struct pwm_device *pwm);/*** 设置pwm通道的相关参数* @duty_ns 以纳秒为单位的占空比* @period_ns 以纳秒为单位的脉冲周期*/int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)/*** 打开pwm通道，开始输出脉冲*/int pwm_enable(struct pwm_device *pwm)/*** 关闭pwm通道，停止输出脉冲*/void pwm_disable(struct pwm_device *pwm) 2、驱动程序案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/miscdevice.h&gt;#include &lt;linux/pwm.h&gt;#define PWMLED_PERIOD 1000000 // 脉冲周期固定为1ms#define PWMLED_MAX_BRIGHTNESS 1000typedef enum &#123; PWMLED_CMD_SET_BRIGHTNESS = 0x1, PWMLED_CMD_GET_BRIGHTNESS,&#125; pwmled_cmd_t;static struct &#123; struct pwm_device* pwm; unsigned int brightness;&#125; pwmled;long pwmled_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) &#123;switch (cmd) &#123;case PWMLED_CMD_SET_BRIGHTNESS: // 所谓调节亮度，就是配置占空比，然后使能pwm0 pwmled.brightness = arg &lt; PWMLED_MAX_BRIGHTNESS ? arg : PWMLED_MAX_BRIGHTNESS; pwm_config(pwmled.pwm, pwmled.brightness * 1000, PWMLED_PERIOD); if (pwmled.brightness &gt; 0) &#123; pwm_enable(pwmled.pwm); &#125; else &#123; pwm_disable(pwmled.pwm); &#125;case PWMLED_CMD_GET_BRIGHTNESS: return pwmled.brightness;default: return -EINVAL;&#125;return pwmled.brightness;&#125;static struct file_operations fops = &#123; .owner = THIS_MODULE, .unlocked_ioctl = pwmled_ioctl,&#125;;static struct miscdevice dev = &#123; .minor = 0, .name = &quot;pwmled&quot;, .fops = &amp;fops, .nodename = &quot;pwmled&quot;, .mode = 0666,&#125;;int __init pwmled_init(void) &#123;// 请求PWM0通道struct pwm_device* pwm = pwm_request(0, &quot;pwm0&quot;);if (IS_ERR_OR_NULL(pwm)) &#123; printk(KERN_ERR &quot;failed to request pwm\\n&quot;); return PTR_ERR(pwm);&#125;pwmled.pwm = pwm;pwmled.brightness = 0;misc_register(&amp;dev); return 0;&#125;module_init(pwmled_init);void __exit pwmled_exit(void) &#123; misc_deregister(&amp;dev); // 停止并释放PWM0通道 pwm_disable(pwmled.pwm); pwm_free(pwmled.pwm);&#125;module_exit(pwmled_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); 3、测试程序12345678910111213141516171819202122232425int main(int argc, char* argv[]) &#123; int fd = open(&quot;/dev/pwmled&quot;, O_RDWR); int brightness = 0; char key = 0; while ((key = getchar()) != &#x27;q&#x27;) &#123; switch (key) &#123; case &#x27;=&#x27;: brightness += brightness &lt; PWMLED_MAX_BRIGHTNESS ? 10 : 0; break; case &#x27;-&#x27;: brightness -= brightness &gt; 0 ? 10 : 0; break; &#125; if (ioctl(fd, PWMLED_CMD_SET_BRIGHTNESS, brightness) &lt; 0) &#123; perror(&quot;ioctl&quot;); break; &#125; &#125; close(fd); return 0;&#125;","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:02--树莓派GPIO驱动中断","slug":"linuxDrive/Linux驱动-实践-02-树莓派GPIO驱动中断","date":"2022-11-01T07:13:09.000Z","updated":"2022-11-02T13:31:08.570Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-02-树莓派GPIO驱动中断/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-02-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E9%A9%B1%E5%8A%A8%E4%B8%AD%E6%96%AD/","excerpt":"","text":"一、实现IO引脚上升沿中断步骤1) 设置GPIO复用功能为输入模式 gpio_request() 2) 获取GPIO对应的中断号 gpio_to_irq() 3) 申请中断号、中断类型、绑定处理函数 request_irq() 4) 释放中断(卸载驱动时) free_irq() 二、GPIO操作相关的接口12345678910111213141516171819#include &lt;linux/gpio.h&gt;struct gpio &#123; unsigned gpio; // GPIO编号 unsigned long flags; // GPIO复用功能配置 const char *label; // GPIO标签名&#125;;// 单个GPIO资源申请/释放int gpio_request_one(unsigned gpio, unsigned long flags, const char *label);void gpio_free(unsigned gpio);// 多个GPIO资源申请/释放int gpio_request_array(const struct gpio *array, size_t num);void gpio_free_array(const struct gpio *array, size_t num);// GPIO状态读写int gpio_get_value(unsigned gpio);void gpio_set_value(unsigned gpio, int value); 三、按键防抖1、Linux驱动防抖和单片机防抖对比单片机实现按键防抖无非就是sleep 50ms，再确认是否真的按下。 但是Linux是一个多任务系统，永远不要试图在中断函数中睡眠，防抖只能放在Linux中断的底半部。 此外Linux驱动中慎用睡眠函数，除非你很清楚它不是忙等待。 Linux下防抖的逻辑应该是触发中断后，让出CPU资源50ms，然后再确认。 2、Linux底半部机制1) 软中断，是有内核软件模拟的一种中断机制，注意不要和ARM指令触发的中断混淆，后者本质上是硬中断 2) tasklet 基于软中断实现的中断调度机制，本质上还是中断，不允许在处理函数中sleep 3) 工作队列，类似于tasklet，区别在于工作队列底层基于线程，可以在处理函数中sleep 4) 线程IRQ，不用解释了，就是个线程。 3、工作队列API1234567891011121314151617181920#include &lt;linux/workqueue.h&gt;// 工作队列原型struct work_struct &#123; atomic_long_t data; struct list_head entry; work_func_t func;#ifdef CONFIG_LOCKDEP struct lockdep_map lockdep_map;#endif&#125;;// 工作队列回调函数原型typedef void (*work_func_t)(struct work_struct *work);// 初始化一个工作队列，绑定回调INIT_WORK(work, func);// 启动队列，之后会由内核完成调度schedule_work(&amp;my_wq); 4、定时器API1234567891011121314151617181920212223242526272829303132#include &lt;linux/timer.h&gt;// 全局变量// 记录上电后定时器中断次数，也就是开机时长，但不是微秒或纳秒的概念extern unsigned long volatile jiffies;// 表示CPU一秒钟有多少个定时器中断#define HZ 1000// 简单来说，如果要定义一个100ms的延时，相当于以下公式：// jiffies + (HZ/10)// 相当于以现在的jiffies做偏移，而1s的十分之一就是100ms// 定时器原型struct timer_list &#123; struct hlist_node entry; unsigned long expires; void (*function)(struct timer_list *); u32 flags;#ifdef CONFIG_LOCKDEP struct lockdep_map lockdep_map;#endif&#125;;// 向内核注册一个定时器#define timer_setup(timer, callback, flags)void add_timer(struct timer_list *timer);// 向内核删除一个定时器int del_timer(struct timer_list *timer);// 修改定时器的下次的jiffiesint mod_timer(struct timer_list *timer, unsigned long expires) 三、完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/miscdevice.h&gt; // 混杂设备相关结构#include &lt;linux/gpio.h&gt; // 各种gpio的数据结构及函数#include &lt;linux/interrupt.h&gt; // 内核中断相关接口#include &lt;linux/workqueue.h&gt;#include &lt;linux/timer.h&gt;// 定义按键的GPIO引脚static const struct gpio key = &#123; .gpio = 17, // 引脚号为BCM - 17 .flags = GPIOF_IN, // 功能复用为输入 .label = &quot;Key0&quot; // 标示为Key0&#125;;// 定义三色LED的GPIO引脚static const struct gpio leds[] = &#123; &#123; 2, GPIOF_OUT_INIT_HIGH, &quot;LED_RED&quot; &#125;, &#123; 3, GPIOF_OUT_INIT_HIGH, &quot;LED_GREEN&quot; &#125;, &#123; 4, GPIOF_OUT_INIT_HIGH, &quot;LED_BLUE&quot; &#125;,&#125;;static unsigned int keyirq = 0; // GPIO按键中断号static struct work_struct keywork; // 按键工作队列static struct timer_list timer; // 定时器作为中断延时// 按键中断“顶半部”处理函数，启用工作队列static irqreturn_t on_key_press(int irq, void* dev)&#123; schedule_work(&amp;keywork); return IRQ_HANDLED;&#125;// 按键中断“底半部”工作队列，启动一个50ms的延时定时器void start_timer(struct work_struct *work)&#123; mod_timer(&amp;timer, jiffies + (HZ/20));&#125;// 按键防抖定时器，及处理函数void on_delay_50ms(struct timer_list *timer)&#123; static int i = 0; if (gpio_get_value(key.gpio)) &#123; gpio_set_value(leds[i].gpio, 0); i = ++i == 3 ? 0 : i; gpio_set_value(leds[i].gpio, 1); &#125;&#125;static int __init gpiokey_init(void)&#123; int rc = 0; // 向内核申请GPIO if ((rc = gpio_request_one(key.gpio, key.flags, key.label)) &lt; 0 || (rc = gpio_request_array(leds, 3)) &lt; 0) &#123; printk(KERN_ERR &quot;ERROR%d: cannot request gpio\\n&quot;, rc); return rc; &#125; // 获取中断号 keyirq = gpio_to_irq(key.gpio); if (keyirq &lt; 0) &#123; printk(KERN_ERR &quot;can not get irq num.\\n&quot;); return -EFAULT; &#125; // 申请上升沿触发 if (request_irq(keyirq, on_key_press, IRQF_TRIGGER_RISING, &quot;onKeyPress&quot;, NULL) &lt; 0) &#123; printk(KERN_ERR &quot;can not request irq\\n&quot;); return -EFAULT; &#125; // 初始化按键中断底半部(工作队列) INIT_WORK(&amp;keywork, start_timer); // 初始化定时器 timer_setup(&amp;timer, on_delay_50ms, 0); add_timer(&amp;timer); return 0;&#125;module_init(gpiokey_init);static void __exit gpiokey_exit(void)&#123; free_irq(keyirq, NULL); gpio_free_array(leds, 3); gpio_free(key.gpio); del_timer(&amp;timer);&#125;module_exit(gpiokey_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;);","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:01--树莓派GPIO驱动LED","slug":"linuxDrive/Linux驱动-实践-01-树莓派GPIO驱动LED","date":"2022-11-01T07:12:47.000Z","updated":"2022-11-02T01:15:56.026Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-01-树莓派GPIO驱动LED/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-01-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E9%A9%B1%E5%8A%A8LED/","excerpt":"","text":"一、Linux中的地址Linux内核中，又三种地址:总线地址、物理地址和虚拟地址。 1) 总线地址： 一种计算机总线，CPU或者有DMA能力的单元中的内存组件或者物理地址在总线上有相对应的地址。 比如CPU的寄存器也会在总线上有单独的地址，但是总线地址不等于真实的寄存器。 又比如类似于IIC设备在IIC总线上的地址。总线的宽度决定了CPU能够访问内存的范围，32位的最大只能识别4G的内存； 1) 物理地址： 硬件中的实际地址或绝对地址:比如磁盘地址，比如51的寄存器，就是物理地址； 2) 虚拟地址： 操作系统运行在保护模式下所使用的地址，也叫逻辑地址，它是基于算法的，处于软件层面。 树莓派IO口的地址介绍是物理地址，挂载到Linux内核虚拟地址，编程使用的是虚拟地址。 二、树莓派GPIO寄存器地址1、GPFSELx IO口模式配置寄存器Address ：寄存器的基地址，也是寄存器的物理地址；Field Name:寄存器名；Descriptin: 寄存器说明； GPFSEL0 是 pin0 ~ pin9的配置寄存器，GPFSEL1是pin10 ~ pin19的配置寄存器，以此类推，GPFSEL5就是pin50 ~ pin53的配置寄存器。每个pin在寄存器上的位置及模式说明： 2、GPSET0,GPSET1 IO设置寄存器 GPSET0: pin0~pin31的设置寄存器，1位高电平，0为低电平，复位后为0： GPSET1: pin32~pin53的设置寄存器，1位高电平，0为低电平，复位后为0： 3、GPCLR0,GPCLR1 IO口清除寄存器 GPCLR0: pin0~pin31的清除寄存器，1位高电平，0为低电平，复位后为0； GPCLR1: pin31~pin54的清除寄存器，1位高电平，0为低电平，复位后为0； 有这三种寄存器，就操作树莓派的IO口输入高低电平了，但是不要忘了，操作树莓派的IO是操作虚拟地址，而不是上面的 0x7E20…，因此在编程之前一定要查看物理地址的映射 使用： 1cat /proc/iomem 树莓派3B对 0x7e200000的映射在虚拟地址 0x3f200000上。所以编程时，以上几种寄存器的基地址应该是：0x3f20000; 二、GPIO驱动LED案例1、驱动代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;asm/io.h&gt;#define BCM2837_GPIO_BASE 0x3F200000#define BCM2837_GPIO_FSEL0_OFFSET 0x0#define BCM2837_GPIO_SET0_OFFSET 0x1C#define BCM2837_GPIO_CLR0_OFFSET 0x28#define LED_RED_PIN 2#define LED_GREEN_PIN 3#define LED_BLUE_PIN 4static void* gpio = 0;static bool ledstate[3] = &#123;0&#125;;static struct &#123;const char* name; const bool pins[3];&#125; colors[] = &#123; &#123; &quot;white&quot;, &#123;1,1,1&#125; &#125;, &#123; &quot;black&quot;, &#123;0,0,0&#125; &#125;, &#123; &quot;red&quot;, &#123;1,0,0&#125; &#125;, &#123; &quot;green&quot;, &#123;0,1,0&#125; &#125;, &#123; &quot;blue&quot;, &#123;0,0,1&#125; &#125;, &#123; &quot;yellow&quot;, &#123;1,1,0&#125; &#125;, &#123; &quot;cyan&quot;, &#123;0,1,1&#125; &#125;, &#123; &quot;purple&quot;, &#123;1,0,1&#125; &#125;,&#125;;void gpioctl(int pin, bool stat)&#123; void* reg = gpio + (stat ? BCM2837_GPIO_SET0_OFFSET : BCM2837_GPIO_CLR0_OFFSET); ledstate[pin-2] = stat; iowrite32(1 &lt;&lt; pin, reg);&#125;ssize_t rgbled_read(struct file* filp, char __user* buf, size_t len, loff_t* off)&#123; int rc = 0; int i = 0; /* if file has been read, return */ if (*off &gt; 0) &#123; return 0; &#125; for (i = 0; i &lt; sizeof(colors) / sizeof(colors[0]); i++) &#123; const char* name = colors[i].name; const bool* pins = colors[i].pins; if (ledstate[0] == pins[0] &amp;&amp; ledstate[1] == pins[1] &amp;&amp; ledstate[2] == pins[2]) &#123; char color[32] = &#123;0&#125;; sprintf(color, &quot;%s\\n&quot;, name); *off = strlen(color); rc = copy_to_user(buf, color, *off); return rc &lt; 0 ? rc : *off; &#125; &#125; return -EFAULT;&#125;ssize_t rgbled_write(struct file* filp, const char __user* buf, size_t len, loff_t* off)&#123; char color[32] = &#123;0&#125;; int rc = 0; int i = 0; rc = copy_from_user(color, buf, len); if (rc &lt; 0) &#123; return rc; &#125; /* reset offset after read */ *off = 0; for (i = 0; i &lt; sizeof(colors) / sizeof(colors[0]); i++) &#123; const char* name = colors[i].name; const bool* pins = colors[i].pins; if (!strncasecmp(color, name, strlen(name))) &#123; gpioctl(LED_RED_PIN, pins[0]); gpioctl(LED_GREEN_PIN, pins[1]); gpioctl(LED_BLUE_PIN, pins[2]); return len; &#125; &#125; return -EINVAL;&#125;// 用户层通过ioctl函数单独控制灯的状态long rgbled_ioctl(struct file* filp, unsigned int cmd, unsigned long arg)&#123; if (cmd &gt;= 2 &amp;&amp; cmd &lt;= 4) &#123; gpioctl(cmd, arg); &#125; else &#123; return -ENODEV; &#125; return 0;&#125;static const struct file_operations fops = &#123; .owner = THIS_MODULE, .read = rgbled_read, .write = rgbled_write, .unlocked_ioctl = rgbled_ioctl,&#125;;static dev_t devno = 0;static struct cdev cdev;static int __init rgbled_init(void)&#123; // 映射GPIO物理内存到虚拟地址，并将其置为“输出模式” // 代码写得比较丑，解释以下： // 就是先把三个GPIO的“功能选择位”全部置000 // 然后再将其置为001 int val = ~((7 &lt;&lt; (LED_RED_PIN*3)) | (7 &lt;&lt; (LED_GREEN_PIN*3)) | (7 &lt;&lt; LED_BLUE_PIN*3)); gpio = ioremap(BCM2837_GPIO_BASE, 0xB0); val &amp;= ioread32(gpio + BCM2837_GPIO_FSEL0_OFFSET); val |= (1 &lt;&lt; (LED_RED_PIN*3)) | (1 &lt;&lt; (LED_GREEN_PIN*3)) | (1 &lt;&lt; (LED_BLUE_PIN*3)); iowrite32(val, gpio); if (alloc_chrdev_region(&amp;devno, 0, 1, &quot;rgbled&quot;)) &#123; printk(KERN_ERR&quot;failed to register kernel module!\\n&quot;); return -1; &#125; cdev_init(&amp;cdev, &amp;fops); cdev_add(&amp;cdev, devno, 1); printk(KERN_INFO&quot;rgbled device major &amp; minor is [%d:%d]\\n&quot;, MAJOR(devno), MINOR(devno)); return 0;&#125;module_init(rgbled_init);static void __exit rgbled_exit(void)&#123; // 取消gpio物理内存映射 iounmap(gpio); // 释放字符设备 cdev_del(&amp;cdev); unregister_chrdev_region(devno, 1); printk(KERN_INFO&quot;rgbled free\\n&quot;);&#125;module_exit(rgbled_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); 2、测试代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;int main(int argc, char* argv[])&#123; if (argc &lt; 3) &#123; fprintf(stderr, &quot;\\n./rgbled_test &lt;r|g|b&gt; &lt;0|1&gt;\\n\\n&quot;); exit(0); &#125; int fd = open(&quot;/dev/rgbled&quot;, O_RDWR); if (fd &lt; 0) &#123; perror(&quot;open device&quot;); return -1; &#125; switch (argv[1][0]) &#123; case &#x27;r&#x27;: case &#x27;R&#x27;: ioctl(fd, 2, atoi(argv[2])); break; case &#x27;g&#x27;: case &#x27;G&#x27;: ioctl(fd, 3, atoi(argv[2])); break; case &#x27;b&#x27;: case &#x27;B&#x27;: ioctl(fd, 4, atoi(argv[2])); break; &#125; close(fd); return 0;&#125;","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[理论]:15--Linux设备驱动调试","slug":"linuxDrive/Linux驱动-理论-15-Linux设备驱动调试","date":"2022-11-01T05:16:20.000Z","updated":"2022-11-01T07:41:19.234Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-15-Linux设备驱动调试/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-15-Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:14--ARM Linux设备树","slug":"linuxDrive/Linux驱动-理论-14-ARM-Linux设备树","date":"2022-11-01T05:15:59.000Z","updated":"2022-11-01T07:10:58.668Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-14-ARM-Linux设备树/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-14-ARM-Linux%E8%AE%BE%E5%A4%87%E6%A0%91/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:13--I2C SPI USB架构类比","slug":"linuxDrive/Linux驱动-理论-13-I2C-SPI-USB架构类比","date":"2022-11-01T05:15:31.000Z","updated":"2022-11-01T07:10:54.792Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-13-I2C-SPI-USB架构类比/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-13-I2C-SPI-USB%E6%9E%B6%E6%9E%84%E7%B1%BB%E6%AF%94/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:12--USB主机及设备与Gadget驱动","slug":"linuxDrive/Linux驱动-理论-12-USB主机及设备与Gadget驱动","date":"2022-11-01T05:14:51.000Z","updated":"2022-11-01T07:10:51.660Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-12-USB主机及设备与Gadget驱动/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-12-USB%E4%B8%BB%E6%9C%BA%E5%8F%8A%E8%AE%BE%E5%A4%87%E4%B8%8EGadget%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:11--I2C核心及总线与设备驱动","slug":"linuxDrive/Linux驱动-理论-11-I2C核心及总线与设备驱动","date":"2022-11-01T05:14:15.000Z","updated":"2022-11-01T07:10:48.396Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-11-I2C核心及总线与设备驱动/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-11-I2C%E6%A0%B8%E5%BF%83%E5%8F%8A%E6%80%BB%E7%BA%BF%E4%B8%8E%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:10--网络设备","slug":"linuxDrive/Linux驱动-理论-10-网络设备","date":"2022-11-01T05:13:24.000Z","updated":"2022-11-01T07:10:45.564Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-10-网络设备/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-10-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:09--块设备驱动","slug":"linuxDrive/Linux驱动-理论-09-块设备驱动","date":"2022-11-01T05:13:10.000Z","updated":"2022-11-01T07:10:42.460Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-09-块设备驱动/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-09-%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:08--设备驱动软件架构","slug":"linuxDrive/Linux驱动-理论-08-设备驱动软件架构","date":"2022-11-01T05:12:54.000Z","updated":"2022-11-01T07:10:38.952Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-08-设备驱动软件架构/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-08-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:07--内存与IO访问","slug":"linuxDrive/Linux驱动-理论-07-内存与IO访问","date":"2022-11-01T05:12:27.000Z","updated":"2022-11-01T07:10:35.764Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-07-内存与IO访问/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-07-%E5%86%85%E5%AD%98%E4%B8%8EIO%E8%AE%BF%E9%97%AE/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:06--时钟","slug":"linuxDrive/Linux驱动-理论-06-时钟","date":"2022-11-01T05:12:18.000Z","updated":"2022-11-01T07:37:20.934Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-06-时钟/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-06-%E6%97%B6%E9%92%9F/","excerpt":"","text":"一、内核定时器编程1、初始化定时器4.14之前的内核版本使用以下方式初始化： 12init_timer(&amp;second_devp-&gt;s_timer);second_devp-&gt;s_timer.function = &amp;second_timer_handler; 4.14之后的内核版本使用以下方式初始化： 1timer_setup(&amp;second_devp-&gt;s_timer, second_timer_handler, 0); 2、增加定时器1void add_timer(struct timer_list *list); 用于注册内核定时器，将定时器加入到内核动态定时器链表中。 3、删除定时器1void del_timer(struct timer_list *list); 用于删除定时器，其中del_timer_sync()是上述函数的同步版，在删除一个定时器时需要等待其被处理完， 因此该函数的调用不能发生在中断上下文中。 4、修改定时器的expire1int mod_timer(struct timer_list *list, unsigned long expires); 用于修改定时器的到期时间，在新的被传入的expire到来后才会执行定时器函数。 5、内核定时器模板12345678910111213141516171819202122232425262728293031323334struct xxx_dev &#123; struct cdev cdev; ... struct timer_list s_timer;&#125;;static int xxx_fun1(...)&#123; struct xxx_dev *dev = file-&gt;private_data; /* 初始化定时器 */ timer_setup(&amp;second_devp-&gt;s_timer, second_timer_handler, 0); second_devp-&gt;s_timer.expires = jiffies + HZ; /* 注册定时器 */ add_timer(&amp;second_devp-&gt;s_timer); ....&#125;static int xxx_fun2(...)&#123; .... /* 删除定时器 */ del_timer(&amp;second_devp-&gt;s_timer); ....&#125;static void xxx_timer_handler(struct timer_list *timer)&#123; /* 调度定时器再次执行 */ mod_timer(&amp;second_devp-&gt;s_timer, jiffies + HZ); atomic_inc(&amp;second_devp-&gt;counter);&#125; 二、实例：秒字符设备1、驱动层代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/mm.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/timer.h&gt;#include &lt;linux/uaccess.h&gt;#define SECOND_MAJOR 234static int second_major = SECOND_MAJOR;module_param(second_major, int, S_IRUGO);struct second_dev &#123; struct cdev cdev; atomic_t counter; struct timer_list s_timer;&#125;;static struct second_dev *second_devp;static void second_timer_handler(struct timer_list *timer)&#123; printk(KERN_INFO &quot;current jiffies is %ld\\n&quot;, jiffies); mod_timer(&amp;second_devp-&gt;s_timer, jiffies + HZ); atomic_inc(&amp;second_devp-&gt;counter);&#125;static int second_open(struct inode *inode, struct file *filp)&#123; timer_setup(&amp;second_devp-&gt;s_timer, second_timer_handler, 0); second_devp-&gt;s_timer.expires = jiffies + HZ; add_timer(&amp;second_devp-&gt;s_timer); atomic_set(&amp;second_devp-&gt;counter, 0); return 0;&#125;static int second_release(struct inode *inode, struct file *filp)&#123; del_timer(&amp;second_devp-&gt;s_timer); return 0;&#125;static ssize_t second_read(struct file *filp, char __user * buf, size_t count, loff_t * ppos)&#123; int counter; counter = atomic_read(&amp;second_devp-&gt;counter); if (put_user(counter, (int *)buf)) return -EFAULT; else return sizeof(unsigned int);&#125;static const struct file_operations second_fops = &#123; .owner = THIS_MODULE, .open = second_open, .release = second_release, .read = second_read,&#125;;static void second_setup_cdev(struct second_dev *dev, int index)&#123; int err, devno = MKDEV(second_major, index); cdev_init(&amp;dev-&gt;cdev, &amp;second_fops); dev-&gt;cdev.owner = THIS_MODULE; err = cdev_add(&amp;dev-&gt;cdev, devno, 1); if (err) printk(KERN_ERR &quot;Failed to add second device\\n&quot;);&#125;static int __init second_init(void)&#123; int ret; dev_t devno = MKDEV(second_major, 0); if (second_major) ret = register_chrdev_region(devno, 1, &quot;second&quot;); else &#123; ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;second&quot;); second_major = MAJOR(devno); &#125; if (ret &lt; 0) return ret; second_devp = kzalloc(sizeof(*second_devp), GFP_KERNEL); if (!second_devp) &#123; ret = -ENOMEM; goto fail_malloc; &#125; second_setup_cdev(second_devp, 0); return 0;fail_malloc: unregister_chrdev_region(devno, 1); return ret;&#125;module_init(second_init);static void __exit second_exit(void)&#123; cdev_del(&amp;second_devp-&gt;cdev); kfree(second_devp); unregister_chrdev_region(MKDEV(second_major, 0), 1);&#125;module_exit(second_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); 2、应用层测试代码12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;sys/stat.h&gt;int main()&#123; int fd; unsigned int counter = 0; unsigned int old_counter = 0; fd = open(&quot;/dev/second&quot;, O_RDONLY); if (fd &lt; 0) &#123; printf(&quot;Device open failure\\n&quot;); return -1; &#125; while (1) &#123; read(fd, &amp;counter, sizeof(unsigned int)); if(counter!= old_counter) &#123; printf(&quot;seconds after open /dev/second :%d\\n&quot;, counter); old_counter = counter; &#125; msleep(200); &#125; return 0;&#125;","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:05--中断处理","slug":"linuxDrive/Linux驱动-理论-05-中断处理","date":"2022-11-01T05:11:40.000Z","updated":"2022-11-01T07:10:28.276Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-05-中断处理/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-05-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:04--异步通知与异步IO","slug":"linuxDrive/Linux驱动-理论-04-异步通知与异步IO","date":"2022-11-01T05:11:11.000Z","updated":"2022-11-01T07:10:25.416Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-04-异步通知与异步IO/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-04-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5%E4%B8%8E%E5%BC%82%E6%AD%A5IO/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:03--阻塞与非阻塞IO","slug":"linuxDrive/Linux驱动-理论-03-阻塞与非阻塞IO","date":"2022-11-01T05:10:52.000Z","updated":"2022-11-01T07:40:56.399Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-03-阻塞与非阻塞IO/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-03-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EIO/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:02--驱动并发控制","slug":"linuxDrive/Linux驱动-理论-02-驱动并发控制","date":"2022-11-01T05:10:30.000Z","updated":"2022-11-01T08:01:11.585Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-02-驱动并发控制/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-02-%E9%A9%B1%E5%8A%A8%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/","excerpt":"","text":"一、驱动的并发控制1、原因1) 多进程、多线程程序执行时会出现并发与竞态的情况。 2) 程序在编译和执行阶段可能会出现“编译乱序”和“执行乱序”的问题 2、解决方法1) 中断屏蔽 2) 原子操作 3) 自旋锁 4) 信号量 5) 互斥体 6) 完成量 3、加入并发控制的字符设备驱动程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/uaccess.h&gt;#define GLOBALMEM_SIZE 0x1000#define MEM_CLEAR 0x1#define GLOBALMEM_MAJOR 230static int globalmem_major = GLOBALMEM_MAJOR;module_param(globalmem_major, int, S_IRUGO);struct globalmem_dev &#123; struct cdev cdev; unsigned char mem[GLOBALMEM_SIZE]; struct mutex mutex;&#125;;struct globalmem_dev *globalmem_devp;static int globalmem_open(struct inode *inode, struct file *filp)&#123; filp-&gt;private_data = globalmem_devp; return 0;&#125;int globalmem_release(struct inode *inode, struct file *filp)&#123; return 0;&#125;static long globalmem_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; struct globalmem_dev *dev = filp-&gt;private_data; switch (cmd) &#123; case MEM_CLEAR: mutex_lock(&amp;dev-&gt;mutex); memset(dev-&gt;mem, 0, GLOBALMEM_SIZE); mutex_unlock(&amp;dev-&gt;mutex); printk(KERN_INFO &quot;globalmem is set to zero\\n&quot;); break; default: return -EINVAL; &#125; return 0;&#125;static ssize_t globalmem_read(struct file *filp, char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; mutex_lock(&amp;dev-&gt;mutex); if (copy_to_user(buf, dev-&gt;mem + p, count)) &#123; ret = -EFAULT; &#125; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;read %u bytes(s) from %lu\\n&quot;, count, p); &#125; mutex_unlock(&amp;dev-&gt;mutex); return ret;&#125;static ssize_t globalmem_write(struct file *filp, const char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; mutex_lock(&amp;dev-&gt;mutex); if (copy_from_user(dev-&gt;mem + p, buf, count)) ret = -EFAULT; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;written %u bytes(s) from %lu\\n&quot;, count, p); &#125; mutex_unlock(&amp;dev-&gt;mutex); return ret;&#125;static loff_t globalmem_llseek(struct file *filp, loff_t offset, int orig)&#123; loff_t ret = 0; switch (orig) &#123; case 0: if (offset &lt; 0) &#123; ret = -EINVAL; break; &#125; if ((unsigned int)offset &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos = (unsigned int)offset; ret = filp-&gt;f_pos; break; case 1: if ((filp-&gt;f_pos + offset) &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; if ((filp-&gt;f_pos + offset) &lt; 0) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos += offset; ret = filp-&gt;f_pos; break; default: ret = - EINVAL; break; &#125; return ret;&#125;static const struct file_operations globalmem_fops = &#123; .owner = THIS_MODULE, .llseek = globalmem_llseek, .read = globalmem_read, .write = globalmem_write, .unlocked_ioctl = globalmem_ioctl, .open = globalmem_open, .release = globalmem_release,&#125;;static void globalmem_setup_cdev(struct globalmem_dev *dev, int index)&#123; int err, devno = MKDEV(globalmem_major, index); cdev_init(&amp;dev-&gt;cdev, &amp;globalmem_fops); dev-&gt;cdev.owner = THIS_MODULE; err = cdev_add(&amp;dev-&gt;cdev, devno, 1); if (err) printk(KERN_NOTICE &quot;Error %d adding globalmem%d&quot;, err, index);&#125;static int __init globalmem_init(void)&#123; int ret; dev_t devno = MKDEV(globalmem_major, 0); if (globalmem_major) ret = register_chrdev_region(devno, 1, &quot;globalmem&quot;); else &#123; ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;globalmem&quot;); globalmem_major = MAJOR(devno); &#125; if (ret &lt; 0) return ret; globalmem_devp = kzalloc(sizeof(struct globalmem_dev), GFP_KERNEL); if (!globalmem_devp) &#123; ret = -ENOMEM; goto fail_malloc; &#125; globalmem_setup_cdev(globalmem_devp, 0); mutex_init(&amp;globalmem_devp-&gt;mutex); return 0;fail_malloc: unregister_chrdev_region(devno, 1); return ret;&#125;module_init(globalmem_init);static void __exit globalmem_exit(void)&#123; cdev_del(&amp;globalmem_devp-&gt;cdev); kfree(globalmem_devp); unregister_chrdev_region(MKDEV(globalmem_major, 0), 1);&#125;module_exit(globalmem_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;);","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:01--字符设备驱动","slug":"linuxDrive/Linux驱动-理论-01-字符设备驱动","date":"2022-11-01T05:10:04.000Z","updated":"2022-11-01T07:40:37.964Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-01-字符设备驱动/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-01-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"一、字符设备驱动的组成1、模块加载与卸载函数加载函数： 实现设备号的申请和cdev的注册。 卸载函数： 实现设备号的释放cdev的注销。 12345678910111213141516171819202122232425262728293031struct xxx_dev_t &#123; struct cdev cdev;&#125; xxx_dev;/* 加载函数 */static int __init xxx_init(void) &#123; ... cdev_init(&amp;xxx_dev.cdev, &amp;xxx_fops); xxx_dev.cdev.owner = THIS_MODULE; /* 获取字符设备号 */ if (xxx_major) &#123; register_chrdev_region(xxx_dev_no, 1, DEV_NAME); &#125; else &#123; alloc_chrdev_region(&amp;xxx_dev_no, 0, 1, DEV_NAME); &#125; ret = cdev_add(&amp;xxx_dev.cdev, &amp;xxx_dev_no, 1); ...&#125;/* 卸载函数 */static void __exit xxx_exit(void) &#123; unregister_chrdev_region(xxx_dev_no, 1); cdev_del(&amp;xxx_dev.cdev); ...&#125; 2、file_operations结构体中的成员函数1234567891011121314151617181920212223242526272829303132333435/* device read */ssize_t xxx_read(struct file *fp, char __user *buf, size_t size, loff_t *loff)&#123; ... copy_to_user(buf, ..., ...); ...&#125;/* device write */ssize_t xxx_write(struct file *fp, char __user *buf, size_t size, loff_t *loff)&#123; ... copy_from_user(buf, ..., ...); ...&#125;/* ioctrl */long xxx_ioctrl(struct file *fp, unsigned int cmd, unsigned long arg)&#123; ... switch(cmd) &#123; case xxx_CMD1: .... break; case xxx_CMD2: .... break; default: return -ENOTTY; break; &#125; return 0;&#125; 3、字符设备驱动的结构图 二、字符设备驱动实例1、编写字符设备驱动程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/uaccess.h&gt;#define GLOBALMEM_SIZE 0x1000#define MEM_CLEAR 0x1#define GLOBALMEM_MAJOR 230static int globalmem_major = GLOBALMEM_MAJOR;module_param(globalmem_major, int, S_IRUGO);struct globalmem_dev &#123; struct cdev cdev; unsigned char mem[GLOBALMEM_SIZE];&#125;;struct globalmem_dev *globalmem_devp;static int globalmem_open(struct inode *inode, struct file *filp)&#123; filp-&gt;private_data = globalmem_devp; return 0;&#125;static int globalmem_release(struct inode *inode, struct file *filp)&#123; return 0;&#125;static long globalmem_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; struct globalmem_dev *dev = filp-&gt;private_data; switch (cmd) &#123; case MEM_CLEAR: memset(dev-&gt;mem, 0, GLOBALMEM_SIZE); printk(KERN_INFO &quot;globalmem is set to zero\\n&quot;); break; default: return -EINVAL; &#125; return 0;&#125;static ssize_t globalmem_read(struct file *filp, char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; if (copy_to_user(buf, dev-&gt;mem + p, count)) &#123; ret = -EFAULT; &#125; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;read %u bytes(s) from %lu\\n&quot;, count, p); &#125; return ret;&#125;static ssize_t globalmem_write(struct file *filp, const char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; if (copy_from_user(dev-&gt;mem + p, buf, count)) ret = -EFAULT; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;written %u bytes(s) from %lu\\n&quot;, count, p); &#125; return ret;&#125;static loff_t globalmem_llseek(struct file *filp, loff_t offset, int orig)&#123; loff_t ret = 0; switch (orig) &#123; case 0: if (offset &lt; 0) &#123; ret = -EINVAL; break; &#125; if ((unsigned int)offset &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos = (unsigned int)offset; ret = filp-&gt;f_pos; break; case 1: if ((filp-&gt;f_pos + offset) &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; if ((filp-&gt;f_pos + offset) &lt; 0) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos += offset; ret = filp-&gt;f_pos; break; default: ret = -EINVAL; break; &#125; return ret;&#125;static const struct file_operations globalmem_fops = &#123; .owner = THIS_MODULE, .llseek = globalmem_llseek, .read = globalmem_read, .write = globalmem_write, .unlocked_ioctl = globalmem_ioctl, .open = globalmem_open, .release = globalmem_release,&#125;;static void globalmem_setup_cdev(struct globalmem_dev *dev, int index)&#123; int err, devno = MKDEV(globalmem_major, index); cdev_init(&amp;dev-&gt;cdev, &amp;globalmem_fops); dev-&gt;cdev.owner = THIS_MODULE; err = cdev_add(&amp;dev-&gt;cdev, devno, 1); if (err) printk(KERN_NOTICE &quot;Error %d adding globalmem%d&quot;, err, index);&#125;static int __init globalmem_init(void)&#123; int ret; dev_t devno = MKDEV(globalmem_major, 0); if (globalmem_major) ret = register_chrdev_region(devno, 1, &quot;globalmem&quot;); else &#123; ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;globalmem&quot;); globalmem_major = MAJOR(devno); &#125; if (ret &lt; 0) return ret; globalmem_devp = kzalloc(sizeof(struct globalmem_dev), GFP_KERNEL); if (!globalmem_devp) &#123; ret = -ENOMEM; goto fail_malloc; &#125; globalmem_setup_cdev(globalmem_devp, 0); return 0;fail_malloc: unregister_chrdev_region(devno, 1); return ret;&#125;module_init(globalmem_init);static void __exit globalmem_exit(void)&#123; cdev_del(&amp;globalmem_devp-&gt;cdev); kfree(globalmem_devp); unregister_chrdev_region(MKDEV(globalmem_major, 0), 1);&#125;module_exit(globalmem_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); 2、在用户空间中认证1) 加载程序 1sudo insmod globalmem.ko 2) 创建节点 1sudo mknod /dev/globalmem c 230 0 3) 写入字符 1echo &quot;hello Linux drive world&quot; &gt; /dev/globalmem 4) 查看字符 1cat /dev/globalmem 3、附录1、多个驱动字符设备驱动程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/uaccess.h&gt;#define GLOBALMEM_SIZE 0x1000#define MEM_CLEAR 0x1#define GLOBALMEM_MAJOR 230#define DEVICE_NUM 10static int globalmem_major = GLOBALMEM_MAJOR;module_param(globalmem_major, int, S_IRUGO);struct globalmem_dev &#123; struct cdev cdev; unsigned char mem[GLOBALMEM_SIZE];&#125;;struct globalmem_dev *globalmem_devp;static int globalmem_open(struct inode *inode, struct file *filp)&#123; struct globalmem_dev *dev = container_of(inode-&gt;i_cdev, struct globalmem_dev, cdev); filp-&gt;private_data = dev; return 0;&#125;static int globalmem_release(struct inode *inode, struct file *filp)&#123; return 0;&#125;static long globalmem_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; struct globalmem_dev *dev = filp-&gt;private_data; switch (cmd) &#123; case MEM_CLEAR: memset(dev-&gt;mem, 0, GLOBALMEM_SIZE); printk(KERN_INFO &quot;globalmem is set to zero\\n&quot;); break; default: return -EINVAL; &#125; return 0;&#125;static ssize_t globalmem_read(struct file *filp, char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; if (copy_to_user(buf, dev-&gt;mem + p, count)) &#123; ret = -EFAULT; &#125; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;read %u bytes(s) from %lu\\n&quot;, count, p); &#125; return ret;&#125;static ssize_t globalmem_write(struct file *filp, const char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; if (copy_from_user(dev-&gt;mem + p, buf, count)) ret = -EFAULT; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;written %u bytes(s) from %lu\\n&quot;, count, p); &#125; return ret;&#125;static loff_t globalmem_llseek(struct file *filp, loff_t offset, int orig)&#123; loff_t ret = 0; switch (orig) &#123; case 0: if (offset &lt; 0) &#123; ret = -EINVAL; break; &#125; if ((unsigned int)offset &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos = (unsigned int)offset; ret = filp-&gt;f_pos; break; case 1: if ((filp-&gt;f_pos + offset) &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; if ((filp-&gt;f_pos + offset) &lt; 0) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos += offset; ret = filp-&gt;f_pos; break; default: ret = -EINVAL; break; &#125; return ret;&#125;static const struct file_operations globalmem_fops = &#123; .owner = THIS_MODULE, .llseek = globalmem_llseek, .read = globalmem_read, .write = globalmem_write, .unlocked_ioctl = globalmem_ioctl, .open = globalmem_open, .release = globalmem_release,&#125;;static void globalmem_setup_cdev(struct globalmem_dev *dev, int index)&#123; int err, devno = MKDEV(globalmem_major, index); cdev_init(&amp;dev-&gt;cdev, &amp;globalmem_fops); dev-&gt;cdev.owner = THIS_MODULE; err = cdev_add(&amp;dev-&gt;cdev, devno, 1); if (err) printk(KERN_NOTICE &quot;Error %d adding globalmem%d&quot;, err, index);&#125;static int __init globalmem_init(void)&#123; int ret; int i; dev_t devno = MKDEV(globalmem_major, 0); if (globalmem_major) ret = register_chrdev_region(devno, DEVICE_NUM, &quot;globalmem&quot;); else &#123; ret = alloc_chrdev_region(&amp;devno, 0, DEVICE_NUM, &quot;globalmem&quot;); globalmem_major = MAJOR(devno); &#125; if (ret &lt; 0) return ret; globalmem_devp = kzalloc(sizeof(struct globalmem_dev) * DEVICE_NUM, GFP_KERNEL); if (!globalmem_devp) &#123; ret = -ENOMEM; goto fail_malloc; &#125; for (i = 0; i &lt; DEVICE_NUM; i++) globalmem_setup_cdev(globalmem_devp + i, i); return 0;fail_malloc: unregister_chrdev_region(devno, DEVICE_NUM); return ret;&#125;module_init(globalmem_init);static void __exit globalmem_exit(void)&#123; int i; for (i = 0; i &lt; DEVICE_NUM; i++) cdev_del(&amp;(globalmem_devp + i)-&gt;cdev); kfree(globalmem_devp); unregister_chrdev_region(MKDEV(globalmem_major, 0), DEVICE_NUM);&#125;module_exit(globalmem_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;);","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"ubuntu18安装ch340驱动","slug":"ubuntu/ubuntu18安装ch340驱动","date":"2022-10-26T12:49:31.000Z","updated":"2022-11-22T06:45:32.617Z","comments":true,"path":"2022/10/26/ubuntu/ubuntu18安装ch340驱动/","link":"","permalink":"http://example.com/2022/10/26/ubuntu/ubuntu18%E5%AE%89%E8%A3%85ch340%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"一、安装过程1、下载驱动程序先到这个网站下驱动源文件包 https://www.wch.cn/download/CH341SER_LINUX_ZIP.html 2、替换源文件根据内核的不同版本，替换掉里边的源文件 https://elixir.bootlin.com/linux/v5.4.42/source/drivers/usb/serial/ch341.c 3、编译及安装根据readme内容的提示，make &amp;&amp; sudo make load 4、开机自动加载将驱动文件复制到 /lib/modules/5.4.0-42-generic/kernel/drivers/usb/serial/ 然后运行 sudo depmod -a 二、多个USB串口绑定1、查看当前USB串口信息123456789101112131415161718192021222324252627282930313233343536lufahai@station:/dev$ udevadm info /dev/ttyUSB0P: /devices/pci0000:00/0000:00:14.0/usb1/1-5/1-5:1.0/ttyUSB0/tty/ttyUSB0N: ttyUSB0L: 0S: serial/by-id/usb-1a86_USB_Serial-if00-port0S: serial/by-path/pci-0000:00:14.0-usb-0:5:1.0-port0E: DEVPATH=/devices/pci0000:00/0000:00:14.0/usb1/1-5/1-5:1.0/ttyUSB0/tty/ttyUSB0E: DEVNAME=/dev/ttyUSB0E: MAJOR=188E: MINOR=0E: SUBSYSTEM=ttyE: USEC_INITIALIZED=529937465118E: ID_BUS=usbE: ID_VENDOR_ID=1a86E: ID_MODEL_ID=7523E: ID_PCI_CLASS_FROM_DATABASE=Serial bus controllerE: ID_PCI_SUBCLASS_FROM_DATABASE=USB controllerE: ID_PCI_INTERFACE_FROM_DATABASE=XHCIE: ID_VENDOR_FROM_DATABASE=QinHeng ElectronicsE: ID_VENDOR=1a86E: ID_VENDOR_ENC=1a86E: ID_MODEL=USB_SerialE: ID_MODEL_ENC=USB\\x20SerialE: ID_REVISION=8033E: ID_SERIAL=1a86_USB_SerialE: ID_TYPE=genericE: ID_USB_INTERFACES=:ff0102:E: ID_USB_INTERFACE_NUM=00E: ID_USB_DRIVER=ch341E: ID_USB_CLASS_FROM_DATABASE=Vendor Specific ClassE: ID_MODEL_FROM_DATABASE=HL-340 USB-Serial adapterE: ID_PATH=pci-0000:00:14.0-usb-0:5:1.0E: ID_PATH_TAG=pci-0000_00_14_0-usb-0_5_1_0E: ID_MM_CANDIDATE=1E: DEVLINKS=/dev/serial/by-id/usb-1a86_USB_Serial-if00-port0 /dev/serial/by-path/pci-0000:00:14.0-usb-0:5:1.0-port0E: TAGS=:systemd: 第一行，串口序列号是 1-5:1.0 2、创建udev配置文件1sudo gedit /etc/udev/rules.d/myserial.rules 增加以下内容： 1ACTION==&quot;add&quot;,KERNELS==&quot;1-5:1.0&quot;,SUBSYSTEMS==&quot;usb&quot;,MODE:=&quot;0777&quot;,SYMLINK+=&quot;stm32Serial&quot; 3、保存与更新先拔出USB串口，然后执行下面指令： 123sudo service udev reloadsudo service udev restart","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"ubuntu18安装ROS1和ROS2","slug":"ubuntu/ubuntu18安装ROS1和ROS2","date":"2022-10-19T11:09:38.000Z","updated":"2022-10-27T15:13:14.361Z","comments":true,"path":"2022/10/19/ubuntu/ubuntu18安装ROS1和ROS2/","link":"","permalink":"http://example.com/2022/10/19/ubuntu/ubuntu18%E5%AE%89%E8%A3%85ROS1%E5%92%8CROS2/","excerpt":"","text":"一、安装ROS11、添加源1sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; 2、设置公钥1sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 3、安装1) 安装 12sudo apt updatesudo apt install ros-melodic-desktop-full 4、安装必要组件1sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential 5、初始化1sudo rosdep init 如果遇到问题，那就在 /etc/hosts后面添加 123456789101112131415161718192021222324252627282930313233343536373839199.232.28.133 raw.githubusercontent.com192.30.253.118 gist.github.com185.199.110.153 github.io151.101.113.194 github.global.ssl.fastly.net52.216.227.168 github-cloud.s3.amazonaws.com52.74.223.119 github.com199.232.28.133 avatars1.githubusercontent.com199.232.28.133 avatars2.githubusercontent.com199.232.28.133 avatars0.githubusercontent.com199.232.28.133 avatars3.githubusercontent.com199.232.28.133 user-images.githubusercontent.com199.232.28.133 avatars.githubusercontent.com199.232.28.133 github.map.fastly.net199.232.28.133 avatars7.githubusercontent.com54.239.31.69 aws.amazon.com54.239.30.25 console.aws.amazon.com54.239.96.90 ap-northeast-1.console.aws.amazon.com54.240.226.81 ap-southeast-1.console.aws.amazon.com54.240.193.125 ap-southeast-2.console.aws.amazon.com54.239.54.102 eu-central-1.console.aws.amazon.com177.72.244.194 sa-east-1.console.aws.amazon.com176.32.114.59 eu-west-1.console.aws.amazon.com54.239.31.128 us-west-1.console.aws.amazon.com54.240.254.230 us-west-2.console.aws.amazon.com54.239.38.102 s3-console-us-standard.console.aws.amazon.com54.231.49.3 s3.amazonaws.com52.219.0.4 s3-ap-northeast-1.amazonaws.com54.231.242.170 s3-ap-southeast-1.amazonaws.com54.231.251.21 s3-ap-southeast-2.amazonaws.com54.231.193.37 s3-eu-central-1.amazonaws.com52.218.16.140 s3-eu-west-1.amazonaws.com52.92.72.2 s3-sa-east-1.amazonaws.com54.231.236.6 s3-us-west-1.amazonaws.com54.231.168.160 s3-us-west-2.amazonaws.com52.216.80.48 github-cloud.s3.amazonaws.com54.231.40.3 github-com.s3.amazonaws.com52.216.20.171 github-production-release-asset-2e65be.s3.amazonaws.com52.216.228.168 github-production-user-asset-6210df.s3.amazonaws.com 接着修改/etc/resolv.conf 在其后增加 12nameserver 8.8.8.8nameserver 8.8.4.4 再次执行 sudo rosdep init 5、update根据提示执行 1rosdep update 可能会显示报错 read operation timed out，原因是raw.githubusercontent.com网站被墙掉了，解决如下： 1sudo cp -r ../ros_github/ /etc/ros/ 1) 修改路径Python配置路径 1sudo gedit /usr/lib/python2.7/dist-packages/rosdistro/__init__.py 注释第68行路径代码，然后改为 file:///etc/ros/ros_github/index-v4.yaml，如下图： 1) 修改20-default路径 改为下面的路径： 12345678sudo gedit /etc/ros/rosdep/sources.list.d/20-default.listyaml file:///etc/ros/ros_github/osx-homebrew.yaml osx#genericyaml file:///etc/ros/ros_github/base.yamlyaml file:///etc/ros/ros_github/python.yamlyaml file:///etc/ros/ros_github/ruby.yamlgbpdistro file:///etc/ros/ros_github/fuerte.yaml fuerte 再次执行 rosdep update 三、安装ROS21、设置编码123sudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8export LANG=en_US.UTF-8 2、更新软件源1234sudo apt update &amp;&amp; sudo apt install curl gnupg2 lsb-releasecurl http://repo.ros2.org/repos.key | sudo apt-key add -sudo sh -c &#x27;echo &quot;deb [arch=amd64,arm64] http://packages.ros.org/ros2/ubuntu `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros2-latest.list&#x27; 3、安装1sudo apt install ros-dashing-desktop 4、安装其他工具1234567sudo apt install python3-argcompletesource /opt/ros/dashing/setup.bashsudo apt updatesudo apt install ros-dashing-ros1-bridge 3、配置ROS1和ROS2共存界面1234567891011121314#source /opt/ros/melodic/setup.bash#source /opt/ros/dashing/setup.bash# ROS 1.0 melodic or ROS 2.0 Dashingecho Hello alvin! ROS 1.0 or ROS 2.0? 1=Melodic 2=Dashing read ROSif (($ROS==1));thensource /opt/ros/melodic/setup.bashecho &quot;Melodic&quot;elif (($ROS==2));thensource /opt/ros/dashing/setup.bashecho &quot;Dashing&quot;elseecho &quot;Non-ROS&quot;fi","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"设计模式:23--访问者模式","slug":"designPatter/设计模式-23-访问者模式","date":"2022-10-15T14:21:29.000Z","updated":"2022-10-21T05:56:56.309Z","comments":true,"path":"2022/10/15/designPatter/设计模式-23-访问者模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-23-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。 2、应用场景3、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:22--模板方法模式","slug":"designPatter/设计模式-22-模板方法模式","date":"2022-10-15T14:21:07.000Z","updated":"2022-10-21T05:53:20.860Z","comments":true,"path":"2022/10/15/designPatter/设计模式-22-模板方法模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-22-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法的某些特定步骤 2、应用场景一个操作的步骤稳定，而具体细节的改变延迟的子类 3、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:21--策略模式","slug":"designPatter/设计模式-21-策略模式","date":"2022-10-15T14:20:44.000Z","updated":"2022-10-21T05:57:03.557Z","comments":true,"path":"2022/10/15/designPatter/设计模式-21-策略模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-21-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。 2、应用场景3、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:20--状态模式","slug":"designPatter/设计模式-20-状态模式","date":"2022-10-15T14:20:27.000Z","updated":"2022-10-21T05:52:35.500Z","comments":true,"path":"2022/10/15/designPatter/设计模式-20-状态模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-20-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。 2、应用场景一个对象的内部状态改变时，他的行为剧烈的变化。 3、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:19--观察者模式","slug":"designPatter/设计模式-19-观察者模式","date":"2022-10-15T14:20:06.000Z","updated":"2022-10-21T05:57:20.101Z","comments":true,"path":"2022/10/15/designPatter/设计模式-19-观察者模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-19-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。 2、应用场景3、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:18--备忘录模式","slug":"designPatter/设计模式-18-备忘录模式","date":"2022-10-15T14:19:47.000Z","updated":"2022-10-21T05:57:22.825Z","comments":true,"path":"2022/10/15/designPatter/设计模式-18-备忘录模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-18-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 2、应用场景3、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:17--中介模式","slug":"designPatter/设计模式-17-中介模式","date":"2022-10-15T14:19:32.000Z","updated":"2022-10-21T05:57:26.293Z","comments":true,"path":"2022/10/15/designPatter/设计模式-17-中介模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-17-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念用一个中介对象封装一些列的对象交互。 2、应用场景3、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:16--迭代模式","slug":"designPatter/设计模式-16-迭代模式","date":"2022-10-15T14:19:03.000Z","updated":"2022-10-21T05:50:41.411Z","comments":true,"path":"2022/10/15/designPatter/设计模式-16-迭代模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-16-%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示 2、应用场景迭代。 3、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:15--解释器模式","slug":"designPatter/设计模式-15-解释器模式","date":"2022-10-15T14:18:43.000Z","updated":"2022-10-21T05:57:30.665Z","comments":true,"path":"2022/10/15/designPatter/设计模式-15-解释器模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-15-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 2、应用场景3、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class Variable;class Context&#123;public: void registerVariable(Variable *var, int value) &#123; m_map.insert(&#123; var, value &#125;); &#125; int lookUpValue(Variable *var) &#123; auto itor = m_map.find(var); if (itor != m_map.end()) &#123; return itor-&gt;second; &#125; return 0; &#125;private: std::unordered_map&lt;Variable *, int&gt; m_map;&#125;;class Expression&#123;public: virtual ~Expression() &#123;&#125; virtual int interpret(Context *ctx) = 0;&#125;;class Variable : public Expression&#123;public: virtual int interpret(Context *ctx) &#123; return ctx-&gt;lookUpValue(this); &#125;&#125;;class Constant : public Expression&#123;public: Constant(int value) : m_value(value) &#123;&#125; virtual int interpret(Context *ctx) override &#123; return m_value; &#125;private: int m_value;&#125;;class Add : public Expression&#123;public: Add(Expression *left, Expression *right) : m_left(left), m_right(right) &#123;&#125; virtual int interpret(Context *ctx) override &#123; return m_left-&gt;interpret(ctx) + m_right-&gt;interpret(ctx); &#125;private: Expression *m_left, *m_right;&#125;;class Sub : public Expression&#123;public: Sub(Expression *left, Expression *right) : m_left(left), m_right(right) &#123;&#125; virtual int interpret(Context *ctx) override &#123; return m_left-&gt;interpret(ctx) - m_right-&gt;interpret(ctx); &#125;private: Expression *m_left, *m_right;&#125;;class Mul : public Expression&#123;public: Mul(Expression *left, Expression *right) : m_left(left), m_right(right) &#123;&#125; virtual int interpret(Context *ctx) override &#123; return m_left-&gt;interpret(ctx) * m_right-&gt;interpret(ctx); &#125;private: Expression *m_left, *m_right;&#125;;class Div : public Expression&#123;public: Div(Expression *left, Expression *right) : m_left(left), m_right(right) &#123;&#125; virtual int interpret(Context *ctx) override &#123; assert(m_right-&gt;interpret(ctx) != 0); return m_left-&gt;interpret(ctx) / m_right-&gt;interpret(ctx); &#125;private: Expression *m_left, *m_right;&#125;;int main()&#123; Context ctx; Variable a; Variable b; Constant c(1024); ctx.registerVariable(&amp;a, 22); ctx.registerVariable(&amp;b, 11); Expression *e1 = new Mul(&amp;a, &amp;b); //242 Expression *e2 = new Div(&amp;a, &amp;b); //1 Expression *e3 = new Add(e2, &amp;c); //1025 Expression *e = new Sub(e1, e3); std::cout &lt;&lt; e-&gt;interpret(&amp;ctx) &lt;&lt; std::endl; delete e1, e2, e3, e; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:14--命令模式","slug":"designPatter/设计模式-14-命令模式","date":"2022-10-15T14:18:23.000Z","updated":"2022-10-21T05:49:39.071Z","comments":true,"path":"2022/10/15/designPatter/设计模式-14-命令模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-14-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。 2、应用场景将命令者与执行者完全解耦。 3、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class ICommand&#123;public: virtual ~ICommand() &#123;&#125; virtual void execute() = 0;&#125;;class Drawable&#123;public: virtual ~Drawable() &#123;&#125; virtual void draw(int x, int y) = 0;&#125;;class MacroCommand : public ICommand&#123;public: ~MacroCommand() &#123; clear(); &#125; virtual void execute() override &#123; for (auto cmd : m_commandList) &#123; cmd-&gt;execute(); &#125; &#125; void addCommand(ICommand *cmd) &#123; m_commandList.push_back(cmd); &#125; void clear() &#123; for (auto cmd : m_commandList) &#123; delete cmd; &#125; m_commandList.clear(); &#125; void undo() &#123; if (!m_commandList.empty()) &#123; auto cmd = m_commandList.back(); delete cmd; m_commandList.pop_back(); &#125; &#125;private: std::vector&lt;ICommand *&gt; m_commandList;&#125;;class DrawCommand : public ICommand&#123;public: DrawCommand(int x, int y, Drawable *drawable) : m_x(x), m_y(y), m_drawable(drawable) &#123;&#125; virtual void execute() override &#123; m_drawable-&gt;draw(m_x, m_y); &#125;private: int m_x; int m_y; Drawable *m_drawable;&#125;;class DrawCanvas : public Drawable&#123;public: DrawCanvas(MacroCommand *macroCommand) : m_macroCommand(macroCommand) &#123;&#125; virtual void draw(int x, int y) override &#123; std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; std::endl; &#125; void paint() &#123; m_macroCommand-&gt;execute(); &#125;private: MacroCommand *m_macroCommand;&#125;;int main()&#123; MacroCommand macroCommand; DrawCanvas canvas(&amp;macroCommand); macroCommand.addCommand(new DrawCommand(1, 2, &amp;canvas)); canvas.draw(20, 10); canvas.paint(); return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:13--责任链模式","slug":"designPatter/设计模式-13-责任链模式","date":"2022-10-15T14:18:06.000Z","updated":"2022-10-21T05:57:35.517Z","comments":true,"path":"2022/10/15/designPatter/设计模式-13-责任链模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-13-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系 2、应用场景3、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class Trouble &#123;public: Trouble(int number) : m_number(number) &#123;&#125; int getNumber() const &#123; return m_number; &#125; std::string toString() const &#123; return &quot;[ Trouble &quot; + std::to_string(m_number) + &quot; ]&quot;; &#125;private: int m_number;&#125;;class Support &#123;public: virtual ~Support() &#123;&#125; Support(const std::string &amp;name) : m_name(name) &#123;&#125; Support *setNext(Support *next) &#123; m_next = next; return next; &#125; void support(Trouble *trouble) &#123; if (resolve(trouble)) done(trouble); else if (m_next) m_next-&gt;support(trouble); else fail(trouble); &#125; std::string toString() const &#123; return &quot;[&quot; + m_name + &quot;]&quot;; &#125; virtual bool resolve(Trouble *trouble) = 0;protected: void done(Trouble *trouble) &#123; std::cout &lt;&lt; trouble-&gt;toString() &lt;&lt; &quot; is solved by &quot; &lt;&lt; toString() &lt;&lt; std::endl; &#125; void fail(Trouble *trouble) &#123; std::cout &lt;&lt; trouble-&gt;toString() &lt;&lt; &quot; cannot be resolved.&quot; &lt;&lt; std::endl; &#125;private: std::string m_name; Support *m_next = nullptr;&#125;;class NoSupport : public Support &#123;public: using Support::Support; virtual bool resolve(Trouble *trouble) override &#123; return false; &#125;&#125;;class OddSupport : public Support &#123;public: using Support::Support; virtual bool resolve(Trouble *trouble) override &#123; return (trouble-&gt;getNumber() % 2 == 0); &#125;&#125;;class LimitSupport : public Support &#123;public: LimitSupport(const std::string &amp;name, int limit) : Support(name), m_limit(limit)&#123;&#125; virtual bool resolve(Trouble *trouble) override &#123; return (trouble-&gt;getNumber() &lt;= m_limit); &#125;private: int m_limit;&#125;;class SpecialSupport : public Support &#123;public: SpecialSupport(const std::string &amp;name, int num) : Support(name), m_num (num) &#123;&#125; virtual bool resolve(Trouble *trouble) override &#123; return (trouble-&gt;getNumber() == m_num); &#125; private: int m_num;&#125;;int main()&#123; Support *s1 = new NoSupport(&quot;Alance&quot;); Support *s2 = new LimitSupport(&quot;Bob&quot;, 30); Support *s3 = new OddSupport(&quot;Charlie&quot;); Support *s4 = new SpecialSupport(&quot;David&quot;, 55); s1-&gt;setNext(s2)-&gt;setNext(s3)-&gt;setNext(s4); for (int i = 0; i &lt; 100; ++i) &#123; Trouble t(i); s1-&gt;support(&amp;t); &#125; delete s1; delete s2; delete s3; delete s4; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:12--代理模式","slug":"designPatter/设计模式-12-代理模式","date":"2022-10-15T14:17:42.000Z","updated":"2022-10-21T05:57:39.993Z","comments":true,"path":"2022/10/15/designPatter/设计模式-12-代理模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-12-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念为其他对象提供一种代理以控制对这个对象的访问 2、应用场景3、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class Printable &#123;public: virtual ~Printable() &#123;&#125; virtual void setPrinterName(const std::string &amp;name) = 0; virtual const std::string &amp;getPrinterName() const = 0; virtual void print() = 0;&#125;;class Printer : public Printable &#123;public: Printer(const std::string &amp;name) : m_name(name) &#123; heavyJob(); &#125; virtual void setPrinterName(const std::string &amp;name) override &#123; m_name = name; &#125; virtual const std::string &amp;getPrinterName() const &#123; return m_name; &#125; void print() override &#123; std::cout &lt;&lt; __FUNCTION__ &lt;&lt; getPrinterName() &lt;&lt; std::endl; &#125;private: void heavyJob() &#123; std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot; start &quot; &lt;&lt; std::endl; for (int i = 0; i &lt; 5; ++i) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(300)); &#125; std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot; end &quot; &lt;&lt; std::endl; &#125;private: std::string m_name;&#125;;class PrinterProxy : public Printable &#123;public: PrinterProxy(const std::string &amp;name) : m_name(name) &#123;&#125; ~PrinterProxy() &#123; delete m_printer; &#125; virtual void setPrinterName(const std::string &amp;name) override &#123; if (m_printer != nullptr) &#123; m_printer-&gt;setPrinterName(name); &#125; m_name = name; &#125; virtual const std::string &amp;getPrinterName() const override &#123; return m_name; &#125; void print() override &#123; if (nullptr == m_printer)&#123; m_printer = new Printer(m_name); &#125; m_printer-&gt;print(); &#125;private: Printer *m_printer = nullptr; std::string m_name;&#125;;int main()&#123; Printable *p = new PrinterProxy(&quot;123&quot;); std::cout &lt;&lt; p-&gt;getPrinterName() &lt;&lt; std::endl; p-&gt;setPrinterName(&quot;456&quot;); std::cout &lt;&lt; p-&gt;getPrinterName() &lt;&lt; std::endl; p-&gt;print(); p-&gt;setPrinterName(&quot;789&quot;); p-&gt;print(); delete p; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:11--享元模式","slug":"designPatter/设计模式-11-享元模式","date":"2022-10-15T14:17:27.000Z","updated":"2022-10-21T05:57:42.773Z","comments":true,"path":"2022/10/15/designPatter/设计模式-11-享元模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-11-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。 2、应用场景3、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;static const char *strList[] = &#123; &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;......##........\\n&quot; &quot;..######........\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;..##########....\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..........##....\\n&quot; &quot;......####......\\n&quot; &quot;....##..........\\n&quot; &quot;..##............\\n&quot; &quot;..##########....\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..........##....\\n&quot; &quot;......####......\\n&quot; &quot;..........##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;........##......\\n&quot; &quot;......####......\\n&quot; &quot;....##..##......\\n&quot; &quot;..##....##......\\n&quot; &quot;..########......\\n&quot; &quot;........##......\\n&quot; &quot;......######....\\n&quot; &quot;................\\n&quot;, &quot;..##########....\\n&quot; &quot;..##............\\n&quot; &quot;..##............\\n&quot; &quot;..########......\\n&quot; &quot;..........##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##............\\n&quot; &quot;..########......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;..##########....\\n&quot; &quot;..##......##....\\n&quot; &quot;..........##....\\n&quot; &quot;........##......\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....########....\\n&quot; &quot;..........##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;................\\n&quot; &quot;................\\n&quot; &quot;................\\n&quot; &quot;................\\n&quot; &quot;..##########....\\n&quot; &quot;................\\n&quot; &quot;................\\n&quot; &quot;................\\n&quot; &#125;;class BigChar&#123;public: BigChar(int order) : m_char(strList[order % 11]) &#123;&#125; void show() &#123; std::cout &lt;&lt; m_char &lt;&lt; std::endl; &#125;private: const char *m_char;&#125;;class BigCharFactory&#123;public: ~BigCharFactory() &#123; for (auto i : m_map) &#123; delete i.second; &#125; m_map.clear(); &#125; BigChar *getBigChar(int order) &#123; BigChar *b = nullptr; int tOrder = order % 11; auto it = m_map.find(tOrder); if (it == m_map.end()) &#123; b = new BigChar(tOrder); m_map.insert(&#123; tOrder, b &#125;); return b; &#125; else &#123; return it-&gt;second; &#125; &#125;private: std::unordered_map&lt;int, BigChar *&gt; m_map;&#125;;int main()&#123; BigCharFactory f; for (int i = 0; i &lt; 20; ++i) &#123; for (int j = 0; j &lt; 2; ++j) &#123; BigChar *b = f.getBigChar(i); std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; std::endl; b-&gt;show(); &#125; &#125; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:10--外观模式","slug":"designPatter/设计模式-10-外观模式","date":"2022-10-15T14:16:48.000Z","updated":"2022-10-21T05:57:45.621Z","comments":true,"path":"2022/10/15/designPatter/设计模式-10-外观模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-10-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念为子系统中的一组接口提供一致的界面，fa?ade提供了一高层接口，这个接口使得子系统更容易使用。 2、应用场景3、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;using namespace std;class DataBase &#123;public: ~DataBase() = default; static DataBase &amp;GetInstance() &#123; static DataBase db; return db; &#125; std::string getNameByEmail(const std::string &amp;email) const &#123; auto it = m_map.find(email); if (it != m_map.end()) return it-&gt;second; else return &#123;&#125;; &#125;protected: DataBase(const DataBase &amp;) = delete; DataBase(DataBase &amp;&amp;) = delete; DataBase &amp;operator=(const DataBase &amp;) = delete; DataBase &amp;operator=(DataBase &amp;&amp;) = delete;private: DataBase() &#123;&#125;private: std::unordered_map&lt;std::string, std::string&gt; m_map&#123; &#123; &quot;zhangsan@zhangsan.com&quot;, &quot;zhangsan&quot; &#125;, &#123; &quot;lisi@lisi.com&quot;, &quot;lisi&quot; &#125;, &#123; &quot;wangwu@wangwu.com&quot;, &quot;wangwu&quot; &#125; &#125;;&#125;;class HtmlWriter&#123;public: void title(const std::string &amp;title) &#123; m_ss &lt;&lt; &quot;&lt;html&gt;&quot; &lt;&lt; &quot;&lt;head&gt;&quot; &lt;&lt; &quot;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&quot; &lt;&lt; &quot;&lt;/head&gt;&quot; &lt;&lt; &quot;&lt;body&gt;\\n&quot; &lt;&lt; &quot;&lt;h1&gt;&quot; + title + &quot;&lt;/h1&gt;\\n&quot;; &#125; void paragraph(const std::string &amp;msg) &#123; m_ss &lt;&lt; &quot;&lt;p&gt;&quot; + msg + &quot;&lt;/p&gt;\\n&quot;; &#125; void link(const std::string &amp;herf, const std::string &amp;caption) &#123; paragraph(&quot;&lt;a herf=\\&quot;&quot; + herf + &quot;\\&quot;&gt;&quot; + caption + &quot;&lt;/a&gt;&quot;); &#125; void mailto(const std::string &amp;mailAddr, const std::string &amp;userName)&#123; link(&quot;mailto:&quot; + mailAddr, userName); &#125; void close() &#123; m_ss &lt;&lt; &quot;&lt;/body&gt;&quot; &lt;&lt; &quot;&lt;/html&gt;\\n&quot;; &#125; std::string toString() const &#123; return m_ss.str(); &#125;private: std::stringstream m_ss;&#125;;class PageMaker&#123;public: ~PageMaker() = default; PageMaker(const PageMaker &amp;) = delete; PageMaker(PageMaker &amp;&amp;) = delete; PageMaker &amp;operator=(const PageMaker &amp;) = delete; PageMaker &amp;operator=(PageMaker &amp;&amp;) = delete; static PageMaker &amp;GetInstance() &#123; static PageMaker pm; return pm; &#125; void makeWelcomePage(const std::string &amp;mailAddr) &#123; auto name = DataBase::GetInstance().getNameByEmail(mailAddr); HtmlWriter writer; writer.title(&quot;Welcome to &quot; + name + &quot;&#x27;s page!&quot;); writer.paragraph(name + u8&quot;欢迎来到&quot; + name + u8&quot;的主页.&quot;); writer.paragraph(u8&quot;等着你的邮件哦！&quot;); writer.mailto(mailAddr, name); writer.close(); std::cout &lt;&lt; writer.toString() &lt;&lt; std::endl; &#125;protected: PageMaker() &#123;&#125;private:&#125;;int main()&#123; assert(DataBase::GetInstance().getNameByEmail(&quot;&quot;).empty()); PageMaker::GetInstance().makeWelcomePage(&quot;zhangsan@zhangsan.com&quot;); return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:09--装饰模式","slug":"designPatter/设计模式-09-装饰模式","date":"2022-10-15T14:16:29.000Z","updated":"2022-10-21T05:57:49.037Z","comments":true,"path":"2022/10/15/designPatter/设计模式-09-装饰模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-09-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。 2、应用场景3、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;class IDisplay &#123;public: virtual ~IDisplay() &#123;&#125; virtual int getRows() const = 0; virtual int getColumns() const = 0; virtual std::string getRow(int index) const = 0; void show() &#123; int r = getRows(); for (int i = 0; i &lt; r; ++i) &#123; std::cout &lt;&lt; getRow(i) &lt;&lt; std::endl; &#125; &#125;&#125;;class StringDisplay : public IDisplay &#123;public: StringDisplay(const std::string &amp;str) : m_str(str) &#123;&#125; virtual int getRows() const override &#123; return 1; &#125; virtual int getColumns() const override &#123; return static_cast&lt;int&gt;(m_str.length()); &#125; virtual std::string getRow(int index) const override &#123; if (index == 0) return m_str; else return &#123;&#125;; &#125;private: std::string m_str;&#125;;class Border : public IDisplay &#123;public: Border(IDisplay *display) : m_display(display) &#123;&#125; virtual ~Border() &#123; delete m_display; &#125;protected: IDisplay *m_display;&#125;;class FullBorder : public Border &#123;public: FullBorder(IDisplay *display) : Border(display) &#123;&#125; virtual int getRows() const override &#123; return 1 + m_display-&gt;getRows() + 1; &#125; virtual int getColumns() const override &#123; return 1 + m_display-&gt;getColumns() + 1; &#125; virtual std::string getRow(int index) const override &#123; if (index == 0) return &quot;+&quot; + makeLine(&#x27;-&#x27;, m_display-&gt;getColumns()) + &quot;+&quot;; else if (index == m_display-&gt;getRows() + 1) return &quot;+&quot; + makeLine(&#x27;-&#x27;, m_display-&gt;getColumns()) + &quot;+&quot;; else return &quot;|&quot; + m_display-&gt;getRow(index - 1) + &quot;|&quot;; &#125;private: std::string makeLine(char ch, int count) const &#123; std::string str; str.resize(count, ch); return str; &#125;&#125;;class SideBorder : public Border &#123;public: SideBorder(IDisplay *display, const char &amp;borderChar) : Border(display), m_borderChar(borderChar) &#123;&#125; virtual int getRows() const override &#123; return m_display-&gt;getRows(); &#125; virtual int getColumns() const override &#123; return 1 + m_display-&gt;getColumns() + 1; &#125; virtual std::string getRow(int index) const override &#123; return m_borderChar + m_display-&gt;getRow(index) + m_borderChar; &#125;private: char m_borderChar;&#125;;int main()&#123; IDisplay *d1 = new StringDisplay(&quot;Hello&quot;); assert(d1-&gt;getRow(-1).empty()); IDisplay *d2 = new SideBorder(d1, &#x27;#&#x27;); IDisplay *d3 = new FullBorder(d2); d1-&gt;show(); d2-&gt;show(); d3-&gt;show(); IDisplay *d4 = new SideBorder(new FullBorder(new FullBorder(new SideBorder(new FullBorder(new StringDisplay(&quot;Hello,World&quot;)), &#x27;*&#x27;))), &#x27;/&#x27;); d4-&gt;show(); delete d1; delete d4; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:08--组合模式","slug":"designPatter/设计模式-08-组合模式","date":"2022-10-15T14:16:07.000Z","updated":"2022-10-21T05:57:51.833Z","comments":true,"path":"2022/10/15/designPatter/设计模式-08-组合模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-08-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性 2、应用场景3、UML 二、案例1、案例1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class Component &#123;public: Component()&#123;&#125; Component(string iName) &#123; this-&gt;name = iName; &#125; virtual ~Component()&#123;&#125; virtual void add(Component*) = 0; virtual void remove(Component*) = 0; virtual Component* getChild(int) = 0; virtual void operation() = 0; string getName() &#123; return name; &#125;private: string name;&#125;;class Office : public Component &#123;public: Office(string iName) &#123; this-&gt;name = iName; &#125; Office() &#123;&#125; void add(Component* c) &#123; printf(&quot;not support!\\n&quot;); &#125; void remove(Component* c) &#123; printf(&quot;not support!\\n&quot;); &#125; Component* getChild(int i) &#123; printf(&quot;not support!\\n&quot;); return NULL; &#125;private: string name;&#125;;class AdminOffice :public Office &#123;public: AdminOffice(string iName) &#123; this-&gt;name = iName; &#125; void operation() &#123; printf(&quot;-----Administration Office:%s\\n&quot;, name.c_str()); &#125;private: string name;&#125;;class DeanOffice :public Office &#123;public: DeanOffice(string iName) &#123; this-&gt;name = iName; &#125; void operation() &#123; printf(&quot;-----Dean Office:%s\\n&quot;, name.c_str()); &#125;private: string name;&#125;;class SubComponent :public Component &#123;public: SubComponent(string iName) &#123; this-&gt;name = iName; &#125; void add(Component *c) &#123; componentList.push_back(c); &#125; void remove(Component *c) &#123; for (int i = 0; i &lt; componentList.size(); i++) &#123; if (componentList[i]-&gt;getName() == c-&gt;getName()) &#123; componentList.erase(componentList.begin() + i); break; &#125; &#125; &#125; Component* getChild(int i) &#123; return (Component*)componentList[i]; &#125; void operation() &#123; printf(&quot;%s\\n&quot;, this-&gt;name.c_str()); for (int i = 0; i &lt; componentList.size(); i++) &#123; ((Component*)componentList[i])-&gt;operation(); &#125; &#125;private: string name; vector&lt;Component*&gt;componentList;&#125;;int main()&#123; Component *head, *sichuanBranch, *cdBranch, *myBranch, *office1, *office2, *office3, *office4, *office5, *office6, *office7, *office8; head = new SubComponent(&quot;总部&quot;); sichuanBranch = new SubComponent(&quot;四川分部&quot;); office1 = new AdminOffice(&quot;行政办公室&quot;); office2 = new DeanOffice(&quot;教务办公室&quot;); cdBranch = new SubComponent(&quot;成都分部&quot;); myBranch = new SubComponent(&quot;绵阳分部&quot;); office3 = new AdminOffice(&quot;行政办公室&quot;); office4 = new DeanOffice(&quot;教务办公室&quot;); office5 = new AdminOffice(&quot;行政办公室&quot;); office6 = new DeanOffice(&quot;教务办公室&quot;); office7 = new AdminOffice(&quot;行政办公室&quot;); office8 = new DeanOffice(&quot;教务办公室&quot;); cdBranch-&gt;add(office5); cdBranch-&gt;add(office6); myBranch-&gt;add(office7); myBranch-&gt;add(office8); sichuanBranch-&gt;add(office3); sichuanBranch-&gt;add(office4); sichuanBranch-&gt;add(cdBranch); sichuanBranch-&gt;add(myBranch); head-&gt;add(office1); head-&gt;add(office2); head-&gt;add(sichuanBranch); head-&gt;operation(); delete head; delete sichuanBranch; delete cdBranch; delete myBranch; delete office1; delete office2; delete office3; delete office4; delete office5; delete office6; delete office7; delete office8; return 0;&#125; 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;class Entry &#123;public: virtual ~Entry() &#123;&#125; virtual std::string getName() const = 0; virtual int getSize() const = 0; virtual void addEntryy(Entry *entry) &#123;&#125; virtual void printList(const std::string &amp;str) = 0; void printList() &#123; printList(&quot;&quot;); &#125; std::string toString() const &#123; return getName() + &quot; (&quot; + std::to_string(getSize()) + &quot;)&quot;; &#125;&#125;;class File : public Entry &#123;public: File(const std::string &amp;name, int size) : m_name(name), m_size(size) &#123;&#125; virtual std::string getName() const override &#123; return m_name; &#125; virtual int getSize() const override &#123; return m_size; &#125; virtual void printList(const std::string &amp;str) override &#123; std::cout &lt;&lt; str &lt;&lt; &quot;/&quot; &lt;&lt; toString() &lt;&lt; std::endl; &#125;private: std::string m_name; int m_size;&#125;;class Directory : public Entry &#123;public: Directory(const std::string &amp;name) : m_name(name) &#123;&#125; ~Directory() &#123; for (auto it : m_dirs) &#123; delete it; &#125; m_dirs.clear(); &#125; virtual std::string getName() const override &#123; return m_name; &#125; virtual int getSize() const &#123; int size = 0; for (auto it : m_dirs) &#123; size += it-&gt;getSize(); &#125; return size; &#125; virtual void addEntryy(Entry *entry) override &#123; m_dirs.push_back(entry); &#125; virtual void printList(const std::string &amp;str) override &#123; std::cout &lt;&lt; str &lt;&lt; &quot;/&quot; &lt;&lt; toString() &lt;&lt; std::endl; for (auto it : m_dirs) &#123; it-&gt;printList(str + &quot;/&quot; + m_name); &#125; &#125;private: std::string m_name; std::vector&lt;Entry *&gt; m_dirs;&#125;;int main()&#123; Directory *root = new Directory(&quot;root&quot;); Directory *bin = new Directory(&quot;bin&quot;); Directory *tmp = new Directory(&quot;tmp&quot;); Directory *usr = new Directory(&quot;usr&quot;); root-&gt;addEntryy(bin); root-&gt;addEntryy(tmp); root-&gt;addEntryy(usr); bin-&gt;addEntryy(new File(&quot;vi&quot;, 3000)); bin-&gt;addEntryy(new File(&quot;latex&quot;, 2000)); static_cast&lt;Entry *&gt;(root)-&gt;printList(); Directory *yuki = new Directory(&quot;yuki&quot;); Directory *hanako = new Directory(&quot;hanako&quot;); Directory *tomura = new Directory(&quot;tomura&quot;); usr-&gt;addEntryy(yuki); usr-&gt;addEntryy(hanako); usr-&gt;addEntryy(tomura); yuki-&gt;addEntryy(new File(&quot;diary.html&quot;, 100)); hanako-&gt;addEntryy(new File(&quot;memo.tex&quot;, 1024)); tomura-&gt;addEntryy(new File(&quot;junk.mail&quot;, 40)); static_cast&lt;Entry *&gt;(root)-&gt;printList(); // for test coverage &#123; File *f = new File(&quot;123.txt&quot;, 1); f-&gt;addEntryy(root); f-&gt;printList(&quot;&quot;); delete f; &#125; &#123; yuki-&gt;printList(&quot;&quot;); &#125; &#123; File *f = new File(&quot;123.txt&quot;, 1); Entry *e = new Directory(&quot;test&quot;); e-&gt;addEntryy(f); e-&gt;printList(&quot;&quot;); e-&gt;toString(); delete e; &#125; delete root; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:07--桥接模式","slug":"designPatter/设计模式-07-桥接模式","date":"2022-10-15T14:15:47.000Z","updated":"2022-10-21T05:57:54.617Z","comments":true,"path":"2022/10/15/designPatter/设计模式-07-桥接模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-07-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念将抽象部分与它的实现部分相分离，使他们可以独立的变化 2、应用场景3、UML 二、案例1、案例11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;class Game &#123;public: Game()&#123;&#125; virtual ~Game()&#123;&#125; virtual void play() = 0;private:&#125;;class GameA : public Game &#123;public: GameA()&#123;&#125; void play()&#123; printf(&quot;Jungle play gameA\\n&quot;); &#125;&#125;;class GameB : public Game &#123;public: GameB()&#123;&#125; void play()&#123; printf(&quot;Jungle play gameB\\n&quot;); &#125;&#125;;class Phone &#123;public: Phone()&#123;&#125; virtual ~Phone()&#123;&#125; virtual void setupGame(Game *igame) = 0; virtual void play() = 0;private: Game *game;&#125;;class PhoneA:public Phone &#123;public: PhoneA()&#123;&#125; void setupGame(Game *igame)&#123; this-&gt;game = igame; &#125; void play()&#123; this-&gt;game-&gt;play(); &#125;private: Game *game;&#125;;class PhoneB :public Phone &#123;public: PhoneB()&#123;&#125; void setupGame(Game *igame)&#123; this-&gt;game = igame; &#125; void play()&#123; this-&gt;game-&gt;play(); &#125;private: Game *game;&#125;;int main()&#123; Game *game; Phone *phone; phone = new PhoneA(); game = new GameA(); phone-&gt;setupGame(game); phone-&gt;play(); printf(&quot;++++++++++++++++++++++++++++++++++\\n&quot;); delete game; game = new GameB(); phone-&gt;setupGame(game); phone-&gt;play(); delete phone; delete game; return 0;&#125; 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;class IDisplayImpl &#123;public: virtual ~IDisplayImpl() &#123;&#125; virtual void rawOpen() = 0; virtual void rawPrint() = 0; virtual void rawClose() = 0;&#125;;class Display &#123;public: virtual ~Display() &#123;&#125; Display(IDisplayImpl *impl) : m_pImpl(impl) &#123;&#125; virtual void open() &#123; m_pImpl-&gt;rawOpen(); &#125; virtual void print() &#123; m_pImpl-&gt;rawPrint(); &#125; virtual void close() &#123; m_pImpl-&gt;rawClose(); &#125; void display() &#123; open(); print(); close(); &#125;private: IDisplayImpl *m_pImpl;&#125;;class CountDisplay : public Display &#123;public: using Display::Display; void mulitDisplay(unsigned int count) &#123; open(); for (unsigned int i = 0; i &lt; count; ++i) print(); close(); &#125;&#125;;class StringDisplayImpl : public IDisplayImpl&#123;public: StringDisplayImpl(const std::string &amp;str) : m_str(str) &#123;&#125; virtual void rawOpen() override &#123; printLine(); &#125; virtual void rawPrint() override &#123; cout &lt;&lt; &quot;|&quot; &lt;&lt; m_str &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; &#125; virtual void rawClose() override &#123; printLine(); &#125;private: void printLine() &#123; cout &lt;&lt; &quot;+&quot;; for (int i = 0; i &lt; m_str.length(); ++i) cout &lt;&lt; &quot;-&quot;; cout &lt;&lt; &quot;+&quot; &lt;&lt; endl; &#125;private: std::string m_str;&#125;;int main()&#123; std::shared_ptr&lt;IDisplayImpl&gt; impl1(new StringDisplayImpl(&quot;Hello, China&quot;)); std::shared_ptr&lt;Display&gt; d1(new Display(impl1.get())); std::shared_ptr&lt;IDisplayImpl&gt; impl2(new StringDisplayImpl(&quot;Hello, Tao&quot;)); std::shared_ptr&lt;Display&gt; d2(new CountDisplay(impl2.get())); std::shared_ptr&lt;IDisplayImpl&gt; impl3(new StringDisplayImpl(&quot;Hello,Universe&quot;)); std::shared_ptr&lt;CountDisplay&gt; d3(new CountDisplay(impl3.get())); d1-&gt;display(); d2-&gt;display(); d3-&gt;display(); d3-&gt;mulitDisplay(4); return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:06--适配器模式","slug":"designPatter/设计模式-06-适配器模式","date":"2022-10-15T14:15:26.000Z","updated":"2022-10-21T05:57:58.977Z","comments":true,"path":"2022/10/15/designPatter/设计模式-06-适配器模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-06-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。 2、应用场景3、UML 二、案例1、案例11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;class Controller &#123;public: Controller()&#123;&#125; virtual ~Controller()&#123;&#125; virtual void pathPlanning() = 0;&#125;;class DxfParser &#123;public: DxfParser()&#123;&#125; void parseFile()&#123; printf(&quot;parseFile\\n&quot;); &#125;&#125;;class PathPlanner &#123;public: PathPlanner()&#123;&#125; void calculate()&#123; printf(&quot;calculate\\n&quot;); &#125;&#125;;class Adapter:public Controller &#123;public: Adapter()&#123; dxfParser = new DxfParser(); pathPlanner = new PathPlanner(); &#125; void pathPlanning()&#123; printf(&quot;pathPlanning\\n&quot;); dxfParser-&gt;parseFile(); pathPlanner-&gt;calculate(); &#125;private: DxfParser *dxfParser; PathPlanner *pathPlanner;&#125;;int main()&#123; Controller *controller = new Adapter(); controller-&gt;pathPlanning(); delete controller; return 0;&#125; 2、案例212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;class Banner &#123;public: Banner(const std::string &amp;str) : m_str(str) &#123;&#125; void showWithParen() &#123; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; m_str &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; &#125; void showWithAster() &#123; std::cout &lt;&lt; &quot;*&quot; &lt;&lt; m_str &lt;&lt; &quot;*&quot; &lt;&lt; std::endl; &#125;private: std::string m_str;&#125;;class Painter &#123;public: virtual ~Painter() &#123;&#125; virtual void printStrong() = 0; virtual void printWeak() = 0;&#125;;class PainterBanner : public Banner, public Painter &#123;public: PainterBanner(const std::string &amp;str) : Banner(str) &#123;&#125; virtual void printStrong() override &#123; showWithParen(); &#125; virtual void printWeak() override &#123; showWithAster(); &#125;&#125;;int main()&#123; Painter *painter = new PainterBanner(std::string(&quot;HelloWorld&quot;)); painter-&gt;printStrong(); painter-&gt;printWeak(); delete painter; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:05--单例模式","slug":"designPatter/设计模式-05-单例模式","date":"2022-10-15T14:14:36.000Z","updated":"2022-10-21T05:45:06.174Z","comments":true,"path":"2022/10/15/designPatter/设计模式-05-单例模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-05-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念保证一个类只有一个实例，并提供一个访问它的全局访问点 2、应用场景一个无状态的类使用单例模式节省内存资源 3、UML 二、案例1、案例112345678910111213141516171819202122class Singleton &#123;public: static Singleton* getInstance() &#123; if (instance == NULL) &#123; m_mutex.lock(); if (instance == NULL)&#123; printf(&quot;create Singleton\\n&quot;); instance = new Singleton(); &#125; m_mutex.unlock(); &#125; return instance; &#125;private: Singleton()&#123;&#125; static Singleton* instance; static std::mutex m_mutex;&#125;;Singleton* Singleton::instance = NULL;std::mutex Singleton::m_mutex; 2、案例21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;template &lt;class T&gt;class SingleTon &#123;public: static T &amp;GetInstance() &#123; static T ins; return ins; &#125; SingleTon(const SingleTon &amp;) = delete; SingleTon &amp;operator=(const SingleTon &amp;) = delete; virtual ~SingleTon() &#123;&#125;protected: SingleTon() &#123;&#125;&#125;;class Apple : public SingleTon&lt;Apple&gt; &#123; friend SingleTon&lt;Apple&gt;;public: void show() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125; ~Apple() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125;protected: Apple() &#123;&#125;&#125;;class Orange : public SingleTon&lt;Orange&gt; &#123; friend SingleTon&lt;Orange&gt;;public: ~Orange() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125; void show() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125;protected: Orange()&#123;&#125;&#125;;int main()&#123; Apple::GetInstance().show(); cout &lt;&lt; &amp;Apple::GetInstance() &lt;&lt; endl; Apple::GetInstance().show(); cout &lt;&lt; &amp;Apple::GetInstance() &lt;&lt; endl; Orange::GetInstance().show(); Orange::GetInstance().show(); Orange::GetInstance().show(); return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:04--原型模式","slug":"designPatter/设计模式-04-原型模式","date":"2022-10-15T14:14:15.000Z","updated":"2022-10-21T05:44:45.269Z","comments":true,"path":"2022/10/15/designPatter/设计模式-04-原型模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-04-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象 2、应用场景用new创建一个对象需要非常繁琐的数据准备或者权限，可以考虑使用原型模式 3、UML 二、案例1、案例1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class WorkModel &#123;public: char *modelName; void setWorkModelName(char *iName)&#123; this-&gt;modelName = iName; &#125;&#125;;class PrototypeWork &#123;public: PrototypeWork()&#123;&#125; virtual PrototypeWork *clone() = 0;&#125;;class ConcreteWork :public PrototypeWork &#123;public: ConcreteWork()&#123;&#125; ConcreteWork(char* iName, int iIdNum, char* modelName)&#123; this-&gt;name = iName; this-&gt;idNum = iIdNum; this-&gt;workModel = new WorkModel(); this-&gt;workModel-&gt;setWorkModelName(modelName); &#125; ConcreteWork *clone()&#123; ConcreteWork *work = new ConcreteWork(); work-&gt;setName(this-&gt;name); work-&gt;setIdNum(this-&gt;idNum); work-&gt;workModel = this-&gt;workModel; return work; &#125; void setName(char* iName)&#123; this-&gt;name = iName; &#125; void setIdNum(int iIdNum)&#123; this-&gt;idNum = iIdNum; &#125; void setModel(WorkModel *iWorkModel)&#123; this-&gt;workModel = iWorkModel; &#125; void printWorkInfo()&#123; printf(&quot;name:%s\\n&quot;, this-&gt;name); printf(&quot;idNum:%d\\n&quot;, this-&gt;idNum); printf(&quot;modelName:%s\\n&quot;, this-&gt;workModel-&gt;modelName); &#125;private: char* name; int idNum; WorkModel *workModel;&#125;;int main()&#123; ConcreteWork *singleWork = new ConcreteWork(&quot;Single&quot;, 1001, &quot;Single_Model&quot;); printf(&quot;\\nSingleConcreteWork\\n&quot;); ConcreteWork *jungleWork = singleWork-&gt;clone(); printf(&quot;\\nJungleConcreteWork\\n&quot;); printf(&quot;\\njungleClone&quot;); jungleWork-&gt;setName(&quot;jungle&quot;); jungleWork-&gt;setIdNum(1002); WorkModel *jungleModel = new WorkModel(); jungleModel-&gt;setWorkModelName(&quot;Jungle_Model&quot;); jungleWork-&gt;setModel(jungleModel); printf(&quot;\\nSingleInfo\\n&quot;); singleWork-&gt;printWorkInfo(); printf(&quot;\\nJungleInfo\\n&quot;); jungleWork-&gt;printWorkInfo(); return 0;&#125; 2、案例2``` C #include &lt;iostream&gt; #include &lt;functional&gt; #include &lt;memory&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;unordered_map&gt; #include &lt;cassert&gt; using namespace std; class IProduct &#123; public: virtual ~IProduct() &#123;&#125; virtual IProduct *Clone() = 0; virtual void Use(const std::string &amp;str) = 0; &#125;; class MessageBox : public IProduct &#123; public: MessageBox(const std::string &amp;str) : m_name(str) &#123;&#125; IProduct *Clone() override &#123; return new MessageBox(m_name); &#125; void Use(const std::string &amp;str) &#123; std::cout &lt;&lt; &quot;Message box &quot; &lt;&lt; m_name &lt;&lt; &quot; &quot; &lt;&lt; str &lt;&lt; std::endl; &#125; private: std::string m_name; &#125;; class ProductMgr &#123; public: void Register(const std::string &amp;name, IProduct *pro) &#123; m_map.insert(&#123; name, pro &#125;); &#125; IProduct *Create(const std::string &amp;name) &#123; auto it = m_map.find(name); if (it != m_map.end()) return it-&gt;second-&gt;Clone(); else return nullptr; &#125; private: std::unordered_map&lt;std::string, IProduct *&gt; m_map; &#125;; int main() &#123; ProductMgr mgr; IProduct *p1 = new MessageBox(&quot;Hello&quot;); mgr.Register(&quot;MB&quot;, p1); p1-&gt;Use(&quot;World&quot;); auto p2 = mgr.Create(&quot;MB&quot;); p2-&gt;Use(&quot;World&quot;); cout &lt;&lt; p1 &lt;&lt; endl; cout &lt;&lt; p2 &lt;&lt; endl; auto pp = mgr.Create(&quot;Not&quot;); assert(pp == nullptr); delete p1; delete p2; return 0; &#125; ...","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:03--建造者模式","slug":"designPatter/设计模式-03-建造者模式","date":"2022-10-15T14:13:17.000Z","updated":"2022-10-21T05:58:03.057Z","comments":true,"path":"2022/10/15/designPatter/设计模式-03-建造者模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-03-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。 2、应用场景一个类的各个组成部分的具体实现类或者算法经常面临着变化，但是将他们组合在一起的算法却相对稳定。提供一种封装机制 将稳定的组合算法于易变的各个组成部分隔离开来。 3、UML 二、案例1、案例1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class House &#123;public: House() &#123;&#125; void setFloor(string iFloor) &#123; this-&gt;floor = iFloor; &#125; void setWall(string iWall) &#123; this-&gt;wall = iWall; &#125; void setRoof(string iRoof) &#123; this-&gt;roof = iRoof; &#125; void printfHouseInfo() &#123; printf(&quot;Floor:%s\\t\\n&quot;, this-&gt;floor.c_str()); printf(&quot;Wall:%s\\t\\n&quot;, this-&gt;wall.c_str()); printf(&quot;Roof:%s\\t\\n&quot;, this-&gt;roof.c_str()); &#125;private: string floor; string wall; string roof;&#125;;class AbstractBuilder &#123;public: AbstractBuilder() &#123; house = new House(); &#125; virtual ~AbstractBuilder() &#123; if (house != nullptr) &#123; delete house; house = nullptr; &#125; &#125; virtual void buildFloor() = 0; virtual void buildWall() = 0; virtual void buildRoof() = 0; virtual House *getHouse() = 0; House *house;&#125;;class ConcreteBuilderA : public AbstractBuilder &#123;public: ConcreteBuilderA() &#123; printf(&quot;ConcreteBuilderA\\n&quot;); &#125; ~ConcreteBuilderA() &#123; &#125; void buildFloor() &#123; this-&gt;house-&gt;setFloor(&quot;Floor_A&quot;); &#125; void buildWall() &#123; this-&gt;house-&gt;setWall(&quot;Wall_A&quot;); &#125; void buildRoof() &#123; this-&gt;house-&gt;setRoof(&quot;Roof_A&quot;); &#125; House *getHouse() &#123; return this-&gt;house; &#125;&#125;;class ConcreteBuilderB : public AbstractBuilder &#123;public: ConcreteBuilderB() &#123; printf(&quot;ConcreteBuilderB\\n&quot;); &#125; ~ConcreteBuilderB() &#123; &#125; void buildFloor() &#123; this-&gt;house-&gt;setFloor(&quot;Floor_B&quot;); &#125; void buildWall() &#123; this-&gt;house-&gt;setWall(&quot;Wall_B&quot;); &#125; void buildRoof() &#123; this-&gt;house-&gt;setRoof(&quot;Roof_B&quot;); &#125; House *getHouse() &#123; return this-&gt;house; &#125;&#125;;class Director &#123;public: Director() :builder(nullptr) &#123;&#125; ~Director() &#123; if (this-&gt;builder != nullptr) &#123; delete builder; builder = nullptr; &#125; &#125; void setBuilder(AbstractBuilder *iBuilder) &#123; this-&gt;builder = iBuilder; &#125; House *construct() &#123; builder-&gt;buildFloor(); builder-&gt;buildWall(); builder-&gt;buildRoof(); return builder-&gt;getHouse(); &#125;private: AbstractBuilder *builder;&#125;;int main()&#123; AbstractBuilder *builder; Director *director = new Director(); House *house; builder = new ConcreteBuilderA(); director-&gt;setBuilder(builder); house = director-&gt;construct(); house-&gt;printfHouseInfo(); delete builder; builder = new ConcreteBuilderB(); director-&gt;setBuilder(builder); house = director-&gt;construct(); house-&gt;printfHouseInfo(); delete director; return 0;&#125; 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;class IBuilder &#123;public: virtual ~IBuilder() &#123;&#125; virtual void makeTitle(const std::string &amp;title) = 0; virtual void makeString(const std::string &amp;str) = 0; virtual void makeItems(const std::vector&lt;std::string&gt; &amp;items) = 0; virtual void close() = 0;&#125;;class TextBuilder : public IBuilder &#123;public: void makeTitle(const std::string &amp;title) override &#123; m_str.append(&quot;============================\\n&quot;); m_str.append(&quot;[&quot; + title + &quot;]\\n&quot;); m_str.append(&quot;\\n&quot;); &#125; void makeString(const std::string &amp;str) override &#123; m_str.append(&quot; * &quot; + str + &quot;\\n&quot;); m_str.append(&quot;\\n&quot;); &#125; void makeItems(const std::vector&lt;std::string&gt; &amp;items) override &#123; for (auto item : items) &#123; m_str.append(&quot; . &quot; + item + &quot;\\n&quot;); &#125; m_str.append(&quot;\\n&quot;); &#125; void close() override &#123; m_str.append(&quot;============================\\n&quot;); &#125; std::string getResult() const &#123; return m_str; &#125;private: std::string m_str;&#125;;class Director &#123;public: Director(IBuilder *builder) : m_builder(builder) &#123;&#125; void construct() &#123; m_builder-&gt;makeTitle(&quot;Greeting&quot;); m_builder-&gt;makeString(u8&quot;从早上到下午&quot;); m_builder-&gt;makeItems(std::vector&lt;std::string&gt;&#123; u8&quot;早上好&quot;, u8&quot;下午好&quot; &#125;); m_builder-&gt;makeString(u8&quot;晚上&quot;); m_builder-&gt;makeItems(std::vector&lt;std::string&gt;&#123; u8&quot;晚上好&quot;, u8&quot;晚安&quot;, u8&quot;再见&quot; &#125;); m_builder-&gt;close(); &#125;private: IBuilder *m_builder;&#125;;int main()&#123; TextBuilder *builder = new TextBuilder; Director director(builder); director.construct(); std::string result = builder-&gt;getResult(); std::cout &lt;&lt; result &lt;&lt; std::endl; delete builder; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:02--抽象工厂模式","slug":"designPatter/设计模式-02-抽象工厂模式","date":"2022-10-15T14:11:56.000Z","updated":"2022-10-21T05:41:11.352Z","comments":true,"path":"2022/10/15/designPatter/设计模式-02-抽象工厂模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-02-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。 2、应用场景一系列相互依赖的对象有不同的具体实现。提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合。 3、UML 二、案例1、案例1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class AbstractBall &#123;public: virtual ~AbstractBall()&#123;&#125; AbstractBall()&#123;&#125; void play()&#123;&#125;;&#125;;class Basketball : public AbstractBall &#123;public: Basketball() &#123; play(); &#125; void play()&#123; printf(&quot;Jungle play Basketball\\n\\n&quot;); &#125;&#125;;class Football : public AbstractBall &#123;public: Football()&#123; play(); &#125; void play()&#123; printf(&quot;Jungle play Football\\n\\n&quot;); &#125;&#125;;class AbstractShirt &#123;public: virtual ~AbstractShirt()&#123;&#125; AbstractShirt()&#123;&#125; void wearShirt()&#123;&#125;;&#125;;class BasketballShirt :public AbstractShirt &#123;public: BasketballShirt()&#123; wearShirt(); &#125; void wearShirt()&#123; printf(&quot;Jungle wear Basketball Shirt\\n\\n&quot;); &#125;&#125;;class FootballShirt :public AbstractShirt &#123;public: FootballShirt()&#123; wearShirt(); &#125; void wearShirt()&#123; printf(&quot;Jungle wear Football Shirt\\n\\n&quot;); &#125;&#125;;class AbstractFactory &#123;public: virtual ~AbstractFactory()&#123;&#125; virtual AbstractBall *getBall() = 0; virtual AbstractShirt *getShirt() = 0;&#125;;class BasketballFactory :public AbstractFactory &#123;public: BasketballFactory()&#123; printf(&quot;BasketballFactory\\n&quot;); &#125; AbstractBall *getBall()&#123; printf(&quot;Jungle get basketball\\n&quot;); return new Basketball(); &#125; AbstractShirt *getShirt()&#123; printf(&quot;Jungle get basketball shirt\\n&quot;); return new BasketballShirt(); &#125;&#125;;class FootballFactory :public AbstractFactory &#123;public: FootballFactory()&#123; printf(&quot;FootballFactory\\n&quot;); &#125; AbstractBall *getBall()&#123; printf(&quot;Jungle get football\\n&quot;); return new Football(); &#125; AbstractShirt *getShirt()&#123; printf(&quot;Jungle get football shirt\\n&quot;); return new FootballShirt(); &#125;&#125;;int main()&#123; AbstractFactory *fac = NULL; AbstractBall *ball = NULL; AbstractShirt *shirt = NULL; fac = new BasketballFactory(); ball = fac-&gt;getBall(); shirt = fac-&gt;getShirt(); delete fac; delete ball; delete shirt; fac = new FootballFactory(); ball = fac-&gt;getBall(); shirt = fac-&gt;getShirt(); delete fac; delete ball; delete shirt; return 0;&#125; 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;class IItem &#123;public: virtual ~IItem() &#123;&#125; IItem(const std::string &amp;caption) : m_caption(caption) &#123;&#125; virtual std::string makeHTML() = 0;protected: std::string m_caption;&#125;;class ILink : public IItem &#123;public: virtual ~ILink() &#123;&#125; ILink(const std::string &amp;caption, const std::string &amp;url) : IItem(caption), m_url(url) &#123;&#125;protected: std::string m_url;&#125;;class ITray : public IItem &#123;public: virtual ~ITray() &#123;&#125; ITray(const std::string &amp;caption) : IItem(caption) &#123;&#125; void addItem(IItem *item) &#123; m_itemList.push_back(item); &#125;protected: std::vector&lt;IItem *&gt; m_itemList;&#125;;class ListTray : public ITray &#123;public: using ITray::ITray; std::string makeHTML() override &#123; std::string str; str.append(&quot;&lt;li&gt;\\n&quot;); str.append(m_caption + &quot;\\n&quot;); str.append(&quot;&lt;ul&gt;\\n&quot;); for (auto item : m_itemList) &#123; str.append(item-&gt;makeHTML()); &#125; str.append(&quot;&lt;/ul&gt;\\n&quot;); str.append(&quot;&lt;/li&gt;\\n&quot;); return str; &#125;&#125;;class ListLink : public ILink &#123;public: using ILink::ILink; std::string makeHTML() override &#123; return &quot;&lt;li&gt;&lt;a href=\\&quot;&quot; + m_url + &quot;\\&quot;&gt; &quot; + m_caption + &quot;&lt;/a&gt; &lt;/li&gt;\\n&quot;; &#125;&#125;;class IPage &#123;public: virtual ~IPage() &#123;&#125; IPage(const std::string &amp;title, const std::string &amp;author) : m_title(title), m_author(author) &#123;&#125; void addItem(IItem *item) &#123; m_itemList.push_back(item); &#125; void output() &#123; std::cout &lt;&lt; makeHTML() &lt;&lt; std::endl; &#125; virtual std::string makeHTML() = 0;protected: std::string m_title; std::string m_author; std::vector&lt;IItem *&gt; m_itemList;&#125;;class ListPage : public IPage &#123;public: using IPage::IPage; std::string makeHTML() override &#123; std::string str; str.append(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot; + m_title + &quot;&lt;/head&gt;&lt;/title&gt;\\n&quot;); str.append(&quot;&lt;body&gt;\\n&quot;); str.append(&quot;&lt;h1&gt;&quot; + m_title + &quot;&lt;/h1&gt;\\n&quot;); str.append(&quot;&lt;ul&gt;\\n&quot;); for (auto item : m_itemList) &#123; str.append(item-&gt;makeHTML()); &#125; str.append(&quot;&lt;/ul&gt;\\n&quot;); str.append(&quot;&lt;address&gt;&quot; + m_author + &quot;&lt;/address&gt;\\n&quot;); str.append(&quot;&lt;/body&gt;\\n&quot;); str.append(&quot;&lt;/html&gt;&quot;); return str; &#125;&#125;;class IFactory &#123;public: virtual ~IFactory() &#123;&#125; virtual ILink *createLink(const std::string &amp;caption, const std::string &amp;url) = 0; virtual ITray *createTray(const std::string &amp;caption) = 0; virtual IPage *createPage(const std::string &amp;title, const std::string &amp;author) = 0;&#125;;class IFactoryHelper &#123;public: static void registerFactory(const std::string &amp;name, std::function&lt;IFactory *()&gt; createCallback) &#123; s_createrMap.insert(std::make_pair(name, createCallback)); &#125; static IFactory *getFactory(const std::string &amp;name) &#123; auto itor = s_createrMap.find(name); return itor-&gt;second(); &#125;private: static std::unordered_map&lt;std::string, std::function&lt;IFactory *()&gt;&gt; s_createrMap;&#125;;std::unordered_map&lt;std::string, std::function&lt;IFactory *()&gt;&gt; IFactoryHelper::s_createrMap;class ListFactory : public IFactory &#123;public: ILink *createLink(const std::string &amp;caption, const std::string &amp;url) override &#123; return new ListLink(caption, url); &#125; ITray *createTray(const std::string &amp;caption) override &#123; return new ListTray(caption); &#125; IPage *createPage(const std::string &amp;title, const std::string &amp;author) override &#123; return new ListPage(title, author); &#125;&#125;;static int ListFactoryInit = []() -&gt; int &#123; std::cout &lt;&lt; &quot;1&quot; &lt;&lt; std::endl; IFactoryHelper::registerFactory(&quot;ListFactory&quot;, []() &#123; return new ListFactory; &#125;); return 0;&#125;();int main()&#123; std::shared_ptr&lt;IFactory&gt; factory(IFactoryHelper::getFactory(&quot;ListFactory&quot;)); assert(factory != nullptr); std::shared_ptr&lt;ILink&gt; people(factory-&gt;createLink(u8&quot;人民日报&quot;, u8&quot;http://www.people.com.cn/&quot;)); std::shared_ptr&lt;ILink&gt; gmw(factory-&gt;createLink(u8&quot;光明网&quot;, u8&quot;http://www.gmw.cn/&quot;)); std::shared_ptr&lt;ILink&gt; us_yahoo(factory-&gt;createLink(u8&quot;us_yahoo&quot;, u8&quot;http://www.yahoo.com/&quot;)); std::shared_ptr&lt;ILink&gt; jp_yahoo(factory-&gt;createLink(u8&quot;jp_yahoo&quot;, u8&quot;http://www.yahoo.com.jp/&quot;)); std::shared_ptr&lt;ILink&gt; google(factory-&gt;createLink(u8&quot;google&quot;, u8&quot;http://www.google.com&quot;)); std::shared_ptr&lt;ITray&gt; trayNews(factory-&gt;createTray(&quot;news&quot;)); trayNews-&gt;addItem(people.get()); trayNews-&gt;addItem(gmw.get()); std::shared_ptr&lt;ITray&gt; trayYahoo(factory-&gt;createTray(&quot;yahoo!&quot;)); trayYahoo-&gt;addItem(us_yahoo.get()); trayYahoo-&gt;addItem(jp_yahoo.get()); std::shared_ptr&lt;ITray&gt; traySearch(factory-&gt;createTray(&quot;traySearch&quot;)); trayYahoo-&gt;addItem(trayYahoo.get()); trayYahoo-&gt;addItem(google.get()); std::shared_ptr&lt;IPage&gt; page(factory-&gt;createPage(&quot;LinkPage&quot;, &quot;tao&quot;)); page-&gt;addItem(trayNews.get()); page-&gt;addItem(traySearch.get()); page-&gt;output(); return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:01--工厂方法模式","slug":"designPatter/设计模式-01-工厂方法模式","date":"2022-10-15T14:11:40.000Z","updated":"2022-10-21T05:40:31.403Z","comments":true,"path":"2022/10/15/designPatter/设计模式-01-工厂方法模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-01-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。 2、应用场景于需求的变化，一个类的子类经常面临着剧烈的变化，但他却拥有比较稳定的接口。使用一种封装机制来“隔离这种易变对象的变化”，工厂方法定义一个用于创建对象的接口，让子类来确定创建哪一个具体类的对象，将对象的实例化延迟。 3、UML 二、案例1、案例112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class AbstractSportProduct &#123;public: AbstractSportProduct() &#123;&#125; virtual ~AbstractSportProduct()&#123;&#125; void printName()&#123;&#125;; void play()&#123;&#125;;&#125;;class Basketball : public AbstractSportProduct &#123;public: Basketball()&#123; printName(); play(); &#125; void printName()&#123; printf(&quot;Jungle get Basketball\\n&quot;); &#125; void play()&#123; printf(&quot;Jungle play Basketball\\n&quot;); &#125;&#125;;class AbstractFactory &#123;public: virtual AbstractSportProduct *getSportProduct() = 0; virtual ~AbstractFactory()&#123;&#125;&#125;;class BasketballFactory : public AbstractFactory &#123;public: BasketballFactory() &#123; printf(&quot;BasketballFactory\\n&quot;); &#125; AbstractSportProduct *getSportProduct() &#123; printf(&quot;basketball&quot;); return new Basketball(); &#125;&#125;;int main()&#123; AbstractFactory *fac = NULL; AbstractSportProduct *product = NULL; fac = new BasketballFactory(); product = fac-&gt;getSportProduct(); if (fac) &#123; delete fac; &#125; if (product) &#123; delete product; &#125; return 0;&#125; 2、案例212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;class IProduct &#123;public: virtual ~IProduct() &#123;&#125; virtual void use() = 0;&#125;;class IDCard : public IProduct &#123;public: IDCard(const std::string &amp;owner) : m_owner(owner) &#123;&#125; void use() override &#123; std::cout &lt;&lt; &quot;use IDCare with owner&quot; &lt;&lt; m_owner &lt;&lt; std::endl; &#125;private: std::string m_owner;&#125;;class IFactory &#123;public: virtual ~IFactory() &#123;&#125; virtual void registerProduct(IProduct *) = 0; virtual IProduct *createProduct(const std::string &amp;owner) = 0; virtual IProduct *create(const std::string &amp;owner) &#123; auto *pro = createProduct(owner); registerProduct(pro); return pro; &#125;&#125;;class IDCareFactory : public IFactory &#123;public: IProduct *createProduct(const std::string &amp;owner) &#123; return new IDCard(owner); &#125; void registerProduct(IProduct *pro) &#123; m_productList.push_back(pro); &#125;private: std::vector&lt;IProduct *&gt; m_productList;&#125;;int main()&#123; IFactory *fac = new IDCareFactory; IProduct *pro = fac-&gt;create(&quot;tao&quot;); IProduct *pro2 = fac-&gt;create(&quot;tao2&quot;); pro-&gt;use(); pro2-&gt;use(); delete pro; delete fac; delete pro2; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++:06--function与bind及Lamda实现回调函数","slug":"C++/C-06-function与bind及Lamda实现回调函数","date":"2022-10-15T01:59:13.000Z","updated":"2022-10-16T01:41:46.766Z","comments":true,"path":"2022/10/15/C++/C-06-function与bind及Lamda实现回调函数/","link":"","permalink":"http://example.com/2022/10/15/C++/C-06-function%E4%B8%8Ebind%E5%8F%8ALamda%E5%AE%9E%E7%8E%B0%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","excerpt":"","text":"一、使用std::function作为函数入参1、基于传值的方式传递参数12#include &lt;functional&gt;void registerCallBack(std::function&lt;void()&gt;); 上面的代码实现了一个注册回调函数的机制，入参std::function&lt;void()&gt;是一个模板类对象， 它可以用一个函数签名为void()的可调用对象来进行初始化。 1234// 方法（A）registerCallBack([=]&#123; .... // 回调函数的实现部分&#125;) 这里使用了lambda表达式作为函数的入参，lambda表达式会生成一个匿名的闭包， 基于这个闭包构造了一个std::function&lt;void()&gt;的对象， 然后通过传值调用的方式把这个对象传递registerCallBack函数中使用。 2、基于引用的方式传递参数当然还可以如下实现这个注册函数，入参通过const引用的方式传递，这里的引用必须是const的， 这是因为调用registerCallBack函数的地方生成了一个临时的std::function()对象， 是一个右值，否则编译会报错。 123//方法(B)#include &lt;functional&gt;void registerCallBack(std::function&lt;void()&gt; const&amp;); 这传值和引用区别就在于，在registerCallBack函数内部怎么使用这个入参， 1) 如果只是简单的调用一下std::func()类，那么两种都没有问题，可能使用引用的效率更高； 2) 如果register函数内部需要保存这个std::func()，并用于以后使用，那么方法A直接保存没有问题， 方法B就必须做一次拷贝，否则方法B中，当临时的对象销毁时，有可能出现引用悬空的问题。 3、传值方式下的std::function对象保存如果要在registerCallBack函数内部保存传入的function对象，可以使用std::move，效率更高。 123456789class CallBackHolder &#123;public:void registerCallBack(std::function&lt;void()&gt; func) &#123; callback = std::move(func);&#125; private: std::function&lt;void()&gt; callback; &#125; 二、类的成员函数作为函数入参类的成员函数都会默认有个隐藏的this指针，所以不像普通的函数直接作为入参就可以了。 1、使用bind和function来实现1234567891011121314151617class classA &#123;typedef std::function&lt;void(int i)&gt; callback_t;... void registCb(callback_t func) &#123; cbHandle = std::move(func); &#125;private: callback_t cbHandle;&#125;;class classB &#123;public: classB(classA&amp; cA) &#123; cA.registCb(bind(&amp;classB::handle, this, placeholders::_1)); &#125;&#125;; 2、使用lambda表达式实现123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;class classA &#123;typedef std::function&lt;void(int i)&gt; callback_t;public: classA() &#123;&#125; ~classA() &#123;&#125; void handle(int i) &#123; std::cout &lt;&lt; &quot;classA::handle&quot; &lt;&lt; std::endl; cbHandle(i); &#125; void registCb(callback_t func) &#123;cbHandle = std::move(func);&#125;private: callback_t cbHandle;&#125;;class classB &#123;public: classB(classA&amp; cA) &#123; cA.registCb([this](int i)&#123;classB::handle(i);&#125;); &#125; ~classB() &#123;&#125; void handle(int i)&#123; std::cout &lt;&lt; &quot;classB, handle message&quot; &lt;&lt; i &lt;&lt; std::endl; &#125;&#125;;int main()&#123; classA testa; classB testb(testa); testa.handle(10);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:05--Lamda表达式使用场景","slug":"C++/C-05-Lamda表达式使用场景","date":"2022-10-14T06:54:13.000Z","updated":"2022-10-21T02:06:11.698Z","comments":true,"path":"2022/10/14/C++/C-05-Lamda表达式使用场景/","link":"","permalink":"http://example.com/2022/10/14/C++/C-05-Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"一、lamda表达式变量截取方式1、定义 1) 变量截取方式 2) Lambda表达式的参数列表 3) Mutable 标识 4) 异常标识 5) 返回值 6) “函数”体，也就是lambda表达式需要进行的实际操作 2、变量截取方式[] 不截取任何变量 [&amp;] 截取外部作用域中所有变量，并作为引用在函数体中使用 [&#x3D;] 截取外部作用域中所有变量，并拷贝一份在函数体中使用 [&#x3D;, &amp;foo]截取外部作用域中所有变量，并拷贝一份在函数体中使用，但是对foo使用引用 [bar] 截取bar变量并且拷贝一份在函数体重使用，同时不截取其他变量 [this] 截取当前类中的this指针。如果已经使用了&amp;或者&#x3D;就默认添加此选项 二、lamda表达式使用场景1、场景1简化写法。 //1.1vector数组求和 1234567891011int main()&#123; std::vector&lt;int&gt; some_list; int total = 0; for (int i = 0; i &lt; 5; ++i) some_list.push_back(i); for_each(begin(some_list), end(some_list), [&amp;total](int x) &#123;total += x;&#125;); return 0;&#125; //1.2vector数组排序 123456789101112int main(void)&#123; int data[6] = &#123; 3, 4, 12, 2, 1, 6 &#125;; vector&lt;int&gt; testdata; testdata.insert(testdata.begin(), data, data + 6); // 排序算法 sort(testdata.begin(), testdata.end(), [](int a, int b) &#123; return a &gt; b; &#125;); return 0;&#125; 2、场景2以前类中开启线程都需要通过静态成员函数，现在通过Lambda表达式， 在中括号[this]中可以直接访问到类中的成员变量。 123456789101112131415161718192021222324class A&#123;public: A(); ~A();//析构private: std::unique_ptr&lt;std::thread&gt; monitorThread; int a;&#125;;A::A()&#123; monitorThread = make_unique&lt;thread&gt;([this] &#123; while (true) &#123; cout &lt;&lt; &quot;i can access a &quot; &lt;&lt; a++ &lt;&lt; endl; Sleep(100); &#125; &#125;);&#125;A::~A()&#123;&#125; 3、场景3回调函数实现 123456789101112131415161718192021222324252627class MathCallBack &#123; int ops1,ops2; int result;public: void Add(int a,int b, function&lt;void (int)&gt; func) &#123; ops1 = abs(a); ops2 = abs(b); result = ops1+ops2; func(result); &#125;&#125;;int main()&#123; MathCallBack math; int c1 = 0; math.Add(1, 3, [&amp;c1](int result) -&gt; void &#123; printf(&quot;result = %d\\n&quot;, result); c1 = result; &#125;); printf(&quot;c1 = %d\\n&quot;, c1); return 0;&#125; lambda表达式可以以引用方式捕获上下文中的变量，达到回调的效果。 4、更多参考例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364vector&lt; int&gt; vec;/* 1. simple lambda */ auto it = std::find_if(vec.begin(), vec.end(), [](int i) &#123; return i &gt; 50; &#125;); class A &#123; public: bool operator(int i) const &#123; return i &gt; 50; &#125; &#125;;auto it = std::find_if(vec.begin(), vec.end(), A()); /* 2. lambda return syntax */ function&lt;int(int)&gt; square = [](int i) -&gt; int &#123;return i * i;&#125; /* 3. lambda expr: capture of local variable */ &#123; int min_val = 10; int max_val = 1000; auto it = find_if(vec.begin(), vec.end(), [=](int i) &#123;return i &gt; min_val &amp;&amp; i &lt; max_val;&#125;); auto it = find_if(vec.begin(), vec.end(), [&amp;](int i) &#123;return i &gt; min_val &amp;&amp; i &lt; max_val;&#125;); auto it = find_if(vec.begin(), vec.end(), [=, &amp;max_value](int i) &#123;return i &gt; min_val &amp;&amp; i &lt; max_val;&#125;); &#125; /* 4. lambda expr: capture of class member */ class A &#123; public: void DoSomething(); private: std::vector&lt;int&gt; m_vec; int m_min_val; int m_max_va; &#125;; /* 4.1 capture member by this */ void A::DoSomething() &#123; auto it = find_if(m_vec.begin(), m_vec.end(), [this](int i)&#123; return i &gt; m_min_val &amp;&amp; i &lt; m_max_val;&#125;); &#125; /* 4.2 capture member by default pass-by-value */ void A::DoSomething() &#123; auto it = find_if(m_vec.begin(), m_vec.end(), [=](int i)&#123; return i &gt; m_min_val &amp;&amp; i &lt; m_max_val; &#125;); &#125; /* 4.3 capture member by default pass-by-reference */ void A::DoSomething() &#123; auto it = find_if(m_vec.begin(), m_vec.end(), [&amp;](int i)&#123; return i &gt; m_min_val &amp;&amp; i &lt; m_max_val;&#125;); &#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:04--std::function和std::bind的用法","slug":"C++/C-04-std-function和std-bind的用法","date":"2022-10-14T06:26:43.000Z","updated":"2022-10-16T01:41:35.186Z","comments":true,"path":"2022/10/14/C++/C-04-std-function和std-bind的用法/","link":"","permalink":"http://example.com/2022/10/14/C++/C-04-std-function%E5%92%8Cstd-bind%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"一、std::function的用法1、保存自由函数123456789void printA(int a)&#123; cout &lt;&lt; a &lt;&lt; endl;&#125;std::function&lt;void(int a)&gt; func;func = printA;func(2); 2、保存lamda表达式12std::function&lt;void()&gt; func_1 = []()&#123;cout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl;&#125;;func_1(); 3、保存函数对象12345678910class CStudent&#123;public: void operator() (string strName, int nAge) &#123; cout &lt;&lt; strName &lt;&lt; &quot; : &quot; &lt;&lt; nAge &lt;&lt; endl; &#125;&#125;;CStudent stu;function&lt;void (string, int)&gt; f = stu;f(&quot;Mike&quot;, 12); 4、保存成员函数1234567891011121314struct Foo &#123; Foo(int num) : num_(num) &#123;&#125; void print_add(int i) const &#123; cout &lt;&lt; num_+i &lt;&lt; &#x27;\\n&#x27;; &#125; int num_;&#125;;int main()&#123; std::function&lt;void(const Foo&amp;, int)&gt; f_add_display = &amp;Foo::print_add; Foo foo(2); f_add_display(foo, 1); return 0;&#125; 在实际使用中都用 auto 关键字来代替std::function… 这一长串了 一、std::bind的用法1、用法案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859using namespace std;class A &#123;public: void fun_3(int k, int m) &#123; cout&lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; endl; &#125;&#125;;void fun(int x, int y, int z)&#123; cout&lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; z &lt;&lt; endl;&#125;void fun_2(int &amp;a, int &amp;b)&#123; a++; b++; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;&#125;int main(int argc, const char * argv[])&#123; /* 表示绑定函数fun的第一，二，三个参数值为： 1 2 3 */ auto f1 = std::bind(fun,1,2,3); f1(); //print:1 2 3 /* 前两个形参为占位符，调用时确定，第三个为3 */ auto f2 = std::bind(fun, placeholders::_1, placeholders::_2, 3); f2(1, 2); //print:1 2 3 /* 前两个形参为占位符，调用时确定，第三个为3 */ auto f3 = std::bind(fun, placeholders::_2, placeholders::_1, 3); /* 注意： f2和f3的区别 */ f3(1, 2); //print:2 1 3 int n = 2; int m = 3; auto f4 = std::bind(fun_2, n, placeholders::_1); f4(m); //print: 3 4 /* 打印4，说明bind通过std::placeholders传递的参数是通过引用传递的 */ cout &lt;&lt; m &lt;&lt; endl; /* 打印2，说明：bind对于预先绑定的函数参数是通过值传递的 */ cout &lt;&lt; n &lt;&lt; endl; A a; auto f5 = std::bind(&amp;A::fun_3, a, placeholders::_1, placeholders::_2); f5(10, 20); //print:10 20 std::function&lt;void(int,int)&gt; fc = bind(&amp;A::fun_3, a, placeholders::_1, placeholders::_2); fc(10,20); //print:10 20 return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:03--多级混合继承、虚基类","slug":"C++/C-03-多级混合继承、虚基类","date":"2022-10-13T10:26:35.000Z","updated":"2022-10-16T01:41:28.862Z","comments":true,"path":"2022/10/13/C++/C-03-多级混合继承、虚基类/","link":"","permalink":"http://example.com/2022/10/13/C++/C-03-%E5%A4%9A%E7%BA%A7%E6%B7%B7%E5%90%88%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%9F%BA%E7%B1%BB/","excerpt":"","text":"一、多级混合继承1、例子1234567891011121314151617181920212223242526272829303132//菱形继承class A &#123;public: int data;&#125;;class B : public A &#123;public: int data;&#125;;class C : public A &#123;public: int data;&#125;;class D : public B, public C &#123;public: int data;&#125;;int main()&#123; D c; D.data=1; D.B::data=2;//访问B中的 D.C.::data=3;//访问C中的 D.B::A::data=4;//访问B继承的A D.C::A::data=5;//访问C继承的A D.A::data=4;//错误，产生二义性，不知道是B、C中哪一个&#125; 2、内存大小 3、内存图解 一、虚基类1、概念1) 也称虚继承、菱形继承。用于多级混合继承时，保留一个虚基类。 2) 构造顺序 先构造虚基类，如果有多个虚基类，按声明（从左至右）依次构造; 再构造基类，如果有多个基类，按声明（从左至右）依次构造; 如果有子对象，再构造子对像，如果有多个子对象，按声明的顺序（从上至下）依次构造; 最后构造自己。 2、例子1234567891011121314151617181920212223242526272829303132class A &#123;public: A(int data)&#123;&#125;//1 int data;&#125;;class B : virtual public A &#123;public: B():A(1)&#123;&#125;//2 int data;&#125;;class C : virtual public A &#123;public: C() : A(2)&#123;&#125;//3 int data;&#125;;class D : public B, public C &#123;public: D() : A(3)&#123;&#125;//4 int data;&#125;;int main() &#123; D d; d.data=1; d.B::data=2; d.C::data=3; d.B::A.data=4; d.C::A::data=5;&#125; 1) 构造顺序为：1-2-3-4 2) 构造顺序解释：构造类D对象d的时候，发现继承于B，于是去构造B， 构造B的时候，发现继承于虚基类A，于是构造虚基类A，接着构造B。 再接着构造C，发现C继承于虚基类A，但发现虚基类A已经被B构造过了， 所以不再构造A，直接构造C。最后构造D。 3) 如果虚基类构造函数为带参构造，则其子类，以及子类拓展出来的子类， 都要在成员初始化列表对其进行构造函数的初始化。 4) d的data赋值为1，继承于B、C，分别赋值为2,3，顺序为从左至右。 A的值本来为4，后来执行到最后一行的时候被赋值为5 3、内存大小 4、内存图解","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:02--成员变量初始化方式","slug":"C++/C-02-成员变量初始化方式","date":"2022-10-13T08:58:08.000Z","updated":"2022-10-30T13:55:09.488Z","comments":true,"path":"2022/10/13/C++/C-02-成员变量初始化方式/","link":"","permalink":"http://example.com/2022/10/13/C++/C-02-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/","excerpt":"","text":"一、成员变量3种初始化方式1) 在构造函数体内赋值初始化 2) 在自定义的公有函数体中赋值初始化（一般用于成员变量的初始化） 3) 在构造函数的成员初始化列表初始化 二、构造函数体内初始化1、说明在构造函数体内的初始化方式，本质是是为成员变量赋值，而不是真正意义上的初始化。 2、案例1234567891011class Cperson &#123;public: Cperson(int age, float height) &#123; m_age = age; m_height = height; &#125;private: int m_age; float m_height;&#125; 三、自定义的公有函数体中赋值初始化1、说明与构造函数体内初始化方式一样，此种方式本质上也是赋值，而不是初始化。 2、案例1234567891011class Cperson &#123;public: void setPerson(int age, float height) &#123; m_age = age; m_height = height; &#125;private: int m_age; float m_height;&#125; 四、成员初始化列表初始化1、说明1) 写在构造函数的后面，随着构造函数的执行而执行。 2) 初始化列表初始化优先于构造函数内的代码执行顺序。 3) 一般只对无动态内存的成员、const成员、引用初始化, 其中const成员、引用成员必须在初始化列表初始化。 4) 成员初始化列表初始化效率更高。 5) 有动态内存的成员必须在构造函数内部进行初始化。 2、案例1 (const成员、引用成员必须在初始化列表初始化)123456789101112131415class Person &#123;public: Person(int i);private: const int id; int&amp; m_id;&#125;;Person::Person(int i)&#123; id = i; //错误，const成员变量必须在成员初始化列表初始化 m_id = id; //错误，引用也必须在成员初始化列表初始化&#125; 3、案例2 (成员初始化列表初始化效率更高)1234567891011class Word&#123;public: Word()&#123; _name=0; //先创建一个临时string对象，赋值为0，然后拷贝给_name _cnt=0; //构造函数结束之后，临时对象析构释放 &#125;private: string _name; int _cnt;&#125;; 但是如果使用下面的成员初始化列表初始化，那么就省去了创建临时对象再拷贝的过程 12345678 class Word&#123; public: Word() :_name(0),_cnt(0)&#123;&#125; //直接初始化_name，不创建临时对象 private: string _name; int _cnt;&#125;; 五、总结1) 成员初始化列表初始化成员才是真正意义上的初始化，其他两种方式都是为赋值。 2) 初始化是直接初始化。而赋值是先初始化一个临时变量，再赋值。前者效率高。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:01--this指针","slug":"C++/C-01-this指针","date":"2022-10-13T08:09:26.000Z","updated":"2022-10-16T01:41:16.814Z","comments":true,"path":"2022/10/13/C++/C-01-this指针/","link":"","permalink":"http://example.com/2022/10/13/C++/C-01-this%E6%8C%87%E9%92%88/","excerpt":"","text":"一、this指针应用1、剖析1) 对于类成员函数而言，并不是一个对象对应一个单独的成员函数体，而是此类的所有对象共用这个成员函数体。 当程序被编译之后，此成员函数地址已经确定。 1) 调用类的成员函数时，会将当前对象的this指针传递给成员函数，然后在函数体内对类的数据成员访问时， 就会被转换为“this-&gt;数据成员”的形式。 1) 如果成员函数内部没有访问对象的任何数据成员，那么传进来的this指针实际没有任何用处， 这样的函数与全局函数并没有太大区别。 &amp;nbsp; 2、案例11234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class MyClass &#123;public: int data; MyClass(int data) &#123; this-&gt;data = data; &#125; void print() &#123; //cout&lt;&lt; data &lt;&lt; endl; cout &lt;&lt; &quot;hello!&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; MyClass *pMyClass; pMyClass = new MyClass(1); pMyClass-&gt;print(); pMyClass[0].print(); pMyClass[1].print(); pMyClass[10000000].print(); return 0;&#125; 程序输出如下： 结果分析： 1) 此处我们创建了一个对象，但是访问后面越界之后仍然可以访问成功。 2) 如果一个成员函数没有操作任何类的数据成员，因此这个成员函数与全局函数类型，调用之后都会打印“hello!”。 &amp;nbsp; 3、案例21234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class MyClass &#123;public: int data; MyClass(int data) &#123; this-&gt;data = data; &#125; void print() &#123; cout&lt;&lt; data &lt;&lt; endl; cout &lt;&lt; &quot;hello!&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; MyClass *pMyClass; pMyClass = new MyClass(1); pMyClass-&gt;print(); pMyClass[0].print(); pMyClass[1].print(); pMyClass[10000000].print(); return 0;&#125; 程序输出如下： 结果分析： 1) 此处我们的成员函数访问了类的数据成员，那么每次打印数据时都会通过this指针调用。 2) 但是此处我们只创建了一个对象，所以当调用pMyClass[1]和pMyClass[10000000]越界了，找不到对象，从而报错。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ubuntu搭建Qt4Android的开发环境","slug":"android/ubuntu搭建Qt4Android的开发环境","date":"2022-09-29T05:45:30.000Z","updated":"2024-10-25T01:20:52.355Z","comments":true,"path":"2022/09/29/android/ubuntu搭建Qt4Android的开发环境/","link":"","permalink":"http://example.com/2022/09/29/android/ubuntu%E6%90%AD%E5%BB%BAQt4Android%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"一、软件版本选择1234android-studio: android-studio-2020.3.1.26-linux.tar.gzandroid-sdk: android-sdk_r24.4.1-linux.tgzandroid-ndk: android-ndk-r19c-linux-x86_64.zipQt: 5.12.8 二、安装软件1、安装jdk123456sudo apt install -y openjdk-8-jdkvi /etc/profileexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64export PATH=$PATH:$&#123;JAVA_HOME&#125;/binsource /etc/profile 2、安装sdk解压并运行android-studio, 将sdk、tool等下载到一个空的文件夹android-sdk下 解压android-sdk_r24.4.1-linux.tgz并赋值其目录下的tools到android-sdk下 3、解压ndk解压 android-ndk-r19c-linux-x86_64.zip 4、设置交叉编译","categories":[{"name":"Qt4Android","slug":"Qt4Android","permalink":"http://example.com/categories/Qt4Android/"}],"tags":[{"name":"Qt4Android","slug":"Qt4Android","permalink":"http://example.com/tags/Qt4Android/"}]},{"title":"ubuntu安装VNC-无需显示屏","slug":"ubuntu/ubuntu安装VNC-无需显示屏","date":"2022-09-28T06:35:13.000Z","updated":"2022-10-16T03:33:52.097Z","comments":true,"path":"2022/09/28/ubuntu/ubuntu安装VNC-无需显示屏/","link":"","permalink":"http://example.com/2022/09/28/ubuntu/ubuntu%E5%AE%89%E8%A3%85VNC-%E6%97%A0%E9%9C%80%E6%98%BE%E7%A4%BA%E5%B1%8F/","excerpt":"","text":"一、安装1、安装VNC1234sudo apt-get install x11vnc –y/* generate password */sudo x11vnc -storepasswd /etc/x11vnc.pass 2、启动VNC1sudo x11vnc -display :0 -auth /var/run/lightdm/root/:0 -forever -bg -o /var/log/x11vnc.log -rfbauth /etc/x11vnc.pass -rfbport 5901 一、配置无显示器访问1、生成配置文件1234sudo Xorg :1 –configure/* 此时会在root路径下生成xorg.conf.new文件 */cp /root/xorg.conf.new /usr/share/X11/xorg.conf.d/xorg.conf 2、安装虚拟显卡驱动1sudo apt install xserver-xorg-video-dummy 3、添加虚拟显卡配置1234567891011121314151617181920212223242526272829sudo vi /usr/share/X11/xorg.conf.d/xorg.conf/* 在文件最后添加以下内容 */Section &quot;Monitor&quot; Identifier &quot;Monitor1&quot; HorizSync 1.0 - 2000.0 VertRefresh 1.0 - 200.0 # Add 16:9 modes, others are automatically detected. Modeline &quot;1280x720&quot; 74.48 1280 1336 1472 1664 720 721 724 746 Modeline &quot;1920x1080&quot; 172.80 1920 2040 2248 2576 1080 1081 1084 1118EndSectionSection &quot;Device&quot; Identifier &quot;Card1&quot; Driver &quot;dummy&quot; VideoRam 256000EndSection Section &quot;Screen&quot; DefaultDepth 24 Identifier &quot;Screen1&quot; Device &quot;Card1&quot; Monitor &quot;Monitor1&quot; SubSection &quot;Display&quot; Depth 24 Modes &quot;1920x1080&quot; EndSubSectionEndSection 4、虚拟与真实显示器同时工作配置修改步骤3中的配置文件最上面的ServerLayout: 12345Section &quot;ServerLayout&quot; Identifier &quot;X.org Configured&quot; Screen 0 &quot;Screen0&quot; 0 0 Screen 1 &quot;Screen1&quot; 0 0EndSection","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"树莓派3B+xenomai+igh","slug":"servoCtrl/树莓派3B-xenomai-igh","date":"2022-09-28T05:42:02.000Z","updated":"2022-10-16T03:34:20.236Z","comments":true,"path":"2022/09/28/servoCtrl/树莓派3B-xenomai-igh/","link":"","permalink":"http://example.com/2022/09/28/servoCtrl/%E6%A0%91%E8%8E%93%E6%B4%BE3B-xenomai-igh/","excerpt":"","text":"一、源码包准备1、安装依赖软件1sudo apt install git bc bison flex libssl-dev make 2、源码版本12345git clone https://github.com/raspberrypi/linux.gitgit checkout rpi-4.1.ygit clone http://git.xenomai.org/xenomai-3.git/git checkout v3.0.2 二、实时内核移植1、打实时补丁12345cd xenomai-3scripts/prepare-kernel.sh --linux=../linux/ --arch=arm --ipipe=./kernel/cobalt/arch/arm/patches/ipipe-core-4.1.18-arm-4.patchcd ../linuxcat ../patch-xenomai-3-on-bcm-2709.patch | patch -p1 2、配置内核123456789101112131415161718make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfigmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig/* config linux kernel with the following options */CPU Power Management ---&gt;CPU Frequency scaling ---&gt; [ ] CPU Frequency scalingCPU idle ---&gt; [ ] CPU idle PM supportKernel Features ---&gt; [ ] Contiguous Memory Allocator [ ] Allow for memory compactionKernel Hacking ---&gt; [ ] KGDB: kernel debuggerBoot options ---&gt; Kernel command line type ---&gt; [X] Extend bootloader kernel arguments 3、编译内核及模块1234make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs -j20mkdir modulesmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- INSTALL_MOD_PATH=modules modules_install 4、安装到系统123456cp arch/arm/boot/zImage /media/$&#123;USER&#125;/bootcp arch/arm/boot/dts/bcm2710-rpi-3-b.dtb /media/$&#123;USER&#125;/bootrm -rf /media/$&#123;USER&#125;/boot/overlays/*cp arch/arm/boot/dts/overlays/*.dtb* /media/$&#123;USER&#125;/boot/overlays/sudo cp -r linux/dist/lib/modules/* /media/$&#123;USER&#125;/$&#123;ROOTFS&#125;/lib/modules 5、修改系统启动项12kernel=$&#123;zImage name&#125;device_tree=bcm2710-rpi-3-b.dtb 三、安装xenomai1、配置123cd xenomai-3./scripts/bootstrap --with-core=cobalt –enable-debug=partial./configure CFLAGS=&quot;-march=armv7-a -mtune=cortex-a8 -mfloat-abi=hard -mfpu=neon -ffast-math&quot; --host=arm-linux-gnueabihf --target=arm-linux-gnueabihf --enable-smp 2、编译12mkdir targetmake DESTDIR=$&#123;PWD&#125;/target install 3、安装到系统1sudo cp -a target/* /media/$&#123;USER&#125;/$&#123;ROOTFS&#125;/ 三、安装IGH1、源码包123git clone https://gitlab.com/etherlab.org/ethercat.gitcd ethercatgit checkout stable-1.5 2、配置123mkdir etherlab./bootstrap./configure --prefix=$&#123;PWD&#125;/etherlab --with-linux-dir=$&#123;PWD&#125;/../linux --enable-8139too=no --enable-generic=yes CC=arm-linux-gnueabihf-gcc --host=arm-linux-gnueabihf 3、编译12make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- all modules -j20make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- install -j20 4、可能出现的问题及解决123issue: /usr/bin/ld: error: ethercat use VFP register arguments, ../master/soe_errors.o does notsolve: touch ~/ethercat/master/soe_errors.c 5、安装到系统123456789101112131415161718mkdir -p $&#123;PWD&#125;/etherlab/modulescp devices/ec_generic.ko etherlab/modules/cp master/ec_master.ko etherlab/modules/sudo cp -r etherlab/ /opt sudo ln -fs /opt/etherlab/etc/init.d/ethercat /etc/init.d/sudo ln -fs /opt/etherlab/bin/ethercat /usr/local/bin/sudo mkdir /etc/sysconfigsudo ln -fs /opt/etherlab/etc/sysconfig/ethercat /etc/sysconfig/sudo susudo echo KERNEL==\\&quot;EtherCAT[0-9]*\\&quot;, MODE=\\&quot;0664\\&quot; &gt; /etc/udev/rules.d/99-EtherCAT.rulesexitsudo cp /opt/etherlab/modules/ec_master.ko /lib/modules/4.14.91-rt49-v7+sudo depmodvi ~/.bashrcPATH=$PATH:/opt/etherlab/binsource ~/.bashrc 6、配置网卡123vi /etc/sysconfig/ethercatMASTER0_DEVICE=”b8:27:eb:7d:26:a2” //填写实际的MACDEVICE_MODULES=”generic” 7、启动igh1sudo /etc/init.d/ethercat start 6、测试经过测试发现igh1.5.2可以在pi3上运行，但是效果很差，代码运行后不能识别对应的pdo，原因待查找","categories":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]},{"title":"x86工控机安装igh","slug":"servoCtrl/x86工控机安装igh","date":"2022-09-27T13:51:31.000Z","updated":"2022-12-02T06:50:08.493Z","comments":true,"path":"2022/09/27/servoCtrl/x86工控机安装igh/","link":"","permalink":"http://example.com/2022/09/27/servoCtrl/x86%E5%B7%A5%E6%8E%A7%E6%9C%BA%E5%AE%89%E8%A3%85igh/","excerpt":"","text":"一、网卡驱动类型1、通用型优点: generic通用型的网卡驱动对物理网卡没有太多要求，只需要Linux系统支持其驱动， 就能在IGH的配置中将其选作网卡驱动。 缺点: 实时性较差，尤其是进行dc同步控制时表现更为明显。 2、本地型优点: native本地型网卡驱动是官方专门适配的几款Intel网卡，实时性方面有良好的保证 缺点: 只支持几款网卡 二、安装通用型网卡驱动1、下载源码包使用自己gitlab仓库里边的代码 2、配置123456cd path/to/ethercatMaster./bootstrapmkdir etherlab./configure --prefix=/home/huger/rtubuntu18/ethercat/etherlab --with-linux-dir=/home/huger/rtubuntu18/linux-4.9.38 --enable-generic=yes --enable-8139too=yes --enable-e1000=yes --enable-e1000e=yes --enable-r8169=yes --enable-rtdm=yes --enable-cycles=yes --enable-hrtimer=yes --with-xenomai-dir=/usr/xenomai configure中的路径需要根据本地实际路径修改 3、编译及安装1234make -j16make modules -j16make installsudo make modules_install 4、创建软连接12345678910111213mkdir -p ~/ethercat/etherlab/modulescp devices/ec_generic.ko etherlab/modules/cp master/ec_master.ko etherlab/modules/sudo cp -r etherlab/ /opt sudo ln -fs /opt/etherlab/etc/init.d/ethercat /etc/init.d/sudo ln -fs /opt/etherlab/bin/ethercat /usr/local/bin/sudo mkdir /etc/sysconfigsudo ln -fs /opt/etherlab/etc/sysconfig/ethercat /etc/sysconfig/sudo suecho KERNEL==\\&quot;EtherCAT[0-9]*\\&quot;, MODE=\\&quot;0664\\&quot; &gt; /etc/udev/rules.d/99-EtherCAT.rulesexitsudo cp /opt/etherlab/modules/ec_master.ko /lib/modules/4.9.51-xenomai3.1+sudo depmod 此步骤中的路径需要根据本地实际路径修改 5、配置网卡ifconfig 找出网卡的MAC地址 123sudo vi /etc/sysconfig/ethercatMASTER0_DEVICE=”b8:27:eb:7d:26:a2” //填写实际MACDEVICE_MODULES=”generic” 6、增加系统路径在~/.bashrc 末尾增加下面内容并source 12PATH=$PATH:/opt/etherlab/binsource ~/.bashrc 7、添加库文件供程序链接如果没有将xenomai的库添加到系统路径中，程序在链接的时候就会出现 error: while loading shared libraries... 解决： 123sudo vi /etc/ld.so.conf/usr/xenomai/lib //文件中增加这一行sudo ldconfig -v //使其生效 三、安装native型网卡驱动1、内核及igh源码版本的下载地址安装native型网卡驱动需要内核支持此网卡驱动， 最好的内核无疑是igh官方经过优化后的，下载地址如下 内核：https://source.denx.de/Xenomai/linux-dovetail branch选择 v5.10.y-dovetail igh源码： https://gitlab.com/etherlab.org/ethercat/-/tree/e1000e-5.10 branch选择 e1000e-5.10 xenomai选择3.2.1版本 2、Linux内核配置由于使用官方提供的内核，所以打补丁与另一篇搭建实时系统博客中的方法略有不同 12cd path/to/kernel../xenomai-v3.2.1/scripts/prepare-kernel.sh --arch=x86_64 Linux5.10的内核配置可以参考下面的附录，编译及安装过程与4.x内核移植 3、native型网卡配置12345cd path/to/ighsourceTree./scrip/bootstrapmkdir etherlab./configure --prefix=/home/huger/rtlinux/ethercat-e1000e-5.10/etherlab -enable-8139too=no -enable-e1000e=yes 4、编译及安装123make all modules -j16sudo make modules_install install -j16sudo depmod 5、创建软链接与通用型相同 6、配置网卡sudo vi /etc/sysconfig/ethercat MASTER0_DEVICE=”b8:27:eb:7d:26:a2” //填写实际MAC DEVICE_MODULES=”e1000e” 三、Linux5.10内核配置附录1234567891011121314151617181920212223242526272829303132333435363738394041424344Recommended options:* General setup --&gt; Local version - append to kernel release: -xenomai-3.0.5 --&gt; Timers subsystem --&gt; High Resolution Timer Support (Enable)* Xenomai/cobalt --&gt; Sizes and static limits --&gt; Number of registry slots (512 --&gt; 4096) --&gt; Size of system heap (Kb) (512 --&gt; 4096) --&gt; Size of private heap (Kb) (64 --&gt; 256) --&gt; Size of shared heap (Kb) (64 --&gt; 256) --&gt; Maximum number of POSIX timers per process (128 --&gt; 512) --&gt; Drivers --&gt; RTnet --&gt; RTnet, TCP/IP socket interface (Enable) --&gt; Drivers --&gt; New intel(R) PRO/1000 PCIe (Enable) --&gt; Realtek 8169 (Enable) --&gt; Loopback (Enable) --&gt; Add-Ons --&gt; Real-Time Capturing Support (Enable)* Power management and ACPI options --&gt; CPU Frequency scaling --&gt; CPU Frequency scaling (Disable) --&gt; ACPI (Advanced Configuration and Power Interface) Support --&gt; Processor (Disable) --&gt; CPU Idle --&gt; CPU idle PM support (Disable)* Pocessor type and features --&gt; Enable maximum number of SMP processors and NUMA nodes (Disable) // Ref : http://xenomai.org/pipermail/xenomai/2017-September/037718.html --&gt; Processor family --&gt; Core 2/newer Xeon (if &quot;cat /proc/cpuinfo | grep family&quot; returns 6, set as Generic otherwise) // Xenomai will issue a warning about CONFIG_MIGRATION, disable those in this order --&gt; Transparent Hugepage Support (Disable) --&gt; Allow for memory compaction (Disable) --&gt; Contiguous Memory Allocation (Disable) --&gt; Allow for memory compaction --&gt; Page Migration (Disable)* Device Drivers --&gt; Staging drivers --&gt; Unisys SPAR driver support --&gt; Unisys visorbus driver (Disable) ​","categories":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]},{"title":"x86工控机搭建ubuntu18+xenomai实时系统","slug":"servoCtrl/x86工控机搭建ubuntu18-xenomai实时系统","date":"2022-09-27T08:37:14.000Z","updated":"2022-10-16T03:34:15.764Z","comments":true,"path":"2022/09/27/servoCtrl/x86工控机搭建ubuntu18-xenomai实时系统/","link":"","permalink":"http://example.com/2022/09/27/servoCtrl/x86%E5%B7%A5%E6%8E%A7%E6%9C%BA%E6%90%AD%E5%BB%BAubuntu18-xenomai%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"一、安装系统及软件依赖1、系统选择选择安装 ubuntu18.04.6 LTS 2、软件依赖1sudo apt install libc6-dev libncurses5-dev libssl-dev build-essential bison flex lib32stdc++6 lib32z1 autoconf automake libtool pkg-config libelf-dev 3、软件版本及下载kernel: 4.9.38: https://mirrors.edge.kernel.org/pub/linux/kernel/ xenomai3.1及补丁: https://xenomai.org/downloads/ 二、配置内核1、打补丁123cd linux-4.9.38../xenomai-3.1/scripts/prepare-kernel.sh --arch=x86_64 --ipipe=ipipe-core-4.9.38-x86-3.patch 2、安装内核管理包1sudo apt install kernel-package 在弹出的界面中选择 “keep the local version…….” 3、配置kernel1make menuconfig 安装附录中的选项配置内核，去除xenomai相关的警告 4、去除编译错误1vi .config 找到SYSTEM_TRUSTED_KEYS将其赋值为空，使用#注释掉CONFIG_DEBUG_INFO_BTF 12SYSTEM_TRUSTED_KEYS=&quot;&quot;#CONFIG_DEBUG_INFO_BTF 5、编译内核1CONCURRENCY_LEVEL=$(nproc) make-kpkg --rootcmd fakeroot --initrd kernel_image kernel_headers 6、参考文档https://blog.csdn.net/qq_28882933/article/details/123626659?spm=1001.2014.3001.5502 三、安装新内核并修改grub1、安装内核编译完成后会在上一层目录生成对应的deb安装包 12cd ..sudo dpkg -i *.deb 2、增加非root用户123sudo addgroup xenomai --gid 1234sudo addgroup root xenomaisudo usermod -a -G xenomai $USER 3、查看当前系统下的所有可用内核1cat /boot/grub/grub.cfg | grep menuentry 记住刚才安装的实时内核下标号 4、修改grub启动项1sudo vi /etc/default/grub 倒数第二个选项，要在后面加命令行“xenomai.allowed_group=1234”即上步骤新增的组，具体修改如下: 5、更新grub12sudo update-grubsudo reboot 四、安装xenomai1、编译源文件1234567cd xenomai-3.1./configure --with-pic --with-core=cobalt --enable-smp --disable-tls --enable-dlopen-libs --disable-clock-monotonic-rawmake -j`nproc`sudo make install 2、配置系统路径12345678910111213echo &#x27;### Xenomaiexport XENOMAI_ROOT_DIR=/usr/xenomaiexport XENOMAI_PATH=/usr/xenomaiexport PATH=$PATH:$XENOMAI_PATH/bin:$XENOMAI_PATH/sbinexport PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$XENOMAI_PATH/lib/pkgconfigexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$XENOMAI_PATH/libexport OROCOS_TARGET=xenomai&#x27; &gt;&gt; ~/.xenomai_rcecho &#x27;source ~/.xenomai_rc&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc 3、实时性测试123sudo chmod -R 777 /dev/rtdm/memdev-privatesudo chmod -R 777 /dev/rtdm/memdev-sharedxeno latency 4、修改 lat best为负的方法123sudo suecho 0 &gt; /proc/xenomai/latencyxeno latency 运行一小段时间待其稳定后查看此时lat best 的数值, 将此数值乘1000 后重新echo 1echo value*1000 &gt; /proc/xenomai/latency 五、添加库文件供程序链接如果没有将xenomai的库添加到系统路径中，程序在链接的时候就会出现 error: while loading shared libraries... 解决： 123sudo vi /etc/ld.so.conf/usr/xenomai/lib //文件中增加这一行sudo ldconfig -v //使其生效 六、内核配置附录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 #进入menuconfig界面，会看影响xenomai实时性的警告信息：#*** WARNING! Page migration (CONFIG_MIGRATION) may increase ***#*** latency. ***#*** WARNING! At least one of APM, CPU frequency scaling, ACPI ‘processor‘ ***#*** or CPU idle features is enabled. Any of these options may ***#*** cause troubles with Xenomai. You should disable them. ***#具体配置如下所示： * General setup --&gt; Local version - append to kernel release: -xenomai-3.1 --&gt; Timers subsystem --&gt; High Resolution Timer Support (Enable) * Xenomai/cobalt --&gt; Sizes and static limits --&gt; Number of registry slots (512 --&gt; 4096) --&gt; Size of system heap (Kb) (512 --&gt; 4096) --&gt; Size of private heap (Kb) (64 --&gt; 256) --&gt; Size of shared heap (Kb) (64 --&gt; 256) --&gt; Maximum number of POSIX timers per process (128 --&gt; 512) --&gt; Drivers --&gt; RTnet --&gt; RTnet, TCP/IP socket interface (Enable) --&gt; Drivers --&gt; New intel(R) PRO/1000 PCIe (Enable) --&gt; Realtek 8169 (Enable) --&gt; Loopback (Enable) --&gt; Add-Ons --&gt; Real-Time Capturing Support (Enable) * Power management and ACPI options --&gt; CPU Frequency scaling --&gt; CPU Frequency scaling (Disable) --&gt; ACPI (Advanced Configuration and Power Interface) Support --&gt; Processor (Disable) --&gt; CPU Idle --&gt; CPU idle PM support (Disable) * Pocessor type and features --&gt; Enable maximum number of SMP processors and NUMA nodes (Disable) // Ref : http://xenomai.org/pipermail/xenomai/2017-September/037718.html --&gt; Processor family --&gt; Core 2/newer Xeon (if &quot;cat /proc/cpuinfo | grep family&quot; returns 6, set as Generic otherwise) // Xenomai will issue a warning about CONFIG_MIGRATION, disable those in this orde --&gt; Transparent Hugepage Support (Disable) --&gt; Allow for memory compaction (Disable) --&gt; Contiguous Memory Allocation (Disable) --&gt; Allow for memory compaction --&gt; Page Migration (Disable) * Device Drivers --&gt; Staging drivers --&gt; Unisys SPAR driver support --&gt; Unisys visorbus driver (Disable)","categories":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]},{"title":"ubuntu安装hexo踩坑","slug":"ubuntu/ubuntu安装hexo踩坑","date":"2022-09-27T07:04:27.000Z","updated":"2022-10-16T03:33:43.945Z","comments":true,"path":"2022/09/27/ubuntu/ubuntu安装hexo踩坑/","link":"","permalink":"http://example.com/2022/09/27/ubuntu/ubuntu%E5%AE%89%E8%A3%85hexo%E8%B8%A9%E5%9D%91/","excerpt":"","text":"软件问题导致无法安装HEXO现象及原因如果默认使用 1sudo apt install nodejs npm 系统会默认安装低版本的软件，然而在执行 1npm install -g hexo 会提示版本太低 解决123sudo apt install curlcurl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -sudo apt-get install -y nodejs 这就安装了高版本的软件，可以直接安装hexo. 部署到github上后网页乱码解决打开网址 http://ipaddress.com/ 右上角进行查找 assets-cdn.github.com，得到相应的IP 然后在 /etc/hosts中增加 185.199.109.153 assets-cdn.github.com 以实ip为准，如果一个ip无效，那么就多试其他ip","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]}],"categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://example.com/categories/OpenGL/"},{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"},{"name":"openCL","slug":"openCL","permalink":"http://example.com/categories/openCL/"},{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/categories/armLinux/"},{"name":"ISP","slug":"ISP","permalink":"http://example.com/categories/ISP/"},{"name":"gstreamer","slug":"gstreamer","permalink":"http://example.com/categories/gstreamer/"},{"name":"Qt","slug":"Qt","permalink":"http://example.com/categories/Qt/"},{"name":"Qt4Android","slug":"Qt4Android","permalink":"http://example.com/categories/Qt4Android/"},{"name":"cuda","slug":"cuda","permalink":"http://example.com/categories/cuda/"},{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"},{"name":"STM32","slug":"STM32","permalink":"http://example.com/categories/STM32/"},{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"},{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://example.com/tags/OpenGL/"},{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"},{"name":"openCL","slug":"openCL","permalink":"http://example.com/tags/openCL/"},{"name":"armLinux","slug":"armLinux","permalink":"http://example.com/tags/armLinux/"},{"name":"ISP","slug":"ISP","permalink":"http://example.com/tags/ISP/"},{"name":"gstreamer","slug":"gstreamer","permalink":"http://example.com/tags/gstreamer/"},{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"Qt4Android","slug":"Qt4Android","permalink":"http://example.com/tags/Qt4Android/"},{"name":"cuda","slug":"cuda","permalink":"http://example.com/tags/cuda/"},{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"},{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"},{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"},{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"},{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]}