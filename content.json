{"meta":{"title":"StephenLu`s Blog","subtitle":"Embedded Software Engineering","description":"","author":"Stephen Lu","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-09-27T07:44:47.000Z","updated":"2022-09-27T07:45:37.738Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-27T07:44:42.000Z","updated":"2022-09-27T07:45:26.354Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ubuntu20äº¤å‰ç¼–è¯‘jetson Nano Qt,åŒ…æ‹¬eglfs","slug":"ubuntu/ubuntu20äº¤å‰ç¼–è¯‘jetson-Nano-Qt-åŒ…æ‹¬eglfs","date":"2023-10-04T07:44:32.000Z","updated":"2023-10-14T10:54:39.539Z","comments":true,"path":"2023/10/04/ubuntu/ubuntu20äº¤å‰ç¼–è¯‘jetson-Nano-Qt-åŒ…æ‹¬eglfs/","link":"","permalink":"http://example.com/2023/10/04/ubuntu/ubuntu20%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91jetson-Nano-Qt-%E5%8C%85%E6%8B%ACeglfs/","excerpt":"","text":"ä¸€ã€äº‹å…ˆå‡†å¤‡1ã€ubuntu PC1) ä¸‹è½½Qt5.15.2æºç  2) ä¸‹è½½æ–‡ä»¶ç³»ç»Ÿ ç›´æ¥æ–°å»ºä¸€ä¸ªsysrootç©ºç›®å½•å³å¯ï¼Œç­‰ä¼šå†åŒæ­¥æ¿å­çš„åº“æ–‡ä»¶ 2ã€jetson Nano1) å®‰è£…ä¾èµ–é€‰é¡¹ 1sudo apt-get install &#x27;.*libxcb.*&#x27; libxrender-dev libxi-dev libfontconfig1-dev libudev-dev 2) è½¯è¿æ¥opengl esåº“ 12sudo ln -s libGLESv2_nvidia.so.2 libGLESv2.so sudo ln -s libEGL_nvidia.so.0 libEGL.so äºŒã€ç¼–è¯‘åŠå®‰è£…1ã€åŒæ­¥æ–‡ä»¶ç³»ç»Ÿæ³¨æ„ï¼Œå¯ä»¥æŠŠusr å’Œlibçš„ç€æ•´ä¸ªç›®å½•éƒ½åŒæ­¥è¿‡æ¥ã€‚å¯ä»¥è§£å†³äº¤å‰ç¼–è¯‘çš„å¾ˆå¤šé—®é¢˜ã€‚ 12rsync -avz lufahai@192.168.10.201:/lib sysrootrsync -avz lufahai@192.168.10.201:/usr sysroot 2ã€ä¿®å¤æŸåçš„é“¾æ¥æ–‡ä»¶123wget https://raw.githubusercontent.com/Kukkimonsuta/rpi-buildqt/master/scripts/utils/sysroot-relativelinks.pychmod -x sysroot-relativelinks.py./sysroot-relativelinks.py sysroot æ–‡ä»¶å†…å®¹å¦‚ä¸‹: 12345678910111213141516171819202122232425262728293031323334#!/usr/bin/env pythonimport sysimport os# source: https://raw.githubusercontent.com/riscv/riscv-poky/master/scripts/sysroot-relativelinks.py# Take a sysroot directory and turn all the absolute symlinks and turn them into# relative ones such that the sysroot is usable within another system.if len(sys.argv) != 2: print(&quot;Usage is &quot; + sys.argv[0] + &quot;&lt;directory&gt;&quot;) sys.exit(1)topdir = sys.argv[1]topdir = os.path.abspath(topdir)def handlelink(filePath, subdir): link = os.readlink(filePath) if link[0] != &quot;/&quot;: return if link.startswith(topdir): return newLink = os.path.relpath(topdir+link, subdir) print(&quot;\\t%s replacing %s =&gt; %s&quot; % (filePath, link, newLink)) os.unlink(filePath) os.symlink(newLink, filePath)for subdir, dirs, files in os.walk(topdir): for file in files: filePath = os.path.join(subdir, file) if os.path.islink(filePath): handlelink(filePath, subdir) å°†ä¸Šé¢çš„æ–‡ä»¶ä¿å­˜åˆ°sysroot-relativelinks.pyï¼Œå¹¶ä¸”èµ‹äºˆ+xæƒé™å¦‚ä½•ä½¿ç”¨: 1./sysroot-relativelinks.py sysroot 3ã€ä¿®æ”¹QTé…ç½®æ–‡ä»¶ç”±äºqtæºç ä¸­æ²¡æœ‰ jetson Nanoè¿™ä¸ªdeviceé…ç½®æ–‡ä»¶ï¼Œä½¿ç”¨æ¯”è¾ƒç›¸è¿‘çš„tx1ä½œä¸ºé…ç½®ã€‚ä¿®æ”¹è¯¥é…ç½®æ–‡ä»¶: qt-everywhere-src-5.15.2&#x2F;qtbase&#x2F;mkspecs&#x2F;devices&#x2F;linux-jetson-tx1-g++&#x2F;qmake.confä¸»è¦æ˜¯æ·»åŠ é“¾æ¥åº“å’Œå¤´æ–‡ä»¶ï¼Œä»è€Œè¯†åˆ«openGLçš„ç›¸å…³åº“æ–‡ä»¶ï¼Œä¿®æ”¹å¦‚ä¸‹: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859## qmake configuration for the Jetson TK1 boards running Linux For Tegra## Note that this environment has been tested with X11 only.## A typical configure line might look like:# configure \\# -device linux-jetson-tk1-g++ \\# -device-option CROSS_COMPILE=/opt/nvidia/toolchains/tegra-4.8.1-nv/usr/bin/arm-cortex_a15-linux-gnueabi/arm-cortex_a15-linux-gnueabi- \\# -sysroot /opt/nvidia/l4t/targetfsinclude(../common/linux_device_pre.conf)QMAKE_INCDIR_POST += \\ $$[QT_SYSROOT]/usr/include \\ $$[QT_SYSROOT]/usr/include/aarch64-linux-gnu QMAKE_LIBDIR_POST += \\ $$[QT_SYSROOT]/usr/lib \\ $$[QT_SYSROOT]/lib/aarch64-linux-gnu \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu QMAKE_RPATHLINKDIR_POST += \\ $$[QT_SYSROOT]/usr/lib \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu/tegra \\ $$[QT_SYSROOT]/lib/aarch64-linux-gnu QMAKE_INCDIR_OPENGL[_ES2] += \\ $$[QT_SYSROOT]/include \\ $$[QT_SYSROOT]/include/EGL \\ $$[QT_SYSROOT]/include/GLES2 \\ $$[QT_SYSROOT]/include/GLES3 \\ $$[QT_SYSROOT]/include/KHR \\ $$[QT_SYSROOT]/usr/include \\ $$[QT_SYSROOT]/usr/include/EGL \\ $$[QT_SYSROOT]/usr/include/GLES2 \\ $$[QT_SYSROOT]/usr/include/GLES3 \\ $$[QT_SYSROOT]/usr/include/KHR QMAKE_LIBDIR_OPENGL[_ES2] += \\ $$[QT_SYSROOT]/lib/aarch64-linux-gnu/tegra \\ $$[QT_SYSROOT]/lib/aarch64-linux-gnu/tegra-egl \\ $$[QT_SYSROOT]/lib/aarch64-linux-gnu \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu/tegra \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu/tegra-egl \\ $$[QT_SYSROOT]/usr/lib/aarch64-linux-gnu QMAKE_LIBS_OPENGL[_ES2] += -lEGL -lGLESv2 DISTRO_OPTS += aarch64 COMPILER_FLAGS += -mtune=cortex-a57.cortex-a53 -march=armv8-a EGLFS_DEVICE_INTEGRATION = eglfs_x11 QMAKE_CXXFLAGS += -std=gnu++11QMAKE_CFLAGS_ISYSTEM=-Iinclude(../common/linux_arm_device_post.conf)load(qt_config) 3ã€é…ç½®åŠç¼–è¯‘è¿›å…¥Qtæºç ç›®å½•ï¼Œåˆ›å»ºbuildç›®å½•å¹¶åœ¨å…¶ä¸‹å»ºç«‹é…ç½®è„šæœ¬autoConfig.shæ ¹æ®å®é™…æƒ…å†µä¿®æ”¹è·¯å¾„ã€‚ 1234567891011121314151617181920212223../configure \\-prefix /home/lufahai/workspace/jetson/qt5.15.2 \\-extprefix /home/lufahai/workspace/jetson/qt5.15.2 \\-hostprefix /home/lufahai/workspace/jetson/hostQt5.15.2 \\-confirm-license \\-opensource \\-device-option CROSS_COMPILE=/opt/aarch64-linux-gcc/bin/aarch64-linux-gnu- \\-device linux-jetson-tx1-g++ \\-sysroot /home/lufahai/workspace/jetson/sysroot \\-opengl es2 \\-skip qtscript \\-skip wayland \\-skip qtwebengine \\-force-debug-info \\-skip qtdatavis3d \\-skip qtlocation \\-nomake examples \\-make libs -pkg-config -no-use-gold-linker -v \\-no-openssl -shared -release -pch -no-cups \\-no-glib -no-dbus -no-xcb \\-no-separate-debug-info \\-no-fontconfig \\-nomake tests -no-iconv -no-tslib é…ç½®å‡ºç°çš„ç»“æœå¦‚ä¸‹,ä¸»è¦æ˜¯openGLçš„é€‰é¡¹è¯†åˆ«ä¸ºyes 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248Build options: Mode ................................... release (with debug info) Optimize release build for size ........ no Building shared libraries .............. yes Using C standard ....................... C11 Using C++ standard ..................... C++17 Using ccache ........................... no Using new DTAGS ........................ yes Generating GDB index ................... no Relocatable ............................ yes Using precompiled headers .............. yes Using LTCG ............................. no Target compiler supports: NEON ................................. yes Build parts ............................ libsQt modules and options: Qt Concurrent .......................... yes Qt D-Bus ............................... no Qt D-Bus directly linked to libdbus .... no Qt Gui ................................. yes Qt Network ............................. yes Qt Sql ................................. yes Qt Testlib ............................. yes Qt Widgets ............................. yes Qt Xml ................................. yesSupport enabled for: Using pkg-config ....................... yes udev ................................... no Using system zlib ...................... yes Zstandard support ...................... noQt Core: DoubleConversion ....................... yes Using system DoubleConversion ........ no GLib ................................... no iconv .................................. no ICU .................................... yes Built-in copy of the MIME database ..... yes Tracing backend ........................ &lt;none&gt; Logging backends: journald ............................. no syslog ............................... no slog2 ................................ no PCRE2 .................................. yes Using system PCRE2 ................... noQt Network: getifaddrs() ........................... yes IPv6 ifname ............................ yes libproxy ............................... no Linux AF_NETLINK ....................... yes OpenSSL ................................ no Qt directly linked to OpenSSL ........ no OpenSSL 1.1 ............................ no DTLS ................................... no OCSP-stapling .......................... no SCTP ................................... no Use system proxies ..................... yes GSSAPI ................................. noQt Gui: Accessibility .......................... yes FreeType ............................... yes Using system FreeType ................ no HarfBuzz ............................... yes Using system HarfBuzz ................ yes Fontconfig ............................. no Image formats: GIF .................................. yes ICO .................................. yes JPEG ................................. yes Using system libjpeg ............... no PNG .................................. yes Using system libpng ................ no Text formats: HtmlParser ........................... yes CssParser ............................ yes OdfWriter ............................ yes MarkdownReader ....................... yes Using system libmd4c ............... no MarkdownWriter ....................... yes EGL .................................... yes OpenVG ................................. no OpenGL: Desktop OpenGL ....................... no OpenGL ES 2.0 ........................ yes OpenGL ES 3.0 ........................ yes OpenGL ES 3.1 ........................ yes OpenGL ES 3.2 ........................ yes Vulkan ................................. no Session Management ..................... yesFeatures used by QPA backends: evdev .................................. yes libinput ............................... no INTEGRITY HID .......................... no mtdev .................................. no tslib .................................. no xkbcommon .............................. no X11 specific: XLib ................................. yes XCB Xlib ............................. yes EGL on X11 ........................... yes xkbcommon-x11 ........................ noQPA backends: DirectFB ............................... no EGLFS .................................. yes EGLFS details: EGLFS OpenWFD ........................ no EGLFS i.Mx6 .......................... no EGLFS i.Mx6 Wayland .................. no EGLFS RCAR ........................... no EGLFS EGLDevice ...................... yes EGLFS GBM ............................ no EGLFS VSP2 ........................... no EGLFS Mali ........................... no EGLFS Raspberry Pi ................... no EGLFS X11 ............................ yes LinuxFB ................................ yes VNC .................................... yesQt Sql: SQL item models ........................ yesQt Widgets: GTK+ ................................... no Styles ................................. Fusion WindowsQt PrintSupport: CUPS ................................... noQt Sql Drivers: DB2 (IBM) .............................. no InterBase .............................. no MySql .................................. no OCI (Oracle) ........................... no ODBC ................................... no PostgreSQL ............................. no SQLite2 ................................ no SQLite ................................. yes Using system provided SQLite ......... no TDS (Sybase) ........................... noQt Testlib: Tester for item models ................. yesSerial Port: ntddmodm ............................... noQt SerialBus: Socket CAN ............................. yes Socket CAN FD .......................... yes SerialPort Support ..................... yesFurther Image Formats: JasPer ................................. no MNG .................................... no TIFF ................................... yes Using system libtiff ................. no WEBP ................................... yes Using system libwebp ................. noQt QML: QML network support .................... yes QML debugging and profiling support .... yes QML just-in-time compiler .............. yes QML sequence object .................... yes QML XML http request ................... yes QML Locale ............................. yesQt QML Models: QML list model ......................... yes QML delegate model ..................... yesQt Quick: Direct3D 12 ............................ no AnimatedImage item ..................... yes Canvas item ............................ yes Support for Qt Quick Designer .......... yes Flipable item .......................... yes GridView item .......................... yes ListView item .......................... yes TableView item ......................... yes Path support ........................... yes PathView item .......................... yes Positioner items ....................... yes Repeater item .......................... yes ShaderEffect item ...................... yes Sprite item ............................ yesQtQuick3D: Assimp ................................. yes System Assimp .......................... noQt Scxml: ECMAScript data model for QtScxml ...... yesQt Gamepad: SDL2 ................................... noQt 3D: Assimp ................................. yes System Assimp .......................... no Output Qt3D GL traces .................. no Use SSE2 instructions .................. no Use AVX2 instructions .................. no Aspects: Render aspect ........................ yes Input aspect ......................... yes Logic aspect ......................... yes Animation aspect ..................... yes Extras aspect ........................ yesQt 3D Renderers: OpenGL Renderer ........................ yes RHI Renderer ........................... noQt 3D GeometryLoaders: Autodesk FBX ........................... noQt Bluetooth: BlueZ .................................. no BlueZ Low Energy ....................... no Linux Crypto API ....................... no Native Win32 Bluetooth ................. no WinRT Bluetooth API (desktop &amp; UWP) .... no WinRT advanced bluetooth low energy API (desktop &amp; UWP) . noQt Sensors: sensorfw ............................... noQt Quick Controls 2: Styles ................................. Default Fusion Imagine Material UniversalQt Quick Templates 2: Hover support .......................... yes Multi-touch support .................... yesQtXmlPatterns: XML schema support ..................... yesQt Multimedia: ALSA ................................... yes GStreamer 1.0 .......................... yes GStreamer 0.10 ......................... no Video for Linux ........................ yes OpenAL ................................. no PulseAudio ............................. no Resource Policy (libresourceqt5) ....... no Windows Audio Services ................. no DirectShow ............................. no Windows Media Foundation ............... noQt TextToSpeech: Flite .................................. no Flite with ALSA ........................ no Speech Dispatcher ...................... noQt Tools: Qt Assistant ........................... yes Qt Designer ............................ yes Qt Distance Field Generator ............ yes kmap2qmap .............................. yes Qt Linguist ............................ yes Mac Deployment Tool .................... no makeqpf ................................ yes pixeltool .............................. yes qdbus .................................. yes qev .................................... yes Qt Attributions Scanner ................ yes qtdiag ................................. yes qtpaths ................................ yes qtplugininfo ........................... yes Windows deployment tool ................ no WinRT Runner Tool ...................... noQt Tools: QDoc ................................... no æ¥ç€å°±å¯ä»¥ make -j16 &amp;&amp; make install 4ã€éƒ¨ç½²å°†ç¼–è¯‘å¹¶å®‰è£…åçš„qt5.15.2æ”¾åˆ°jetson Nanoä¸­ï¼Œå¹¶ä¿®æ”¹&#x2F;etc&#x2F;profileé…ç½®ç¯å¢ƒå˜é‡æ ¹æ®å®é™…æƒ…å†µä¿®æ”¹è·¯å¾„ 1234export QTDIR=/home/lufahai/qt5.15.2export LD_LIBRARY_PATH=$QTDIR/lib:$LD_LIBRARY_PATHexport QT_QPA_PLATFORM_PLUGIN_PATH=$QTDIR/pluginsexport QT_QPA_PLATFORM=eglfs 5ã€æµ‹è¯•QOpenGlæµ‹è¯•ä¾‹å­widget.hæ–‡ä»¶å¦‚ä¸‹ 12345678910111213141516171819202122232425262728#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QOpenGLShaderProgram&gt;#include &lt;QOpenGLFunctions&gt;#include &lt;QOpenGLWidget&gt;#include &lt;QPushButton&gt;class Widget : public QOpenGLWidget , public QOpenGLFunctions&#123; Q_OBJECTpublic: Widget(QWidget *parent = nullptr); ~Widget();protected: void initializeGL() override; void resizeGL(int w, int h) override; void paintGL() override;private: QPushButton *button;&#125;;#endif // WIDGET_H widget.cppæ–‡ä»¶å¦‚ä¸‹ 1234567891011121314151617181920212223242526272829303132333435#include &quot;widget.h&quot;#include &lt;QMessageBox&gt;Widget::Widget(QWidget *parent) : QOpenGLWidget(parent)&#123; button = new QPushButton(this); button-&gt;setGeometry(100, 100, 60, 40); button-&gt;setText(&quot;Button&quot;); connect(button, &amp;QPushButton::clicked, [this]() &#123; QMessageBox::information(this, &quot;Info&quot;, &quot;you have clicked this button&quot;); &#125;);&#125;Widget::~Widget()&#123; delete button;&#125;void Widget::initializeGL()&#123; this-&gt;initializeOpenGLFunctions();&#125;void Widget::resizeGL(int w, int h)&#123; glViewport(0.0f, 0.0f, w, h);&#125;void Widget::paintGL()&#123; glClearColor(1.0f, 1.0f, 0.0f, 0.0f); glClear(GL_COLOR_BUFFER_BIT);&#125; ç„¶åç›´æ¥åœ¨main.cppä¸­showå°±å¯ä»¥ ä¸‰ã€äº¤å‰ç¼–è¯‘åº“1ã€è§£å†³cudaäº¤å‰ç¼–è¯‘çš„ä½¿ç”¨äº¤å‰ç¼–è¯‘å‡ºçš„qtæ— æ³•ç›´æ¥ç¼–è¯‘cudaç¨‹åºï¼Œå¯ä»¥å†™ä¸€ä¸ªcmakeå°ç¨‹åºï¼Œåœ¨jetsonä¸Šå°†cudaç¨‹åºç¼–è¯‘æˆä¸€ä¸ªåŠ¨æ€åº“ï¼Œç„¶åQTç›´æ¥é“¾æ¥è¿™ä¸ªåº“å³å¯ã€‚æ ·ä¾‹:CmakeLists 1234567891011cmake_minimum_required(VERSION 3.10)project(CUDAProject)find_package(CUDA REQUIRED)set(CMAKE_CXX_COMPILER g++)set(CUDA_SOURCES cudaKernel.cu)set(CUDA_NVCC_FLAGS -arch=sm_30)include_directories(.)cuda_add_library(cudaKernel SHARED $&#123;CUDA_SOURCES&#125;) cudaç¨‹åº 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &quot;cuda_runtime.h&quot;#include &quot;device_launch_parameters.h&quot;#include &lt;stdio.h&gt;#include &lt;cuda.h&gt;#define NUM_THREAD_X 32#define NUM_THREAD_Y 8static int DivUp(int a, int b)&#123; return ((a % b) != 0) ? (a / b + 1) : (a / b);&#125;__global__ void cuConvert_Rgb10A2_Rgba8(unsigned int *pSrc, unsigned char *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride)&#123; const int dx = blockIdx.x * blockDim.x + threadIdx.x; const int dy = blockIdx.y * blockDim.y + threadIdx.y; if (dx &gt;= iWidth || dy &gt;= iHeight) &#123; return; &#125; int idxSrc = dy * iSrcStride + dx; int idxDst = dy * iDstStride + dx * 4; uint r = pSrc[idxSrc] &gt;&gt; 22; uint g = pSrc[idxSrc] &gt;&gt; 12 &amp; 1023; uint b = pSrc[idxSrc] &gt;&gt; 2 &amp; 1023; b = b &gt;&gt; 2; g = g &gt;&gt; 2; r = r &gt;&gt; 2; pDst[idxDst] = r; pDst[idxDst + 1] = g; pDst[idxDst + 2] = b; pDst[idxDst + 3] = 255;&#125;extern &quot;C&quot;void Convert_Rgb10A2_Rgba8(unsigned int *pSrc, unsigned char *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride)&#123; dim3 numThreads(NUM_THREAD_X, NUM_THREAD_Y, 1); dim3 numBlocks(DivUp(iWidth, numThreads.x), DivUp(iHeight, numThreads.y)); cuConvert_Rgb10A2_Rgba8&lt;&lt;&lt;numBlocks, numThreads&gt;&gt;&gt;(pSrc, pDst, iWidth, iHeight, iSrcStride, iDstStride);&#125;__global__ void cuConvert_16UC3_Rgb10A2(unsigned short *pSrc, unsigned int *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride)&#123; const int dx = blockIdx.x * blockDim.x + threadIdx.x; const int dy = blockIdx.y * blockDim.y + threadIdx.y; if (dx &gt;= iWidth || dy &gt;= iHeight) &#123; return; &#125; int idxSrc = dy * iSrcStride + dx * 3; int idxDst = dy * iDstStride + dx; uint r = pSrc[idxSrc] &gt;&gt; 6; uint g = pSrc[idxSrc + 1] &gt;&gt; 6; uint b = pSrc[idxSrc + 2] &gt;&gt; 6; pDst[idxDst] = r &lt;&lt; 22 | g &lt;&lt; 12 | b &lt;&lt; 2 | 3;&#125;extern &quot;C&quot;void Convert_16UC3_Rgb10A2(unsigned short *pSrc, unsigned int *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride)&#123; dim3 numThreads(NUM_THREAD_X, NUM_THREAD_Y, 1); dim3 numBlocks(DivUp(iWidth, numThreads.x), DivUp(iHeight, numThreads.y)); cuConvert_16UC3_Rgb10A2&lt;&lt;&lt;numBlocks, numThreads&gt;&gt;&gt;(pSrc, pDst, iWidth, iHeight, iSrcStride, iDstStride);&#125;__global__ void cuConvert_16UC3_Rgba8(unsigned short *pSrc, unsigned char *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride)&#123; const int dx = blockIdx.x * blockDim.x + threadIdx.x; const int dy = blockIdx.y * blockDim.y + threadIdx.y; if (dx &gt;= iWidth || dy &gt;= iHeight) &#123; return; &#125; int idxSrc = dy * iSrcStride + dx * 3; int idxDst = dy * iDstStride + dx * 4; pDst[idxDst] = pSrc[idxSrc] &gt;&gt; 8; pDst[idxDst + 1] = pSrc[idxSrc + 1] &gt;&gt; 8; pDst[idxDst + 2] = pSrc[idxSrc + 2] &gt;&gt; 8; pDst[idxDst + 3] = 255;&#125;extern &quot;C&quot;void Convert_16UC3_Rgba8(unsigned short *pSrc, unsigned char *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride)&#123; dim3 numThreads(16, 16, 1); dim3 numBlocks(DivUp(iWidth, numThreads.x), DivUp(iHeight, numThreads.y)); cuConvert_16UC3_Rgba8&lt;&lt;&lt;numBlocks, numThreads&gt;&gt;&gt;(pSrc, pDst, iWidth, iHeight, iSrcStride, iDstStride);&#125; å¤´æ–‡ä»¶ 1234567891011121314#ifndef CUDAKERNEL_H#define CUDAKERNEL_H#include &lt;stdio.h&gt;#include &quot;cuda_runtime.h&quot;#include &quot;device_launch_parameters.h&quot;extern &quot;C&quot; &#123;void Convert_Rgb10A2_Rgba8(unsigned int *pSrc, unsigned char *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride);void Convert_16UC3_Rgb10A2(unsigned short *pSrc, unsigned int *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride);void Convert_16UC3_Rgba8(unsigned short *pSrc, unsigned char *pDst, int iWidth, int iHeight, int iSrcStride, int iDstStride);&#125;#endif","categories":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"æ ‘è“æ´¾ç³»ç»Ÿå®šåˆ¶åŒ–","slug":"ubuntu/æ ‘è“æ´¾ç³»ç»Ÿå®šåˆ¶åŒ–","date":"2023-09-17T08:21:33.000Z","updated":"2023-09-17T12:18:32.978Z","comments":true,"path":"2023/09/17/ubuntu/æ ‘è“æ´¾ç³»ç»Ÿå®šåˆ¶åŒ–/","link":"","permalink":"http://example.com/2023/09/17/ubuntu/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6%E5%8C%96/","excerpt":"","text":"è‡ªå¯åŠ¨Xorgå›¾å½¢ç•Œé¢å®‰è£…qt512sudo apt-get install qtbase5-dev qtchooser qt5-qmake qtbase5-dev-tools libqt5serialport5-dev qml-module-qtquick-controls2 qtdeclarative5-dev å®‰è£…xorg1sudo apt instll xserver-xorg xinit x11-xserver-utils è‡ªå¯åŠ¨å›¾å½¢ç•Œé¢åŠç¨‹åºä½¿ç”¨raspi-configè®¾ç½®console auto loginåœ¨homeç›®å½•åˆ›å»º.bash_profileè„šæœ¬å¹¶èµ‹äºˆå¯æ‰§è¡Œæƒé™ï¼Œå½“ç”¨æˆ·ä»ttyç»ˆç«¯ç™»é™†æ—¶ï¼Œè¯¥è„šæœ¬ä¼šè¢«è‡ªåŠ¨æ‰§è¡Œã€‚è„šæœ¬å†…å®¹å¦‚ä¸‹ï¼šxset s off è¡¨ç¤ºå±è”½ä¼‘çœ xset -dpms è¡¨ç¤ºå…³é—­ç”µæºç®¡ç† 123if [ -z &quot;$DISPLAY&quot; ] &amp;&amp; [ -n &quot;$XDG_VTNR&quot; ] &amp;&amp; [ &quot;$XDG_VTNR&quot; -eq 1 ]; then startx -- -novtswitch -sharevts -nocursor :0 2&gt;/dev/nullfi å¯åŠ¨åº”ç”¨ç¨‹åºåœ¨homeç›®å½•åˆ›å»º.xinitrcæ–‡ä»¶ï¼Œå¹¶èµ‹äºˆå¯æ‰§è¡Œæƒé™ã€‚å½“xinitæ‰§è¡Œæ‰§è¡ŒæˆåŠŸå.xinitrc ä¼šè¢«è‡ªåŠ¨æ‰§è¡Œï¼Œå¯åœ¨è¿™ä¸ªè„šæœ¬ä¸­å¯åŠ¨åº”ç”¨ç¨‹åºã€‚åœ¨å¯åŠ¨QT ç¨‹åºä¹‹å‰ å…ˆè¦æ‰§è¡Œä¸‹é¢æŒ‡ä»¤ï¼Œå±è”½ä¼‘çœ å’Œç”µæºç®¡ç† 123xset s off -dpms -display :0/path/to/qtApp -display :0 å±è”½ç³»ç»Ÿä¿¡æ¯å±è”½é¢œè‰²æ£€æµ‹1sudo nano /boot/config.txt åœ¨æœ€åæ·»åŠ ï¼š disable_splash&#x3D;1 å±è”½åˆå§‹åŒ–ä¸­çš„ä»£ç æµæ˜¾ç¤º1sudo nano /boot/cmdline.txt ä¸»è¦æ˜¯æŠŠtty1æ”¹ä¸ºtty3ï¼Œä»¥åŠå¢åŠ logo.nologo loglevel&#x3D;3 ä¿®æ”¹å¦‚ä¸‹ï¼š 1dwc_otg.lpm_enable=0 console=tty3 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait quiet splash plymouth.ignore-serial-consoles logo.nologo loglevel=3 disable_overscan=1 è®¾ç½®å¯åŠ¨å±å¹•12sudo apt-get install fbisudo nano /etc/systemd/system/splashscreen.service åœ¨æ‰“å¼€çš„æ–‡ä»¶ä¸­å¡«å…¥ä¸€ä¸‹å†…å®¹ 12345678910[Unit]Description=SplashscreenDefaultDependencies=noAfter=basic.target[Service]ExecStart=/usr/bin/fbi -d /dev/fb0 --noverbose -a /path/to/logo.pngStandardInput=ttyStandardOutput=tty[Install]WantedBy=sysinit.target ä½¿å…¶ç”Ÿæ•ˆï¼š 1systemctl enable splashscreen å±è”½consoleç™»å½•ä¿¡æ¯åªéœ€åœ¨homeç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ªç©ºæ–‡ä»¶ 1touch .hushlogin å±è”½è‡ªåŠ¨ç™»å½•æ—¶å‡ºç°çš„æç¤ºsudo nano &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;&#x67;&#x65;&#116;&#116;&#x79;&#x40;&#116;&#116;&#121;&#x31;&#x2e;&#115;&#101;&#x72;&#118;&#x69;&#99;&#101;&#x2e;&#x64;&#x2F;autologin.conf 123[Service]ExecStart=ExecStart=-/sbin/agetty --autologin proxinse --noissue --noclear --nohostname --nohints %I $TERM è½¯å¼€å…³æœºåœ¨ &#x2F;boot&#x2F;config.txt æœ«å°¾å¢åŠ ï¼šdtoverlay&#x3D;gpio-shutdown ç„¶åBCM GPIO3(ä¹Ÿå°±æ˜¯SCL1) çš„å¼•è„šä¸GNDçŸ­æ¥å°±èƒ½å¼€å…³æœºã€‚ å¦‚ä½•å±è”½Boot Diagnosticsè¿™ä¸ªè¯Šæ–­ä¿¡æ¯æ˜¯å†™åœ¨EEPROMä¸­åˆ°ï¼Œå› æ­¤éœ€è¦ä¿®æ”¹é…ç½®ï¼Œç›´æ¥æ‰§è¡Œ 1sudo -E rpi-eeprom-config --edit æ‰§è¡Œåæ‰“å¼€åˆ°æ–‡ä»¶å¦‚ä¸‹ï¼Œç›´æ¥æŠŠDISABLE_HDMI&#x3D;0æ”¹ä¸ºDISABLE_HDMI&#x3D;1å¹¶ä¸”æŒ‰ç…§nanoæ–¹å¼ä¿å­˜é€€å‡ºå³å¯ã€‚å¦‚ä¸‹ï¼š 12345678910[all]BOOT_UART=0WAKE_ON_GPIO=1POWER_OFF_ON_HALT=0DHCP_TIMEOUT=45000DHCP_REQ_TIMEOUT=4000TFTP_FILE_TIMEOUT=30000ENABLE_SELF_UPDATE=1DISABLE_HDMI=1BOOT_ORDER=0xf41","categories":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"debianå¤šæ˜¾å¡è‡ªå®šä¹‰å›¾å½¢ç•Œé¢","slug":"ubuntu/debianå¤šæ˜¾å¡è‡ªå®šä¹‰å›¾å½¢ç•Œé¢","date":"2023-09-17T05:34:54.000Z","updated":"2023-09-17T05:35:58.215Z","comments":true,"path":"2023/09/17/ubuntu/debianå¤šæ˜¾å¡è‡ªå®šä¹‰å›¾å½¢ç•Œé¢/","link":"","permalink":"http://example.com/2023/09/17/ubuntu/debian%E5%A4%9A%E6%98%BE%E5%8D%A1%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/","excerpt":"","text":"å®‰è£…debian12åŠNvidiaé©±åŠ¨å®‰è£…linux headerså®‰è£…Nvidiaé©±åŠ¨éœ€è¦ä¾èµ–linux-headers 123sudo apt install linux-headers-$(uname -r)sudo apt install build-essential ç¦ç”¨nouveaué©±åŠ¨å¿…é¡»å…ˆç¦ç”¨nouveaué©±åŠ¨æ‰èƒ½å®‰è£…Nvidiaé©±åŠ¨ 1sudo nano /etc/modprobe.d/blacklist.conf æ–°å¢ä»¥ä¸‹ä¸¤è¡Œï¼š 12blacklist nouveauoptions nouveau modeset=0 æ›´æ–°å†…æ ¸é…ç½®ä½¿å…¶ç”Ÿæ•ˆ 123sudo update-initramfs -ureboot å®‰è£…Nvidiaé©±åŠ¨åªæœ‰terminalç»ˆç«¯æ‰èƒ½è£…Nvidiaé©±åŠ¨ï¼Œå› æ­¤å…ˆé€€å‡ºç™»å½• 123sudo telinit 3sudo ./NVIDIA-Linux-x86_64-530.30.02.run æ ¹æ®æç¤ºå®‰è£…å³å¯ï¼Œç„¶åå†å®‰è£…cuda 1sudo ./cuda_12.1.0_530.30.02_linux.run å…³é—­æ¡Œé¢ç³»ç»ŸåŠç”¨æˆ·è‡ªåŠ¨ç™»å½•å…³é—­æ¡Œé¢ç³»ç»Ÿ1sudo systemctl set-default multi-user.target å¦‚æœæƒ³è¦æ¢å¤æ¡Œé¢ç³»ç»Ÿå°±æ‰§è¡Œï¼š 1sudo systemctl set-default graphical.target æ–°å»ºç”¨æˆ·ç³»ç»Ÿå¯åŠ¨åéœ€è¦ä¸¤ä¸ªç‹¬ç«‹ç”¨æˆ·å„è‡ªæ ¹æ®ä¸åŒçš„é…ç½®æ–‡ä»¶ï¼Œåˆ†åˆ«å¯åŠ¨intelé›†æ˜¾å’ŒNvidiaæ˜¾å¡çš„XorgæœåŠ¡ã€‚æŒ‰ç…§å¦‚ä¸‹æ–¹å¼æ–°å¢ç”¨æˆ·ï¼š 1sudo useradd -d &quot;/home/stephen&quot; -m -s &quot;/bin/bash&quot; stephen åˆå§‹åŒ–å¯†ç  1sudo passwd stephen åŠ å…¥ç›¸å…³çš„ç»„ 12sudo usermod -aG sudo stephensudo usermod -aG video stephen è¦æƒ³å¯åŠ¨xorgæœåŠ¡å¿…é¡»åŠ å…¥videoç»„ è‡ªåŠ¨ç™»å½•æ–°å¢é…ç½®æ–‡ä»¶ 12sudo mkdir /etc/systemd/system/getty@tty1.service.dsudo nano /etc/systemd/system/getty@tty1.service.d/override.conf åœ¨æ‰“å¼€çš„æ–‡ä»¶ä¸­å¡«å…¥ä»¥ä¸‹å†…å®¹ï¼š 1234[Service]ExecStart=ExecStart=-/sbin/agetty --noissue --autologin stephenLu %I $TERMType=idle åŒç†ä¸ºæ–°å¢çš„stephenç”¨æˆ·å¢åŠ é…ç½®æ–‡ä»¶ 12sudo mkdir /etc/systemd/system/getty@tty2.service.dsudo nano /etc/systemd/system/getty@tty2.service.d/override.conf åœ¨æ‰“å¼€çš„æ–‡ä»¶ä¸­å¡«å…¥ä»¥ä¸‹å†…å®¹ï¼š 12345[Service][Service]ExecStart=ExecStart=-/sbin/agetty --noissue --autologin stephen %I $TERMType=idle å¼€å¯è‡ªåŠ¨ç™»å½•æœåŠ¡ 12sudo systemctl enable getty@tty1.servicesudo systemctl enable getty@tty2.service å¯åŠ¨Xorgåœ¨&#x2F;home&#x2F;stephenLuç›®å½•åˆ›å»º.bash_profileè„šæœ¬å¹¶èµ‹äºˆå¯æ‰§è¡Œæƒé™ï¼Œå½“ç”¨æˆ·ä»ttyç»ˆç«¯ç™»é™†æ—¶ï¼Œè¯¥è„šæœ¬ä¼šè¢«è‡ªåŠ¨æ‰§è¡Œã€‚è„šæœ¬å†…å®¹å¦‚ä¸‹ï¼š 123if [ -z &quot;$DISPLAY&quot; ] &amp;&amp; [ -n &quot;$XDG_VTNR&quot; ] &amp;&amp; [ &quot;$XDG_VTNR&quot; -eq 1 ]; then xinit -- -config xorg.conf.touch -novtswitch -sharevts -layout Touch :0 vt1 &gt;/dev/null 2&gt;&amp;1fi å³è„šæœ¬ä½¿ç”¨xinit æ ¹æ® xorg.conf.touchè¿™ä¸€é…ç½®æ–‡ä»¶ä¸ºintelé›†æ˜¾è§¦æ‘¸å±å¯åŠ¨xorgæœåŠ¡ï¼Œè¦ä¿è¯ xorg.conf.touchå­˜æ”¾äº&#x2F;etc&#x2F;X11 ç›®å½•ä¸‹ åŒç†åœ¨&#x2F;home&#x2F;proxç›®å½•ä¸‹ä¹Ÿåˆ›å»º.bash_profileè„šæœ¬ï¼Œå†…å®¹å¦‚ä¸‹ï¼š 123if [ -z &quot;$DISPLAY&quot; ] &amp;&amp; [ -n &quot;$XDG_VTNR&quot; ] &amp;&amp; [ &quot;$XDG_VTNR&quot; -eq 2 ]; then xinit -- -config xorg.conf.main -novtswitch -sharevts -nocursor -layout Main :1fi å¯åŠ¨åº”ç”¨ç¨‹åºåœ¨&#x2F;home&#x2F;stephenLuç›®å½•åˆ›å»º.xinitrcæ–‡ä»¶ï¼Œå¹¶èµ‹äºˆå¯æ‰§è¡Œæƒé™ã€‚å½“xinitæ‰§è¡Œæ‰§è¡ŒæˆåŠŸå.xinitrc ä¼šè¢«è‡ªåŠ¨æ‰§è¡Œï¼Œå¯åœ¨è¿™ä¸ªè„šæœ¬ä¸­å¯åŠ¨åº”ç”¨ç¨‹åºã€‚ stephenLuç”¨æˆ·homeç›®å½•ä¸‹çš„.xinitrcè„šæœ¬å†…å®¹å¦‚ä¸‹ï¼š 123456DISPLAY_NO=0xset -display :$DISPLAY_NO -dpms &amp; # disable DPMS (Energy Star) featuresxset -display :$DISPLAY_NO s off &amp; # disable screensaverxset -display :$DISPLAY_NO s noblank &amp; # don&#x27;t blank the video devicewhile sleep 1h; do echo &quot;first xorg is aliving...&quot;; done stephenç”¨æˆ·homeç›®å½•ä¸‹çš„.xinitrcè„šæœ¬å†…å®¹å¦‚ä¸‹ï¼š 123456DISPLAY_NO=1xset -display :$DISPLAY_NO -dpms &amp; # disable DPMS (Energy Star) featuresxset -display :$DISPLAY_NO s off &amp; # disable screensaverxset -display :$DISPLAY_NO s noblank &amp; # don&#x27;t blank the video devicewhile sleep 1h; do echo &quot;second xorg is aliving...&quot;; done POST-INSTALLè‡ªå®šä¹‰å¼€æœºæŒ‰é’®é¦–å…ˆå±è”½é»˜è®¤çš„å¼€æœºæŒ‰é”®åŠŸèƒ½ï¼š 1sudo nano /etc/systemd/logind.conf æ‰¾åˆ°HandlePowerKey&#x3D;ignoreï¼Œå–æ¶ˆå‰é¢çš„#å·æ³¨é‡Šï¼Œèµ‹å€¼ä¸º ignore å®‰è£…acpidï¼š 12sudo apt install acpidsudo systemctl enable acpid ç„¶åé…ç½®è‡ªå®šä¹‰çš„æŒ‰é”®æŒ‡ä»¤ï¼š 1sudo nano /etc/acpi/events/powerbtn-acpi-support æŠŠactioné€‰é¡¹æ”¹ä¸ºæ‰€éœ€è¦å®šä¹‰çš„è„šæœ¬ã€‚ å±è”½å¼€æœºlogodebian12 é»˜è®¤ä½¿ç”¨emeraldä½œä¸ºç³»ç»Ÿä¸»é¢˜ï¼Œå¼€æœºçš„æ—¶å€™ä¼šæ˜¾ç¤ºlogoï¼Œä¿®æ”¹å¦‚ä¸‹ï¼šé¦–å…ˆæ›´æ”¹ä¸»é¢˜ï¼š 1sudo nano /etc/plymouth/plymouthd.conf å–æ¶ˆæ–‡ä»¶å†…çš„é€‰é¡¹æ³¨é‡Šï¼Œå¹¶ä¸”å°†Themeèµ‹å€¼ä¸ºhomeworldï¼Œä¿®æ”¹ä¸»é¢˜æ˜¯éå¿…é¡»çš„æ­¥éª¤ï¼Œåªæ˜¯ç»è¿‡å¯¹æ¯”å‘ç°homeworldçš„é…ç½®æ–‡ä»¶æ–¹ä¾¿ä¿®æ”¹ã€‚å‡†å¤‡ä¸€å¼ logoçš„pngå›¾ç‰‡ï¼ŒæŠŠå®ƒå¤åˆ¶åˆ°&#x2F;usr&#x2F;share&#x2F;plymounth&#x2F;themes&#x2F;homeworld 1sudo nano /usr/share/plymounth/themes/homeworld/homeworld.script æ‰¾åˆ°bg_imageçš„èµ‹å€¼è¯­å¥ï¼ŒæŠŠåŸå…ˆçš„èƒŒæ™¯å›¾ç‰‡æ”¹ä¸ºåˆšæ‰å‡†å¤‡çš„logoåç§°ã€‚ ä¸ºäº†å±è”½æ‰æ‰€æœ‰debianç›¸å…³çš„ä¿¡æ¯ï¼Œå¯ä»¥åœ¨debian å’Œ logoç­‰Imageèµ‹å€¼å‚æ•°ï¼Œå†™å…¥ ä¸€ä¸ªé”™è¯¯çš„å›¾ç‰‡åç§°ï¼Œè¿™æ ·å°±ä¸ä¼šåŠ è½½logoå›¾ç‰‡ã€‚ä¾‹å¦‚ï¼š åŸå…ˆï¼šlogo &#x3D; Image(â€œlogo.pngâ€) ä¿®æ”¹ï¼šlogo &#x3D; Image(â€œlogo1.pngâ€) ä¿å­˜æ›´æ”¹ï¼š 1sudo update-initramfs -u é—®é¢˜è®°å½•è§¦æ‘¸å±èŠ±å±é—®é¢˜xorg.config.touchæ–‡ä»¶çš„Device Sectionä¸­ï¼Œå¦‚æœä¸æŒ‡å®š Option â€œaccelMethodâ€ï¼Œé‚£ä¹ˆä¼šé»˜ è®¤ä½¿ç”¨SNAä½œä¸ºåŠ é€Ÿæ–¹æ³•ï¼Œè¿™åœ¨æœ‰çš„è§¦æ‘¸å±ä¸Šæ˜¯OKçš„ã€‚ä½†æ˜¯å¯¹äºæŸäº›è§¦æ‘¸å±ï¼Œé»˜è®¤çš„SNAæ¯”è¾ƒè€ï¼Œintelå®˜æ–¹æ–‡æ¡£æ¨èä½¿ç”¨uxaä»£æ›¿SNAã€‚å› æ­¤åœ¨xorg.config.touch åº”è¯¥æŒ‡å®š Option â€œAccelMethodâ€ â€œuxaâ€è¿™ä¸ªè®¾å®šå¯ä»¥è§£å†³å¼¹å‡ºè™šæ‹Ÿé”®ç›˜æ—¶ï¼Œè§¦æ‘¸å±èŠ±å±çš„é—®é¢˜ã€‚ 12345678Section &quot;Device&quot; Identifier &quot;Device.Intel&quot; Driver &quot;intel&quot; BusID &quot;PCI:0:2:0&quot; Option &quot;monitor-eDP1&quot; &quot;Monitor.Touch&quot; Option &quot;TearFree&quot; &quot;true&quot; Option &quot;AccelMethod&quot; &quot;uxa&quot;EndSection","categories":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"ubuntu20ç¼–è¯‘4.9å†…æ ¸æ—¶é‡å®šå‘é”™è¯¯çš„è§£å†³","slug":"servoCtrl/ubuntu20ç¼–è¯‘4-9å†…æ ¸æ—¶é‡å®šå‘é”™è¯¯çš„è§£å†³","date":"2022-12-19T05:15:55.000Z","updated":"2022-12-19T05:20:35.873Z","comments":true,"path":"2022/12/19/servoCtrl/ubuntu20ç¼–è¯‘4-9å†…æ ¸æ—¶é‡å®šå‘é”™è¯¯çš„è§£å†³/","link":"","permalink":"http://example.com/2022/12/19/servoCtrl/ubuntu20%E7%BC%96%E8%AF%914-9%E5%86%85%E6%A0%B8%E6%97%B6%E9%87%8D%E5%AE%9A%E5%90%91%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3/","excerpt":"","text":"ä¸€ã€ç°è±¡RELOCS arch/x86/boot/compressed/vmlinux.relocs Unsupported relocation type: R_X86_64_PLT32 (4)ã€ äºŒã€è§£å†³æ‰‹åŠ¨ä¾æ¬¡ä¿®æ”¹ä»¥ä¸‹ä¸‰ä¸ªæ–‡ä»¶ arch/x86/kernel/machine_kexec_64.c arch/x86/kernel/module.c arch/x86/tools/relocs.c è§£å†³æ–¹æ³•éƒ½æ˜¯åœ¨è¿™ä¸‰ä¸ªæ–‡ä»¶çš„switchç›®å½•ä¸‹ï¼Œå¢åŠ å¯¹ R_X86_64_PLT32çš„æ”¯æŒ 12case R_X86_64_PC32:case R_X86_64_PLT32:","categories":[{"name":"ä¼ºæœæ§åˆ¶","slug":"ä¼ºæœæ§åˆ¶","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"ä¼ºæœæ§åˆ¶","slug":"ä¼ºæœæ§åˆ¶","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]},{"title":"ubuntuä½¿ç”¨Systembackå¤‡ä»½ç³»ç»Ÿ","slug":"ubuntu/ubuntuä½¿ç”¨Systembackå¤‡ä»½ç³»ç»Ÿ","date":"2022-12-01T02:41:25.000Z","updated":"2022-12-01T03:01:15.127Z","comments":true,"path":"2022/12/01/ubuntu/ubuntuä½¿ç”¨Systembackå¤‡ä»½ç³»ç»Ÿ/","link":"","permalink":"http://example.com/2022/12/01/ubuntu/ubuntu%E4%BD%BF%E7%94%A8Systemback%E5%A4%87%E4%BB%BD%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"ä¸€ã€å®‰è£…systembacké¦–å…ˆåˆ é™¤åŸæœ‰çš„PPA 1sudo add-apt-repository --remove ppa:nemh/systemback å¯¼å…¥æ­¤PPAçš„GPGç­¾åç§˜é’¥ 1sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 382003C2C8B7B4AB813E915B14E4942973C62A1B ç”±äºubuntu18æ²¡æœ‰systembackçš„ä¸‹è½½æºï¼Œå¯ä»¥ä½¿ç”¨Ubuntu16çš„ä¸‹è½½æº 1sudo add-apt-repository &quot;deb http://ppa.launchpad.net/nemh/systemback/ubuntu xenial main&quot; æ›´æ–°æº 12sudo apt updatesudo apt install systemback äºŒã€å¤‡ä»½ç³»ç»Ÿ ä¸‰ã€æ‰“åŒ…é•œåƒ1ã€ç³»ç»Ÿå°äº4Gç›´æ¥åœ¨è½¯ä»¶ä¸Šç”ŸæˆISOé•œåƒ 2ã€ç³»ç»Ÿå¤§äº4G1) è§£å‹ .sbliveæ–‡ä»¶ 12mkdir sblivetar -xf /home/systemback_live_2016-04-27.sblive -C sblive 2) é‡å‘½åæ–‡ä»¶ 12mv sblive/syslinux/syslinux.cfg sblive/syslinux/isolinux.cfgmv sblive/syslinux sblive/isolinux 3) å®‰è£…cdrtools 123456sudo gedit https://nchc.dl.sourceforge.net/project/cdrtools/alpha/cdrtools-3.02a07.tar.gztar -xzvf cdrtools-3.02a07.tar.gzcd cdrtools-3.02./configuremakesudo make install 4) ç”ŸæˆISOæ–‡ä»¶ 1/opt/schily/bin/mkisofs -iso-level 3 -r -V sblive -cache-inodes -J -l -b isolinux/isolinux.bin -no-emul-boot -boot-load-size 4 -boot-info-table -c isolinux/boot.cat -o sblive.iso sblive","categories":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"å°†STM32çš„JTAGå£(PA15,PB3,PB4)é…ç½®æˆgpio","slug":"stm32/å°†STM32çš„JTAGå£-PA15-PB3-PB4-é…ç½®æˆgpio","date":"2022-11-15T01:25:03.000Z","updated":"2022-11-15T01:37:24.242Z","comments":true,"path":"2022/11/15/stm32/å°†STM32çš„JTAGå£-PA15-PB3-PB4-é…ç½®æˆgpio/","link":"","permalink":"http://example.com/2022/11/15/stm32/%E5%B0%86STM32%E7%9A%84JTAG%E5%8F%A3-PA15-PB3-PB4-%E9%85%8D%E7%BD%AE%E6%88%90gpio/","excerpt":"","text":"ä¸€ã€å¯„å­˜å™¨ä»£ç 1234567RCC-&gt;APB2ENR|=1&lt;&lt;2; //ä½¿èƒ½PORTAæ—¶é’Ÿ RCC-&gt;APB2ENR |= RCC_APB2ENR_AFIOEN; AFIO-&gt;MAPR = AFIO_MAPR_SWJ_CFG_JTAGDISABLE; //å…³é—­JTAG é‡Šæ”¾å‡ºPB3,PB4,PA15GPIOA-&gt;CRH&amp;=0X0FFFFFFF; //A15GPIOA-&gt;CRH|=0X20000000; //2MHzé€šç”¨æ¨æŒ½è¾“å‡º GPIOA-&gt;ODR|=0&lt;&lt;15; //PA15 è¾“å‡ºä½ æ³¨æ„: 1) å¯¹å¯„å­˜å™¨AFIO_EVCRï¼ŒAFIO_MAPRå’ŒAFIO_EXTICRXè¿›è¡Œè¯»å†™æ“ä½œå‰ï¼Œåº”å½“å…ˆæ‰“å¼€AFIOçš„æ—¶é’Ÿ 2) å¿…é¡»ä»¥32ä½çš„æ–¹å¼æ“ä½œè¿™äº›å¤–è®¾å¯„å­˜å™¨ äºŒã€Halåº“ä»£ç 12RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOB, ENABLE);GPIO_PInRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE); ä¸‰ã€rtthreadè°ƒç”¨ä»£ç 12__HAL_RCC_AFIO_CLK_ENABLE();__HAL_AFIO_REMAP_SWJ_NOJTAG();","categories":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/categories/STM32/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}]},{"title":"Linuxé©±åŠ¨[å®è·µ]:15--ä½¿ç”¨å†…æ ¸ç°æœ‰é©±åŠ¨","slug":"linuxDrive/Linuxé©±åŠ¨-å®è·µ-15-ä½¿ç”¨å†…æ ¸ç°æœ‰é©±åŠ¨","date":"2022-11-01T07:18:24.000Z","updated":"2022-11-01T07:21:32.548Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-å®è·µ-15-ä½¿ç”¨å†…æ ¸ç°æœ‰é©±åŠ¨/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-15-%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E7%8E%B0%E6%9C%89%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[å®è·µ]","slug":"Linuxé©±åŠ¨-å®è·µ","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linuxé©±åŠ¨[å®è·µ]:14--PDDä¸è®¾å¤‡æ ‘","slug":"linuxDrive/Linuxé©±åŠ¨-å®è·µ-14-PDDä¸è®¾å¤‡æ ‘","date":"2022-11-01T07:18:05.000Z","updated":"2022-11-05T02:27:36.268Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-å®è·µ-14-PDDä¸è®¾å¤‡æ ‘/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-14-PDD%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91/","excerpt":"","text":"ä¸€ã€é©±åŠ¨-æ€»çº¿-è®¾å¤‡æ¨¡å‹1ã€åŠŸèƒ½èŒè´£1) é©±åŠ¨éƒ¨åˆ†ï¼šè´Ÿè´£å®ç°è®¾å¤‡çš„æ§åˆ¶é€»è¾‘åŠç”¨æˆ·æ¥å£ï¼Œå¹¶æ³¨å†Œåˆ°å†…æ ¸ 2) è®¾å¤‡éƒ¨åˆ†ï¼šè´Ÿè´£æè¿°è®¾å¤‡çš„ç¡¬ä»¶èµ„æºï¼Œå¹¶å‘ŠçŸ¥å†…æ ¸ 3) æ€»çº¿éƒ¨åˆ†ï¼šè´Ÿè´£å®ç°è®¾å¤‡ä¸é©±åŠ¨ä¹‹é—´çš„æ„ŸçŸ¥ã€è¯†åˆ«ã€åŒ¹é…è§„åˆ™ 2ã€æ ·ä¾‹platform_bus(å³æ€»çº¿éƒ¨åˆ†)å†…æ ¸å·²ç»å®ç°äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦å®ç°ä¸¤è¾¹çš„ platform_xxx_driverå’Œplatform_xxx_deviceå³å¯ï¼Œç„¶åæŠŠå®ƒä»¬æŒ‚åˆ°å¹³å°æ€»çº¿ä¸Šå»ï¼Œ æ€»çº¿ä¼šè‡ªåŠ¨è¿›è¡ŒåŒ¹é…çš„ã€‚ä»¥ä¸‹åªæ˜¯ä»¥ledä¸ºä¾‹è¯´æ˜platformç›¸å…³æ¥å£ç”¨æ³•ï¼Œå¹¶æœªçœŸæ­£å®ç°ledé©±åŠ¨ã€‚ 1234567891011121314151617181920212223242526272829303132333435#include &lt;linux/module.h&gt;#include &lt;linux/platform_device.h&gt;// å½“æ€»çº¿åŒ¹é…åˆ°è®¾å¤‡æ—¶è°ƒç”¨è¯¥å‡½æ•°static int led_probe(struct platform_device* dev) &#123; printk(&quot;led %s probe\\n&quot;, dev-&gt;name); // todo: å­—ç¬¦è®¾å¤‡æ³¨å†Œã€gpioç”³è¯·ä¹‹ç±»çš„ return 0;&#125;// å½“æ€»çº¿åŒ¹é…åˆ°è®¾å¤‡å¸è½½æ—¶è°ƒç”¨è¯¥å‡½æ•°static int led_remove(struct platform_device* dev) &#123; printk(&quot;led %s removed\\n&quot;, dev-&gt;name); // todo: å…¶ä»–èµ„æºé‡Šæ”¾ return 0;&#125;// å¹³å°é©±åŠ¨æè¿°static struct platform_driver led_driver = &#123; .probe = led_probe, .remove = led_remove, .driver = &#123; .name = &quot;my_led&quot;, // ğŸ‘ˆåŠ¡å¿…æ³¨æ„ï¼Œplatformæ˜¯ä»¥nameæ¯”å¯¹æ¥åŒ¹é…çš„ .owner = THIS_MODULE, &#125;,&#125;;// ã€å®ã€‘å°†ledé©±åŠ¨æŒ‚åˆ°å¹³å°æ€»çº¿ä¸Š// ç›¸å½“äºåŒæ—¶å®šä¹‰äº†æ¨¡å—çš„å…¥å£å’Œå‡ºå£å‡½æ•°// module_init(platform_driver_register)// module_exit(platform_driver_unregister)module_platform_driver(led_driver);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); 12345678910111213141516171819202122232425262728293031#include &lt;linux/module.h&gt;#include &lt;linux/platform_device.h&gt;// æœ€å¥½å®ç°è¯¥æ¥å£ï¼Œå¦åˆ™åœ¨è®¾å¤‡é‡Šæ”¾çš„æ—¶å€™å†…æ ¸ä¼šæŠ¥é”™static void led_release(struct device* pdev) &#123; printk(&quot;led release!\\n&quot;);&#125;// å¹³å°è®¾å¤‡æè¿°static struct platform_device led_device = &#123; .name = &quot;my_led&quot;, // ğŸ‘ˆè¦ç¡®ä¿ä¸led_driverçš„å®šä¹‰ä¸€è‡´ï¼Œå¦åˆ™åŒ¹é…ä¸ä¸Š .dev = &#123; .release = led_release, &#125;,&#125;;// å°†è®¾å¤‡æ³¨å†Œåˆ°å¹³å°æ€»çº¿static int leddev_init(void) &#123; platform_device_register(&amp;led_device); return 0;&#125;module_init(leddev_init);static void leddev_exit(void) &#123; platform_device_unregister(&amp;led_device);&#125;module_exit(leddev_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); ç®€è¿°ä¸€ä¸‹ä»£ç çš„é€»è¾‘ï¼š 1) platform_busç›‘å¬åˆ°æœ‰deviceæ³¨å†Œæ—¶ï¼Œä¼šæŸ¥çœ‹å®ƒçš„device.name 2) platform_busä¼šæŸ¥æ‰¾æ‰€æœ‰çš„driver.nameï¼Œæ‰¾åˆ°ä¹‹åå°†è®¾å¤‡å’Œé©±åŠ¨è¿›è¡Œç»‘å®š 3) ç»‘å®šæˆåŠŸåï¼Œplatform_driver.probe()å°†è§¦å‘ï¼Œåˆšæ‰çš„è®¾å¤‡ä½œä¸ºå‚æ•°ä¼ é€’è¿›å» 4) å‰©ä¸‹çš„äº‹æƒ…ï¼Œå°±çœ‹ä½ å¦‚ä½•å®ç°platform_driveräº† äºŒã€æ ‘è“æ´¾è®¾å¤‡æ ‘1ã€ç”¨è®¾å¤‡æ ‘æ³¨å†Œè®¾å¤‡led_driver.c å…¶ä»–å†…å®¹ä¸å˜ï¼Œä»…ä»…æ˜¯å¢åŠ of_device_idå±æ€§ã€‚ 12345678910111213141516// é¦–å…ˆç”¨of_device_idå£°æ˜äº†ä¸‰ç§LEDå‹å·çš„è¡¨ï¼Œæ”¯æŒè®¾å¤‡æ ‘è§£æstatic const struct of_device_id of_leds_id[] = &#123; &#123; .compatible = &quot;led_type_a&quot; &#125;, &#123; .compatible = &quot;led_type_b&quot; &#125;, &#123; .compatible = &quot;led_type_c&quot; &#125;,&#125;;static struct platform_driver led_driver = &#123; .probe = led_probe, .remove = led_remove, .driver = &#123; .name = &quot;my_led&quot;, .of_match_table = of_leds_id, // ğŸ‘ˆåœ¨é©±åŠ¨ç§æ·»åŠ å¯¹åº”å±æ€§ .owner = THIS_MODULE, &#125;,&#125;; æ¥ç€æ–°å»ºä¸€ä¸ªè®¾å¤‡æ ‘æ–‡ä»¶ï¼Œå¹¶å®šä¹‰ä¸€ä¸ªled_type_açš„LEDè®¾å¤‡ï¼Œå¹¶å°†å…¶å‘½åä¸ºled_a1 12345678910111213/dts-v1/;/plugin/;/ &#123; fragment@0 &#123; target-path = &quot;/&quot;; __overlay__ &#123; led_a1 &#123; compatible = &quot;led_type_a&quot;; &#125;; &#125;; &#125;;&#125;; fragmentå’Œ__overlay__éå¸¸é‡è¦ï¼ï¼å¦‚æœä¸è¿™ä¹ˆå†™ä¼šå¯¼è‡´åŠ¨æ€åŠ è½½å¤±è´¥ï¼Œä½†å…¶å®ä»¥ä¸Šçš„ä»£ç è½¬åŒ–ä¸ºæ ‡å‡†çš„è®¾å¤‡æ ‘è¯­æ³•ä¸ºï¼š 123/led_a1 &#123; compatible = &quot;led_type_a&quot;;&#125;; 1linux-rpi-4.19.y/scripts/dtc/dtc -I dts -o myled.dtbo myled.dts å†æ¥å›é¡¾ä¸‹æµç¨‹ï¼š 1) é¦–å…ˆé©±åŠ¨è¦æ”¯æŒof_device_idå±æ€§ï¼Œå¹¶ä¸”ä»¥compatibleä½œä¸ºåŒ¹é…å¯¹è±¡ 2) ç„¶åé€šè¿‡ç¼–å†™è®¾å¤‡æ ‘å®šä¹‰ç›¸åº”çš„è®¾å¤‡èµ„æº 3) æœ€åé€šè¿‡åŠ è½½é©±åŠ¨å’Œdtoverlayå³å¯ 2ã€è®©è®¾å¤‡å¼€æœºè‡ªåŠ¨æ³¨å†Œ/boot/overlayså…¶å®æ˜¯é€šè¿‡config.txté…ç½®å’Œä½¿èƒ½çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦å°†myled.dtboæ”¾åˆ°overlaysç›®å½•ä¸‹ï¼Œå¹¶åœ¨config.txtæ·»åŠ ä¸€è¡Œä½¿èƒ½å³å¯ã€‚ 123sudo cp myled.dtbo /boot/overlayssudo echo &quot;dtoverlay=myled&quot; | sudo tee -a /boot/config.txtsudo reboot ä½†æ˜¯ï¼Œè®¾å¤‡æ ‘ä»…ä»…æ˜¯å®šä¹‰äº†led_deviceï¼Œè€Œled_driver.koå…¶å®å¹¶æ²¡æœ‰å¼€æœºåŠ è½½ï¼Œå¦‚æœè¦æ›´å®Œå–„çš„è¯ï¼Œåº”è¯¥æŠŠled_driverç›´æ¥ç¼–è¯‘è¿›å†…æ ¸ï¼ ä¸‰ã€æ€»ç»“","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[å®è·µ]","slug":"Linuxé©±åŠ¨-å®è·µ","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linuxé©±åŠ¨[å®è·µ]:13--USB é©±åŠ¨å¼€å‘","slug":"linuxDrive/Linuxé©±åŠ¨-å®è·µ-13-USB-é©±åŠ¨å¼€å‘","date":"2022-11-01T07:17:31.000Z","updated":"2022-11-01T07:21:22.456Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-å®è·µ-13-USB-é©±åŠ¨å¼€å‘/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-13-USB-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/","excerpt":"","text":"","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[å®è·µ]","slug":"Linuxé©±åŠ¨-å®è·µ","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linuxé©±åŠ¨[å®è·µ]:12--USB HIDé©±åŠ¨å¼€å‘","slug":"linuxDrive/Linuxé©±åŠ¨-å®è·µ-12-USB-HIDé©±åŠ¨å¼€å‘","date":"2022-11-01T07:17:04.000Z","updated":"2022-11-01T07:21:19.544Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-å®è·µ-12-USB-HIDé©±åŠ¨å¼€å‘/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-12-USB-HID%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/","excerpt":"","text":"","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[å®è·µ]","slug":"Linuxé©±åŠ¨-å®è·µ","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linuxé©±åŠ¨[å®è·µ]:11--framebuffé©±åŠ¨å­¦ä¹ ","slug":"linuxDrive/Linuxé©±åŠ¨-å®è·µ-11-framebuffé©±åŠ¨å­¦ä¹ ","date":"2022-11-01T07:16:42.000Z","updated":"2022-11-01T07:21:17.064Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-å®è·µ-11-framebuffé©±åŠ¨å­¦ä¹ /","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-11-framebuff%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[å®è·µ]","slug":"Linuxé©±åŠ¨-å®è·µ","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linuxé©±åŠ¨[å®è·µ]:10--SPIé©±åŠ¨","slug":"linuxDrive/Linuxé©±åŠ¨-å®è·µ-10-SPIé©±åŠ¨","date":"2022-11-01T07:16:20.000Z","updated":"2022-11-01T07:21:14.424Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-å®è·µ-10-SPIé©±åŠ¨/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-10-SPI%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[å®è·µ]","slug":"Linuxé©±åŠ¨-å®è·µ","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linuxé©±åŠ¨[å®è·µ]:09--è¾“å…¥å­ç³»ç»Ÿ","slug":"linuxDrive/Linuxé©±åŠ¨-å®è·µ-09-è¾“å…¥å­ç³»ç»Ÿ","date":"2022-11-01T07:16:04.000Z","updated":"2022-11-17T06:19:24.412Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-å®è·µ-09-è¾“å…¥å­ç³»ç»Ÿ/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-09-%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"ä¸€ã€ä¸»è¦æ­¥éª¤åŠè¯´æ˜1ã€ä¸»è¦ä»£ç 123456789101112131415161718192021222324252627282930313233343536static int vs1838_probe(struct platform_device *pdev)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); /* 1. è·å¾—ç¡¬ä»¶ä¿¡æ¯ */ vs1838_data_pin = gpiod_get(&amp;pdev-&gt;dev, NULL, 0); if (IS_ERR(vs1838_data_pin)) &#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); &#125; irq = gpiod_to_irq(vs1838_data_pin); request_irq(irq, vs1838_isr, IRQF_TRIGGER_RISING|IRQF_TRIGGER_FALLING, &quot;vs1838&quot;, NULL); /* è¾“å…¥ç³»ç»Ÿçš„ä»£ç  */ /* å‚è€ƒ: drivers\\input\\keyboard\\gpio_keys.c */ /* A. åˆ†é…input_dev */ vs1838_input_dev = devm_input_allocate_device(&amp;pdev-&gt;dev); /* B. è®¾ç½®input_dev */ vs1838_input_dev-&gt;name = &quot;vs1838&quot;; vs1838_input_dev-&gt;phys = &quot;vs1838&quot;; /* B.1 èƒ½äº§ç”Ÿå“ªç±»äº‹ä»¶ */ __set_bit(EV_KEY, vs1838_input_dev-&gt;evbit); __set_bit(EV_REP, vs1838_input_dev-&gt;evbit); /* B.2 èƒ½äº§ç”Ÿå“ªäº›äº‹ä»¶ */ //__set_bit(KEY_0, vs1838_input_dev-&gt;keybit); memset(vs1838_input_dev-&gt;keybit, 0xff, sizeof(vs1838_input_dev-&gt;keybit)); /* C. æ³¨å†Œinput_dev */ input_register_device(vs1838_input_dev); return 0;&#125; 2ã€è¯´æ˜1) åˆ†é…input_dev å¹¶è®¾ç½®å‚æ•° 1234vs1838_input_dev = devm_input_allocate_device(&amp;pdev-&gt;dev);vs1838_input_dev-&gt;name = &quot;vs1838&quot;;vs1838_input_dev-&gt;phys = &quot;vs1838&quot;; 2) åˆ†é…input_dev å¹¶è®¾ç½®å‚æ•° è®¾å¤‡é©±åŠ¨é€šè¿‡set_bit()å‘Šè¯‰inputå­ç³»ç»Ÿå®ƒæ”¯æŒå“ªäº›äº‹ä»¶ 12set_bit(EV_KEY, vs1838_input_dev-&gt;evbit);set_bit(EV_REP, vs1838_input_dev-&gt;evbit); ä¸»è¦çš„äº‹ä»¶ç±»å‹ä¸»è¦åŒ…æ‹¬ï¼š 3) èƒ½äº§ç”Ÿé‚£äº›äº‹ä»¶ 0xffç±»ä¼¼äºæ©ç ï¼Œè¡¨ç¤ºæŒ‰é”®å€¼å¯ä»¥0x00 - 0xFF 1memset(vs1838_input_dev-&gt;keybit, 0xff, sizeof(vs1838_input_dev-&gt;keybit)); 4) æ³¨å†Œinput_dev è¿™äº›æ“ä½œå®Œæˆåï¼Œå°±ä¼šå­˜åœ¨ä¸€ä¸ªæ–°çš„eventæ–‡ä»¶ã€‚å­˜åœ¨äº/dev/inputè·¯å¾„ä¸‹ 1input_register_device(vs1838_input_dev); 5) äº§ç”Ÿé€šçŸ¥ 1234input_event(vs1838_input_dev, EV_KEY, val, 1);input_event(vs1838_input_dev, EV_KEY, val, 0);input_sync(vs1838_input_dev); äºŒã€å®Œæ•´å®ä¾‹ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261#include &lt;linux/module.h&gt;#include &lt;linux/poll.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/miscdevice.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/major.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/seq_file.h&gt;#include &lt;linux/stat.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/tty.h&gt;#include &lt;linux/kmod.h&gt;#include &lt;linux/gfp.h&gt;#include &lt;linux/gpio/consumer.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/of_gpio.h&gt;#include &lt;linux/of_irq.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/irq.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/fcntl.h&gt;#include &lt;linux/timer.h&gt;#include &lt;linux/workqueue.h&gt;#include &lt;asm/current.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/ktime.h&gt;#include &lt;linux/version.h&gt;#include &lt;linux/input.h&gt;static struct gpio_desc *vs1838_data_pin;static int irq;static unsigned int vs1838_data = 0; static u64 vs1838_edge_time[100];static int vs1838_edge_cnt = 0;static struct input_dev *vs1838_input_dev;/* 0 : æˆåŠŸ, *valä¸­è®°å½•æ•°æ®* -1: æ²¡æ¥æ”¶å®Œæ¯•* -2: è§£æé”™è¯¯*/int vs1838_parse_data(unsigned int *val)&#123; u64 tmp; unsigned char data[4]; int i, j, m; /* åˆ¤æ–­æ˜¯å¦é‡å¤ç  */ if (vs1838_edge_cnt == 4) &#123; tmp = vs1838_edge_time[1] - vs1838_edge_time[0]; if (tmp &gt; 8000000 &amp;&amp; tmp &lt; 10000000) &#123; tmp = vs1838_edge_time[2] - vs1838_edge_time[1]; if (tmp &lt; 3000000) &#123; /* è·å¾—äº†é‡å¤ç  */ *val = vs1838_data; return 0; &#125; &#125; &#125; /* æ¥æ”¶åˆ°äº†66æ¬¡ä¸­æ–­ */ m = 3; if (vs1838_edge_cnt &gt;= 68) &#123; /* è§£æåˆ°äº†æ•°æ® */ for (i = 0; i &lt; 4; i++) &#123; data[i] = 0; /* å…ˆæ¥æ”¶åˆ°bit0 */ for (j = 0; j &lt; 8; j++) &#123; /* æ•°å€¼: 1 */ if (vs1838_edge_time[m+1] - vs1838_edge_time[m] &gt; 1000000) data[i] |= (1&lt;&lt;j); m += 2; &#125; &#125; /* æ£€éªŒæ•°æ® */ data[1] = ~data[1]; if (data[0] != data[1]) &#123; printk(&quot;%s %s line %d, %x, %x, %x\\n&quot;, __FILE__, __FUNCTION__, __LINE__, data[0], data[1], ~data[1]); return -2; &#125; data[3] = ~data[3]; if (data[2] != data[3]) &#123; printk(&quot;%s %s line %d, %x, %x, %x\\n&quot;, __FILE__, __FUNCTION__, __LINE__, data[2], data[3], ~data[3]); return -2; &#125; vs1838_data = (data[0] &lt;&lt; 8) | (data[2]); *val = vs1838_data; return 0; &#125; else &#123; /* æ•°æ®æ²¡æ¥æ”¶å®Œæ¯• */ return -1; &#125; &#125; static irqreturn_t vs1838_isr(int irq, void *dev_id)&#123; unsigned int val; int ret; //printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__);#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 0, 0)) vs1838_edge_time[vs1838_edge_cnt++] = ktime_get_boottime_ns();#else vs1838_edge_time[vs1838_edge_cnt++] = ktime_get_boot_ns();#endif /* åˆ¤æ–­è¶…æ—¶ */ if (vs1838_edge_cnt &gt;= 2) &#123; if (vs1838_edge_time[vs1838_edge_cnt-1] - vs1838_edge_time[vs1838_edge_cnt-2] &gt; 30000000) &#123; /* è¶…æ—¶ */ vs1838_edge_time[0] = vs1838_edge_time[vs1838_edge_cnt-1]; vs1838_edge_cnt = 1; return IRQ_HANDLED; // IRQ_WAKE_THREAD; &#125; &#125; ret = vs1838_parse_data(&amp;val); if (!ret) &#123; /* è§£ææˆåŠŸ */ vs1838_edge_cnt = 0; //printk(&quot;get ir code = 0x%x\\n&quot;, val); val=val&amp;0xff; /* D. è¾“å…¥ç³»ç»Ÿ: ä¸ŠæŠ¥æ•°æ® */ input_event(vs1838_input_dev, EV_KEY, val, 1); input_event(vs1838_input_dev, EV_KEY, val, 0); input_sync(vs1838_input_dev); //input_event(vs1838_input_dev, EV_SYN, 0, 0); &#125; else if (ret == -2) &#123; /* è§£æå¤±è´¥ */ vs1838_edge_cnt = 0; &#125; return IRQ_HANDLED; // IRQ_WAKE_THREAD;&#125;/* 1. ä»platform_deviceè·å¾—GPIO* 2. gpio=&gt;irq* 3. request_irq*/static int vs1838_probe(struct platform_device *pdev)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); /* 1. è·å¾—ç¡¬ä»¶ä¿¡æ¯ */ vs1838_data_pin = gpiod_get(&amp;pdev-&gt;dev, NULL, 0); if (IS_ERR(vs1838_data_pin)) &#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); &#125; irq = gpiod_to_irq(vs1838_data_pin); request_irq(irq, vs1838_isr, IRQF_TRIGGER_RISING|IRQF_TRIGGER_FALLING, &quot;vs1838&quot;, NULL); /* è¾“å…¥ç³»ç»Ÿçš„ä»£ç  */ /* å‚è€ƒ: drivers\\input\\keyboard\\gpio_keys.c */ /* A. åˆ†é…input_dev */ vs1838_input_dev = devm_input_allocate_device(&amp;pdev-&gt;dev); /* B. è®¾ç½®input_dev */ vs1838_input_dev-&gt;name = &quot;vs1838&quot;; vs1838_input_dev-&gt;phys = &quot;vs1838&quot;; /* B.1 èƒ½äº§ç”Ÿå“ªç±»äº‹ä»¶ */ set_bit(EV_KEY, vs1838_input_dev-&gt;evbit); set_bit(EV_REP, vs1838_input_dev-&gt;evbit); /* B.2 èƒ½äº§ç”Ÿå“ªäº›äº‹ä»¶ */ //__set_bit(KEY_0, vs1838_input_dev-&gt;keybit); memset(vs1838_input_dev-&gt;keybit, 0xff, sizeof(vs1838_input_dev-&gt;keybit)); /* C. æ³¨å†Œinput_dev */ input_register_device(vs1838_input_dev); return 0;&#125;static int vs1838_remove(struct platform_device *pdev)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); input_unregister_device(vs1838_input_dev); free_irq(irq, NULL); gpiod_put(vs1838_data_pin); return 0;&#125;static const struct of_device_id ask100_vs1838[] = &#123; &#123; .compatible = &quot;pgg,vs1838&quot; &#125;, &#123; &#125;,&#125;;/* 1. å®šä¹‰platform_driver */static struct platform_driver vs1838_driver = &#123; .probe = vs1838_probe, .remove = vs1838_remove, .driver = &#123; .name = &quot;myvs1883_drv&quot;, .of_match_table = ask100_vs1838, &#125;,&#125;;/* 2. åœ¨å…¥å£å‡½æ•°æ³¨å†Œplatform_driver */static int __init vs1838_init(void)&#123; int err; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); err = platform_driver_register(&amp;vs1838_driver); return err;&#125;/* 3. æœ‰å…¥å£å‡½æ•°å°±åº”è¯¥æœ‰å‡ºå£å‡½æ•°ï¼šå¸è½½é©±åŠ¨ç¨‹åºæ—¶ï¼Œå°±ä¼šå»è°ƒç”¨è¿™ä¸ªå‡ºå£å‡½æ•°* å¸è½½platform_driver*/static void __exit vs1838_exit(void)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); platform_driver_unregister(&amp;vs1838_driver);&#125;/* 7. å…¶ä»–å®Œå–„ï¼šæä¾›è®¾å¤‡ä¿¡æ¯ï¼Œè‡ªåŠ¨åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹ */module_init(vs1838_init);module_exit(vs1838_exit);MODULE_LICENSE(&quot;GPL&quot;);","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[å®è·µ]","slug":"Linuxé©±åŠ¨-å®è·µ","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linuxé©±åŠ¨[å®è·µ]:08--I2Cè®¾å¤‡é©±åŠ¨","slug":"linuxDrive/Linuxé©±åŠ¨-å®è·µ-08-I2Cè®¾å¤‡é©±åŠ¨","date":"2022-11-01T07:15:44.000Z","updated":"2022-11-14T09:49:45.756Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-å®è·µ-08-I2Cè®¾å¤‡é©±åŠ¨/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-08-I2C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"ä¸€ã€è®¾å¤‡æ ‘çš„ç¼–å†™1ã€è®¾å¤‡æ ‘å¢åŠ i2cè®¾å¤‡123456789101112131415161718192021222324&amp;i2c1 &#123; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;i2c1_pins&gt;; clock-frequency = &lt;100000&gt;; mpu6050@68&#123; compatible = &quot;stephen,mpu6050&quot;; reg = &lt;0x68&gt;; //è®¾å¤‡åœ°å€ status = &quot;okay&quot;; &#125;; mcp23017@20 &#123; compatible = &quot;stephen,mcp23017_1&quot;; reg = &lt;0x20&gt;; status = &quot;okay&quot;; &#125;; mcp23017@27 &#123; compatible = &quot;stephen,mcp23017_2&quot;; reg = &lt;0x27&gt;; status = &quot;okay&quot;; &#125;;&#125;; 2ã€å¯ç”¨æ ‘è“æ´¾ç³»ç»Ÿi2c äºŒã€MPU6050ä¾‹å­1ã€ç³»ç»Ÿé©±åŠ¨ç¨‹åº123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/mod_devicetable.h&gt;#include &lt;linux/log2.h&gt;#include &lt;linux/bitops.h&gt;#include &lt;linux/jiffies.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/acpi.h&gt;#include &lt;linux/i2c.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/miscdevice.h&gt;#include &quot;mpu6050.h&quot;#define SMPLRT_DIV 0x19#define CONFIG 0x1A#define GYRO_CONFIG 0x1B#define ACCEL_CONFIG 0x1C#define ACCEL_XOUT_H 0x3B#define ACCEL_XOUT_L 0x3C#define ACCEL_YOUT_H 0x3D#define ACCEL_YOUT_L 0x3E#define ACCEL_ZOUT_H 0x3F#define ACCEL_ZOUT_L 0x40#define TEMP_OUT_H 0x41#define TEMP_OUT_L 0x42#define GYRO_XOUT_H 0x43#define GYRO_XOUT_L 0x44#define GYRO_YOUT_H 0x45#define GYRO_YOUT_L 0x46#define GYRO_ZOUT_H 0x47#define GYRO_ZOUT_L 0x48#define PWR_MGMT_1 0x6Bstatic int major;static struct class *mpu6050_class;// struct mpu6050_device &#123;// struct cdev cdev;// struct i2c_client *client;// &#125;;struct i2c_client *mpu6050_client; static int mpu6050_read_byte(struct i2c_client *client, unsigned char reg)&#123; int ret; char txbuf[1] = &#123; reg &#125;; char rxbuf[1]; struct i2c_msg msg[2] = &#123; &#123;client-&gt;addr, 0, 1, txbuf&#125;, &#123;client-&gt;addr, I2C_M_RD, 1, rxbuf&#125; &#125;; ret = i2c_transfer(client-&gt;adapter, msg, ARRAY_SIZE(msg)); if (ret &lt; 0) &#123; printk(&quot;ret = %d\\n&quot;, ret); return ret; &#125; // printk(&quot;%s,%d\\n&quot;,__func__,__LINE__); return rxbuf[0];&#125;static int mpu6050_write_byte(struct i2c_client *client, unsigned char reg, unsigned char val)&#123; char txbuf[2] = &#123;reg, val&#125;; // addr, write , len , data struct i2c_msg msg[2] = &#123; &#123;client-&gt;addr, 0, 2, txbuf&#125;, &#125;; // ç»™ä»æœºå‘é€æ¶ˆæ¯ i2c_transfer(client-&gt;adapter, msg, ARRAY_SIZE(msg)); // printk(&quot;%s,%d\\n&quot;,__func__,__LINE__); return 0;&#125;static int mpu6050_open(struct inode *inode, struct file *file) &#123; return 0;&#125;static int mpu6050_release(struct inode *inode, struct file *file) &#123; return 0;&#125;static long mpu6050_ioctl(struct file *file, unsigned int cmd, unsigned long arg)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); union mpu6050_data data; struct i2c_client *client = mpu6050_client; switch (cmd) &#123; case GET_ACCEL: data.accel.x = mpu6050_read_byte(client, ACCEL_XOUT_L); data.accel.x |= mpu6050_read_byte(client, ACCEL_XOUT_H) &lt;&lt; 8; data.accel.y = mpu6050_read_byte(client, ACCEL_YOUT_L); data.accel.y |= mpu6050_read_byte(client, ACCEL_YOUT_H) &lt;&lt; 8; data.accel.z = mpu6050_read_byte(client, ACCEL_ZOUT_L); data.accel.z |= mpu6050_read_byte(client, ACCEL_ZOUT_H) &lt;&lt; 8; break; case GET_GYRO: data.gyro.x = mpu6050_read_byte(client, GYRO_XOUT_L); data.gyro.x |= mpu6050_read_byte(client, GYRO_XOUT_H) &lt;&lt; 8; data.gyro.y = mpu6050_read_byte(client, GYRO_YOUT_L); data.gyro.y |= mpu6050_read_byte(client, GYRO_YOUT_H) &lt;&lt; 8; data.gyro.z = mpu6050_read_byte(client, GYRO_ZOUT_L); data.gyro.z |= mpu6050_read_byte(client, GYRO_ZOUT_H) &lt;&lt; 8; break; case GET_TEMP: data.temp = mpu6050_read_byte(client, TEMP_OUT_L); data.temp |= mpu6050_read_byte(client, TEMP_OUT_H) &lt;&lt; 8; break; default: printk(&quot;invalid argument\\n&quot;); return -EINVAL; break; &#125; if (copy_to_user((void *)arg, &amp;data, sizeof(data))) return -EFAULT; return sizeof(data);;&#125;static struct file_operations mpu6050_fops = &#123; .owner = THIS_MODULE, .open = mpu6050_open, .release = mpu6050_release, .unlocked_ioctl = mpu6050_ioctl,&#125;;static int mpu6050_probe(struct i2c_client *client, const struct i2c_device_id *id)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); mpu6050_client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL); if (mpu6050_client == NULL) &#123; return -ENOMEM; &#125; mpu6050_client = client; major = register_chrdev(0, &quot;mpu6050&quot;, &amp;mpu6050_fops); mpu6050_class = class_create(THIS_MODULE, &quot;mpu6050_class&quot;); device_create(mpu6050_class, NULL, MKDEV(major, 0), NULL, &quot;mympu6050&quot;); // åˆå§‹åŒ–mpu6050 mpu6050_write_byte(client, PWR_MGMT_1, 0x00); mpu6050_write_byte(client, SMPLRT_DIV, 0x07); mpu6050_write_byte(client, CONFIG, 0x06); mpu6050_write_byte(client, GYRO_CONFIG, 0xF8); mpu6050_write_byte(client, ACCEL_CONFIG, 0x19); return 0;&#125;static int mpu6050_remove(struct i2c_client *client)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); device_destroy(mpu6050_class, MKDEV(major, 0)); class_destroy(mpu6050_class); unregister_chrdev(major, &quot;mpu6050&quot;); kfree(mpu6050_client); return 0;&#125;static const struct of_device_id mpu6050_of_match[] = &#123; &#123;.compatible = &quot;stephen,mpu6050&quot;&#125;, &#123;&#125;&#125;;static struct i2c_driver mpu6050_drv = &#123; .driver = &#123; .name = &quot;mympu6050_drv&quot;, .of_match_table = mpu6050_of_match, &#125;, .probe = mpu6050_probe, .remove = mpu6050_remove,&#125;;static int mpu6050_init(void)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); return i2c_add_driver(&amp;mpu6050_drv);&#125;static void mpu6050_exit(void)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); i2c_del_driver(&amp;mpu6050_drv);&#125;module_init(mpu6050_init);module_exit(mpu6050_exit);MODULE_LICENSE(&quot;GPL&quot;); 2ã€ç”¨æˆ·æµ‹è¯•ç¨‹åº12345678910111213141516171819202122232425262728293031323334353637#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;mpu6050.h&quot;int main(int argc, char **argv)&#123; int fd; union mpu6050_data data; fd = open(&quot;/dev/mympu6050&quot;, O_RDWR); if (fd &lt; 0) &#123; printf(&quot; can not open %s\\n&quot;, argv[1]); return -1; &#125; while(1) &#123; ioctl(fd, GET_ACCEL, &amp;data); printf(&quot;acceleration data: x = %04x, y = %04x, z = %04x\\n&quot;, data.accel.x, data.accel.y, data.accel.z); ioctl(fd, GET_GYRO, &amp;data); printf(&quot;gyroscope data: x = %04x, y = %04x, z = %04x\\n&quot;, data.accel.x, data.accel.y, data.accel.z); sleep(1); &#125; close(fd); return 0;&#125; 3ã€å…¬å…±å¤´æ–‡ä»¶1234567891011121314151617181920212223242526272829#ifndef MPU6050_H#define MPU6050_H#include &lt;asm-generic/ioctl.h&gt;#define MPU6050_MAGIC &#x27;K&#x27;union mpu6050_data &#123; struct &#123; unsigned short x; unsigned short y; unsigned short z; &#125; accel; struct &#123; unsigned short x; unsigned short y; unsigned short z; &#125; gyro; signed short temp;&#125;;#define GET_ACCEL _IOR(MPU6050_MAGIC, 0, union mpu6050_data)#define GET_GYRO _IOR(MPU6050_MAGIC, 1, union mpu6050_data) #define GET_TEMP _IOR(MPU6050_MAGIC, 2, union mpu6050_data)#endif ä¸‰ã€MCP23017æ‰©å±•IOä¾‹å­1ã€ç³»ç»Ÿé©±åŠ¨ç¨‹åº123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/mod_devicetable.h&gt;#include &lt;linux/log2.h&gt;#include &lt;linux/bitops.h&gt;#include &lt;linux/jiffies.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/acpi.h&gt;#include &lt;linux/i2c.h&gt;S&#x27;s#include &lt;asm/uaccess.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/miscdevice.h&gt;#define DIRE_CONFIG_A 0x00#define DIRE_CONFIG_B 0x01#define PORT_A 0x12#define PORT_B 0x13static int major;static struct class *mcp23017_class;struct i2c_client *mcp23017_client; static int mcp23017_read_byte(struct i2c_client *client, unsigned char reg)&#123; int ret; char txbuf[1] = &#123; reg &#125;; char rxbuf[1]; struct i2c_msg msg[2] = &#123; &#123;client-&gt;addr, 0, 1, txbuf&#125;, &#123;client-&gt;addr, I2C_M_RD, 1, rxbuf&#125; &#125;; ret = i2c_transfer(client-&gt;adapter, msg, ARRAY_SIZE(msg)); if (ret &lt; 0) &#123; printk(&quot;ret = %d\\n&quot;, ret); return ret; &#125; // printk(&quot;%s,%d\\n&quot;,__func__,__LINE__); return rxbuf[0];&#125;static int mcp23017_write_byte(struct i2c_client *client, unsigned char reg, unsigned char val)&#123; char txbuf[2] = &#123;reg, val&#125;; // addr, write , len , data struct i2c_msg msg[2] = &#123; &#123;client-&gt;addr, 0, 2, txbuf&#125;, &#125;; // ç»™ä»æœºå‘é€æ¶ˆæ¯ i2c_transfer(client-&gt;adapter, msg, ARRAY_SIZE(msg)); // printk(&quot;%s,%d\\n&quot;,__func__,__LINE__); return 0;&#125;static int mcp23017_open(struct inode *inode, struct file *file) &#123; return 0;&#125;static int mcp23017_release(struct inode *inode, struct file *file) &#123; return 0;&#125;static long mcp23017_ioctl(struct file *file, unsigned int val, unsigned long arg)&#123; printk(&quot;%s, value: %d\\n&quot;, __FUNCTION__, val); mcp23017_write_byte(mcp23017_client, PORT_A, val); mcp23017_write_byte(mcp23017_client, PORT_B, val); return 0;&#125;static struct file_operations mcp23017_fops = &#123; .owner = THIS_MODULE, .open = mcp23017_open, .release = mcp23017_release, .unlocked_ioctl = mcp23017_ioctl,&#125;;static int mcp23017_probe(struct i2c_client *client, const struct i2c_device_id *id)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); mcp23017_client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL); if (mcp23017_client == NULL) &#123; return -ENOMEM; &#125; mcp23017_client = client; major = register_chrdev(0, &quot;mcp23017&quot;, &amp;mcp23017_fops); mcp23017_class = class_create(THIS_MODULE, &quot;mcp23017_class&quot;); device_create(mcp23017_class, NULL, MKDEV(major, 0), NULL, &quot;mymcp23017&quot;); //è®¾ç½®å¼•è„šæ–¹å‘ï¼Œ0x00:è¾“å‡ºï¼Œ 0xFF:è¾“å…¥(é»˜è®¤) mcp23017_write_byte(client, DIRE_CONFIG_A, 0x00); mcp23017_write_byte(client, DIRE_CONFIG_B, 0x00); return 0;&#125;static int mcp23017_remove(struct i2c_client *client)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); device_destroy(mcp23017_class, MKDEV(major, 0)); class_destroy(mcp23017_class); unregister_chrdev(major, &quot;mcp23017&quot;); kfree(mcp23017_client); return 0;&#125;static const struct of_device_id mcp23017_of_match[] = &#123; &#123;.compatible = &quot;stephen,mcp23017_1&quot;&#125;, &#123;&#125;&#125;;static struct i2c_driver mcp23017_drv = &#123; .driver = &#123; .name = &quot;mymcp23017_drv&quot;, .of_match_table = mcp23017_of_match, &#125;, .probe = mcp23017_probe, .remove = mcp23017_remove,&#125;;static int mcp23017_init(void)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); return i2c_add_driver(&amp;mcp23017_drv);&#125;static void mcp23017_exit(void)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); i2c_del_driver(&amp;mcp23017_drv);&#125;module_init(mcp23017_init);module_exit(mcp23017_exit);MODULE_LICENSE(&quot;GPL&quot;); 2ã€ç”¨æˆ·æµ‹è¯•ç¨‹åº123456789101112131415161718192021222324252627282930#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv)&#123; int fd; fd = open(&quot;/dev/mymcp23017&quot;, O_RDWR); if (fd &lt; 0) &#123; printf(&quot; can not open %s\\n&quot;, argv[1]); return -1; &#125; unsigned int value = 0xFF; while(1) &#123; ioctl(fd, value, NULL); sleep(3); value = (value == 0) ? 0xFF : 0; &#125; close(fd); return 0;&#125;","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[å®è·µ]","slug":"Linuxé©±åŠ¨-å®è·µ","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linuxé©±åŠ¨[å®è·µ]:07--æ ‘è“æ´¾è®¾å¤‡IOè®¿é—®","slug":"linuxDrive/Linuxé©±åŠ¨-å®è·µ-07-æ ‘è“æ´¾è®¾å¤‡IOè®¿é—®","date":"2022-11-01T07:15:26.000Z","updated":"2022-11-19T03:25:51.827Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-å®è·µ-07-æ ‘è“æ´¾è®¾å¤‡IOè®¿é—®/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-07-%E6%A0%91%E8%8E%93%E6%B4%BE%E8%AE%BE%E5%A4%87IO%E8%AE%BF%E9%97%AE/","excerpt":"","text":"1 ä¸€ã€GPIOå­ç³»ç»Ÿ1ã€åŠŸèƒ½é€šè¿‡è¯»å–è®¾å¤‡æ ‘ä¿¡æ¯ï¼Œç”¨æ¥è·å–GPIOï¼Œé…ç½®GPIOçš„æ–¹å‘ï¼Œè®¾ç½®é«˜ä½ç”µå¹³ç­‰ã€‚ 2ã€APIå‡½æ•° æ³¨ï¼šå‰ç¼€devm_çš„å«ä¹‰æ˜¯â€œè®¾å¤‡èµ„æºç®¡ç†â€ï¼Œè¿™æ˜¯ä¸€ç§è‡ªåŠ¨é‡Šæ”¾èµ„æºçš„æœºåˆ¶ã€‚å®ƒçš„æ€æƒ³æ˜¯â€œèµ„æºæ˜¯å±äºè®¾å¤‡çš„ï¼Œè®¾å¤‡ä¸å­˜åœ¨æ—¶èµ„æºå°±å¯ä»¥è‡ªåŠ¨é‡Šæ”¾â€ã€‚ äºŒã€æŸ¥è¯¢å†™æ³•æ¡ˆä¾‹1ã€é©±åŠ¨ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 static int gpio_button_probe(struct platform_device *pdev)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); button_handle = gpiod_get(&amp;pdev-&gt;dev, NULL, 0); gpiod_direction_input(button_handle); /* æ³¨å†Œfile_operations */ major = register_chrdev(0, &quot;pgg_button&quot;, &amp;gpio_button_drv); /* /dev/gpio_key */ gpio_button_class = class_create(THIS_MODULE, &quot;gpio_button_class&quot;); if (IS_ERR(gpio_button_class)) &#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); unregister_chrdev(major, &quot;pgg_button&quot;); return PTR_ERR(gpio_button_class); &#125; device_create(gpio_button_class, NULL, MKDEV(major, 0), NULL, &quot;pgg_button&quot;); return 0;&#125;static int gpio_button_remove(struct platform_device *pdev)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); device_destroy(gpio_button_class, MKDEV(major, 0)); class_destroy(gpio_button_class); unregister_chrdev(major, &quot;pgg_button&quot;); gpiod_put(button_handle); return 0;&#125;static ssize_t gpio_button_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); int val; int len =2; val = gpiod_get_value(button_handle); if(val == 1) &#123; copy_to_user(buf, &quot;1&quot;, 2); &#125; else &#123; copy_to_user(buf, &quot;0&quot;, 2); &#125; return len;&#125; 2ã€æµ‹è¯•ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 int main(int argc, char **argv)&#123; int fd; char buf[1024]; int len; int ret; /* 1. åˆ¤æ–­å‚æ•° */ if (argc &lt; 2) &#123; printf(&quot;Usage: %s -w &lt;string&gt;\\n&quot;, argv[0]); printf(&quot; %s -r\\n&quot;, argv[0]); return -1; &#125; /* 2. æ‰“å¼€æ–‡ä»¶ */ fd = open(&quot;/dev/pgg_button&quot;, O_RDWR); if (fd == -1) &#123; printf(&quot;can not open file /dev/pgg_button\\n&quot;); return -1; &#125; printf(&quot;open file /dev/pgg_button ok\\n&quot;); /* 3. å†™æ–‡ä»¶æˆ–è¯»æ–‡ä»¶ */ if ((0 == strcmp(argv[1], &quot;-w&quot;)) &amp;&amp; (argc == 3)) &#123; len = strlen(argv[2]) + 1; len = len &lt; 1024 ? len : 1024; ret = write(fd, argv[2], len); printf(&quot;write driver: %d\\n&quot;, ret); &#125; else &#123; len = read(fd, buf, 1024); printf(&quot;read driver: %d\\n&quot;, len); buf[1023] = &#x27;\\0&#x27;; printf(&quot;APP read : %s\\n&quot;, buf); &#125; close(fd); return 0;&#125; ä¸‰ã€ä¼‘çœ å”¤é†’æ³•æ¡ˆä¾‹1ã€é©±åŠ¨ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 static int gpio_button_probe(struct platform_device *pdev)&#123; struct device_node *node = pdev-&gt;dev.of_node; enum of_gpio_flags flag; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); gpio_num = of_get_gpio_flags(node, 0, &amp;flag); button_handle = gpiod_get(&amp;pdev-&gt;dev, NULL, 0); gpiod_direction_input(button_handle); button_irq = gpio_to_irq(gpio_num); request_irq(button_irq, gpio_button_isr, IRQF_TRIGGER_RISING, &quot;pgg_button_irq&quot;, NULL);//IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING /* æ³¨å†Œfile_operations */ major = register_chrdev(0, &quot;pgg_button&quot;, &amp;gpio_button_drv); /* /dev/gpio_key */ gpio_button_class = class_create(THIS_MODULE, &quot;gpio_button_class&quot;); if (IS_ERR(gpio_button_class)) &#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); unregister_chrdev(major, &quot;pgg_button&quot;); return PTR_ERR(gpio_button_class); &#125; device_create(gpio_button_class, NULL, MKDEV(major, 0), NULL, &quot;pgg_button&quot;); /* /dev/100ask_gpio_key */ return 0;&#125;static irqreturn_t gpio_button_isr(int irq, void *dev_id)&#123; int val; val = gpiod_get_value(button_handle); printk(&quot;key value %d\\n&quot;, val); g_button_value = val; wake_up_interruptible(&amp;gpio_key_wait); return IRQ_HANDLED;&#125;static ssize_t gpio_button_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); //printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); int err; wait_event_interruptible(gpio_key_wait, g_button_value); err = copy_to_user(buf, &amp;g_button_value, 4); g_button_value = 0; return 4;&#125; 2ã€æµ‹è¯•ä»£ç 12345678910111213141516 &#123; printf(&quot;can not open file %s\\n&quot;, argv[1]); return -1;&#125;while (1)&#123; /* 3. è¯»æ–‡ä»¶ */ read(fd, &amp;val, 4); printf(&quot;get button : 0x%x\\n&quot;, val);&#125;close(fd);return 0; å››ã€ä¼‘çœ å”¤é†’POLLæ³•æ¡ˆä¾‹1ã€é©±åŠ¨ä»£ç 123456789101112static unsigned int gpio_button_drv_poll(struct file *fp, poll_table * wait)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); poll_wait(fp, &amp;gpio_key_wait, wait); if(g_button_value) return POLLIN | POLLRDNORM; else return 0;&#125; 2ã€æµ‹è¯•ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041int main(int argc, char **argv)&#123; int fd; int val; struct pollfd fds[1]; int timeout_ms = 5000; int ret; /* 1. åˆ¤æ–­å‚æ•° */ if (argc != 2) &#123; printf(&quot;Usage: %s &lt;dev&gt;\\n&quot;, argv[0]); return -1; &#125; /* 2. æ‰“å¼€æ–‡ä»¶ */ fd = open(argv[1], O_RDWR); if (fd == -1) &#123; printf(&quot;can not open file %s\\n&quot;, argv[1]); return -1; &#125; fds[0].fd = fd; fds[0].events = POLLIN; while (1) &#123; /* 3. è¯»æ–‡ä»¶ */ ret = poll(fds, 1, timeout_ms); if ((ret == 1) &amp;&amp; (fds[0].revents &amp; POLLIN)) &#123; read(fd, &amp;val, 4); printf(&quot;get button : 0x%x\\n&quot;, val); &#125; else &#123; printf(&quot;timeout\\n&quot;); &#125; &#125; close(fd); return 0;&#125; äº”ã€å¼‚æ­¥é€šçŸ¥æ¡ˆä¾‹1ã€é©±åŠ¨ä»£ç 123456789101112131415161718192021222324252627static int gpio_button_drv_fasync(int fd, struct file *file, int on)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); if (fasync_helper(fd, file, on, &amp;button_fasync) &gt;= 0) return 0; else return -EIO;&#125;static irqreturn_t gpio_button_isr(int irq, void *dev_id)&#123; int val; val = gpiod_get_value(button_handle); printk(&quot;key value: %d\\n&quot;, val); if (val) &#123; g_button_value = val; wake_up_interruptible(&amp;gpio_key_wait); /* å‘é€ä¸­æ–­ç»™ç”¨æˆ·è¿›ç¨‹ */ kill_fasync(&amp;button_fasync, SIGIO, POLL_IN); &#125; return IRQ_HANDLED;&#125; å…­ã€å®Œæ•´æ€»ç»“","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[å®è·µ]","slug":"Linuxé©±åŠ¨-å®è·µ","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linuxé©±åŠ¨[å®è·µ]:06--æ ‘è“æ´¾GPIOé©±åŠ¨SR04è¶…å£°æ¨¡å—","slug":"linuxDrive/Linuxé©±åŠ¨-å®è·µ-06-æ ‘è“æ´¾GPIOé©±åŠ¨SR04è¶…å£°æ¨¡å—","date":"2022-11-01T07:15:07.000Z","updated":"2022-11-05T03:17:05.182Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-å®è·µ-06-æ ‘è“æ´¾GPIOé©±åŠ¨SR04è¶…å£°æ¨¡å—/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-06-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E9%A9%B1%E5%8A%A8SR04%E8%B6%85%E5%A3%B0%E6%A8%A1%E5%9D%97/","excerpt":"","text":"ä¸€ã€è¶…å£°æ¨¡å—åŸç†1ã€å·¥ä½œåŸç†1ã€Trigå¼•è„šæ¥æ”¶è‡³å°‘10usçš„é«˜ç”µå¹³ä¿¡å·ï¼Œç”¨äºè§¦å‘è¶…å£°æ³¢æ¨¡å—å·¥ä½œï¼› 2ã€æ¨¡å—ä¼šè‡ªåŠ¨å‘é€8ä¸ª40KHzçš„æ–¹æ³¢ä¿¡å·ï¼Œè‡ªåŠ¨æ£€æµ‹æ˜¯å¦æœ‰ä¿¡å·è¿”å›ï¼› 3ã€æœ‰ä¿¡å·è¿”å›ï¼Œé€šè¿‡Echoå¼•è„šè¿æ¥å•ç‰‡æœºçš„I/Oå£è¾“å‡ºä¸€é«˜ç”µå¹³ï¼Œé«˜ç”µå¹³æŒç»­æ—¶é—´Tå°±æ˜¯è¶…å£°æ³¢ä»å‘å°„åˆ°è¿”å›çš„æ—¶é—´ï¼› 4ã€å£°éŸ³åœ¨ç©ºæ°”ä¸­çš„ä¼ æ’­é€Ÿåº¦ä¸º340ç±³/ç§’ï¼Œå³å¯è®¡ç®—å‡ºæ‰€æµ‹çš„è·ç¦»ï¼šD = 340*T/2ã€‚ 2ã€é©±åŠ¨åŸç†è¿™é‡Œå°±éœ€è¦ç”¨åˆ°ä¸¤ä¸ªGPIOï¼Œä¸€ä¸ªè´Ÿè´£Tripï¼Œå‘å‡ºè§¦å‘ä¿¡å·ï¼Œä¸€ä¸ªè´Ÿè´£Echoï¼Œæ¥æ”¶Echoé«˜ç”µå¹³ä¿¡å·ï¼Œå¹¶è®¡ç®—é«˜ç”µå¹³æ—¶é—´ã€‚ è¿™é‡Œçš„Tripç®€å•ï¼ŒæŒç»­ä¸€ä¸ªå¤§äº10usçš„é«˜ç”µå¹³å³å¯ï¼ŒEchoå¼•è„šï¼Œæˆ‘ä»¬éœ€è¦ç›‘å¬ä¸Šä¸‹è¾¹æ²¿ï¼Œç„¶åè®¡ç®—å‡ºä¸­é—´çš„æ—¶é—´ï¼Œè¿™é‡Œå°±éœ€è¦ç”¨åˆ°ä¸­æ–­ã€‚é€šè¿‡ä¸­æ–­å¾—åˆ°ä¸¤ä¸ªæ—¶é—´ç‚¹ï¼Œç„¶åè®¡ç®—å·®å€¼ï¼Œä¼ ç»™ç”¨æˆ·ã€‚ äºŒã€é©±åŠ¨å®ç°1ã€è®¾å¤‡æ ‘ç¼–å†™123456mysr04 &#123; compatible = &quot;pgg, sr04&quot;; status = &quot;okay&quot;; sr-04-gpio = &lt;&amp;gpio, 17, GPIO_ACTIVE_HIGH&gt;, &lt;&amp;gpio, 18, GPIO_ACTIVE_HIGH&gt;, &#125; 2ã€å¼•è„šè¯»å–æ–¹å¼123struct gpio_desc *trip, *echo;trip= gpiod_get_index(dev, &quot;sr04&quot;, 0, GPIOD_OUT_HIGH);echo= gpiod_get_index(dev, &quot;sr04&quot;, 1, GPIOD_OUT_HIGH); 3ã€ç¡¬ä»¶åŠä¸­æ–­12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970struct sr04_gpios&#123; struct gpio_desc *trip; struct gpio_desc *echo; int echo_irq;&#125; ;struct sr04_gpios my_sr04_gpios;static int mysr04_probe(struct platform_device *pdev)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); //è¯»å–å…³é”®å¼•è„šæè¿°ä¿¡æ¯ my_sr04_gpios.trip= gpiod_get_index(&amp;pdev-&gt;dev, &quot;sr04&quot;, 0, GPIOD_OUT_HIGH); my_sr04_gpios.echo= gpiod_get_index(&amp;pdev-&gt;dev, &quot;sr04&quot;, 1, GPIOD_OUT_HIGH); //é…ç½®æ–¹å‘ gpiod_direction_output(my_sr04_gpios.trip,0); gpiod_direction_input(my_sr04_gpios.echo); //è·å–ä¸­æ–­ my_sr04_gpios.echo_irq = gpiod_to_irq(my_sr04_gpios.echo); //æ³¨å†Œä¸­æ–­ request_irq(my_sr04_gpios.echo_irq, my_sr04_echo_isr, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, &quot;mysr04_irq&quot;, NULL);//IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING /* æ³¨å†Œfile_operations */ major = register_chrdev(0, &quot;pgg_sr04&quot;, &amp;gpio_button_drv); mysr04_class = class_create(THIS_MODULE, &quot;mysr04_class&quot;); if (IS_ERR(mysr04_class)) &#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); unregister_chrdev(major, &quot;pgg_sr04&quot;); return PTR_ERR(mysr04_class); &#125; device_create(mysr04_class, NULL, MKDEV(major, 0), NULL, &quot;pgg_sr04&quot;); /* /dev/pgg_sr04 */ return 0;&#125;static int mysr04_remove(struct platform_device *pdev)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); device_destroy(mysr04_class, MKDEV(major, 0)); class_destroy(mysr04_class); unregister_chrdev(major, &quot;pgg_sr04&quot;); gpiod_put(my_sr04_gpios.trip); gpiod_put(my_sr04_gpios.echo); free_irq(my_sr04_gpios.echo_irq,NULL); return 0;&#125;static irqreturn_t my_sr04_echo_isr(int irq, void *dev_id)&#123; printk(&quot;revice irq %d\\n&quot;, irq); return IRQ_HANDLED;&#125;static ssize_t gpio_button_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); gpiod_set_value(my_sr04_gpios.trip,1); udelay(100); gpiod_set_value(my_sr04_gpios.trip,0); return 0;&#125; æµ‹è¯•ç¨‹åºï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041int main(int argc, char **argv)&#123; int fd; char buf[1024]; int len; int ret; /* 1. åˆ¤æ–­å‚æ•° */ if (argc &lt; 2) &#123; printf(&quot;Usage: %s -w &lt;string&gt;\\n&quot;, argv[0]); printf(&quot; %s -r\\n&quot;, argv[0]); return -1; &#125; /* 2. æ‰“å¼€æ–‡ä»¶ */ fd = open(&quot;/dev/pgg_sr04&quot;, O_RDWR); if (fd == -1) &#123; printf(&quot;can not open file /dev/pgg_sr04\\n&quot;); return -1; &#125; printf(&quot;open file /dev/pgg_sr04 ok\\n&quot;); /* 3. å†™æ–‡ä»¶æˆ–è¯»æ–‡ä»¶ */ if ((0 == strcmp(argv[1], &quot;-w&quot;)) &amp;&amp; (argc == 3)) &#123; len = strlen(argv[2]) + 1; len = len &lt; 1024 ? len : 1024; ret = write(fd, argv[2], len); printf(&quot;write driver: %d\\n&quot;, ret); &#125; else &#123; len = read(fd, buf, 1024); printf(&quot;read driver: %d\\n&quot;, len); buf[1023] = &#x27;\\0&#x27;; printf(&quot;APP read : %s\\n&quot;, buf); &#125; close(fd); return 0;&#125; 4ã€è®¡ç®—æ—¶é—´å·®å€¼12345678910111213141516171819202122static irqreturn_t my_sr04_echo_isr(int irq, void *dev_id)&#123; int val = gpiod_get_value(my_sr04_gpios.echo); if (val) /* ä¸Šå‡æ²¿ */ &#123; /* 1. è®°å½•æ•°æ® */ a = ktime_get_ns(); printk(&quot;revice irq up a=%llu\\n&quot;,a); &#125; else /* ä¸‹é™æ²¿ */ &#123; b = ktime_get_ns(); printk(&quot;revice irq down b=%llu\\n&quot;,b); printk(&quot;revice irq %llu\\n&quot;,b-a); &#125; return IRQ_HANDLED;&#125; 5ã€ä¼‘çœ å”¤é†’12345678910111213141516static irqreturn_t my_sr04_echo_isr(int irq, void *dev_id)&#123; int val = gpiod_get_value(my_sr04_gpios.echo); /* ä¸Šå‡æ²¿ */ if (val) &#123; a = ktime_get_ns(); &#125; else &#123; /* ä¸‹é™æ²¿ */ b = ktime_get_ns(); dataready = 1; wake_up_interruptible(&amp;mysr04_wait); &#125; return IRQ_HANDLED;&#125; è¯»å–å‡½æ•°ä¸­ï¼Œä¼ å‡ºè®¡ç®—å‡ºæ¥çš„æ—¶é—´å·® 1234567891011121314151617181920212223242526static ssize_t mysr0_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)&#123; char result[64]=&#123;0&#125;; int reslen=0; static u64 c=0; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); a=0; b=0; dataready = 0; gpiod_set_value(my_sr04_gpios.trip,1); udelay(100); gpiod_set_value(my_sr04_gpios.trip,0); wait_event_interruptible(mysr04_wait, dataready); dataready = 0; c = b-a; sprintf(result,&quot;%llu&quot;,c); reslen=strlen(result)+1; copy_to_user(buf, result, reslen); return reslen;&#125; 6ã€é©±åŠ¨æµ‹è¯•12345678910111213141516171819202122232425262728293031323334353637383940int main(int argc, char **argv)&#123; int fd; char buf[1024]; int len; int ret; /* 1. åˆ¤æ–­å‚æ•° */ if (argc &lt; 2) &#123; printf(&quot; %s -r\\n&quot;, argv[0]); return -1; &#125; /* 2. æ‰“å¼€æ–‡ä»¶ */ fd = open(&quot;/dev/pgg_sr04&quot;, O_RDWR); if (fd == -1) &#123; printf(&quot;can not open file /dev/pgg_sr04\\n&quot;); return -1; &#125; //printf(&quot;open file /dev/pgg_sr04 ok\\n&quot;); /* 3. å†™æ–‡ä»¶æˆ–è¯»æ–‡ä»¶ */ if ((0 == strcmp(argv[1], &quot;-r&quot;)) &amp;&amp; (argc == 2)) &#123; len = read(fd, buf, 1024); buf[1023] = &#x27;\\0&#x27;; printf(&quot;driver read : %s\\n&quot;, buf); long res= strtol(buf, NULL, 0); double resm=0.00000017*((double)res); printf(&quot;sr04 è·ç¦» : %lf ç±³\\n&quot;, resm); &#125; else &#123; printf(&quot; %s -r\\n&quot;, argv[0]); &#125; close(fd); return 0;&#125; ä¸‰ã€é™„å½•1ã€ç”¨æˆ·ä¾§å’Œå†…æ ¸ç”¨çš„å­—ç¬¦ä¸²æ“ä½œå‡½æ•°åŒºåˆ«https://blog.csdn.net/qq_44710568/article/details/105382670 2ã€å…³é”®å‡½æ•°è¿”å›å€¼åˆ¤æ–­1234567static inline int __must_checkrequest_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev)&#123; return request_threaded_irq(irq, handler, NULL, flags, name, dev);&#125; å¦‚æœä½ æ²¡æœ‰æ£€æŸ¥ï¼Œç¼–è¯‘çš„æ—¶å€™ï¼Œä¼šæé†’ 12warning: ignoring return value of â€˜request_irqâ€™, declared with attribute warn_unused_result [-Wunused-result]","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[å®è·µ]","slug":"Linuxé©±åŠ¨-å®è·µ","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linuxé©±åŠ¨[å®è·µ]:05--æ ‘è“æ´¾GPIOé©±åŠ¨çº¢å¤–æ¨¡å—","slug":"linuxDrive/Linuxé©±åŠ¨-å®è·µ-05-æ ‘è“æ´¾GPIOé©±åŠ¨çº¢å¤–æ¨¡å—","date":"2022-11-01T07:14:48.000Z","updated":"2022-11-03T09:01:25.182Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-å®è·µ-05-æ ‘è“æ´¾GPIOé©±åŠ¨çº¢å¤–æ¨¡å—/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-05-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E9%A9%B1%E5%8A%A8%E7%BA%A2%E5%A4%96%E6%A8%A1%E5%9D%97/","excerpt":"","text":"ä¸€ã€NECåè®®1ã€ç¼–ç è¯´æ˜ 2ã€ç¼–ç å°ç»“1) åè®®å¸§å¤´æ€»æ˜¯ä»¥9msçš„é«˜ç”µå¹³å’Œ4.5msçš„ä½ç”µå¹³ä¸ºä¸€ä¸ªè„‰å†²å‘¨æœŸ; 2) åè®®å†…å®¹çš„è„‰å†²å‘¨æœŸï¼Œâ€˜-___â€™è¡¨ç¤º1ï¼Œâ€˜-_â€™è¡¨ç¤º0ï¼Œä¸”ç”µå¹³ä¿¡å·ä»¥560usä¸ºå•ä½ï¼› 3) 9msé«˜ç”µå¹³å’Œ2.25msçš„ä½ç”µå¹³è¡¨ç¤ºé‡å¤ç ï¼Œå³é•¿æŒ‰æŒ‰é”®æ—¶è§¦å‘; 4) å¸§é—´é—´éš”ä¸º110ms. äºŒã€é©±åŠ¨å®ç°1ã€æµç¨‹1) ç”³è¯·å¹¶æ³¨å†ŒGPIO18çš„ä¸­æ–­ï¼ŒåŠ¡å¿…æ˜¯åŒè¾¹æ²¿è§¦å‘; 2) ç”³è¯·ä¸€ä¸ªå®šæ—¶å™¨ç”¨äºè¶…æ—¶æ–­å¸§å¤„ç†; 3) æ¯æ¬¡ä¸­æ–­è§¦å‘ï¼Œéƒ½è®°å½•ä¸Šå‡æˆ–è€…ä¸‹é™æ²¿çš„çŠ¶æ€åŠæ—¶é•¿; 4) æ¯å½“ç»è¿‡ä¸€ä¸ªå®Œæ•´è„‰å†²åï¼Œé€šè¿‡å ç©ºæ¯”åˆ¤æ–­æ•°æ®ç±»å‹; 5) æ¯å½“è®°å½•äº†32ä¸ªæ•°æ®(ä¸€å¸§)åï¼Œå¤„ç†åè®®æŒ‡ä»¤; 6) æˆ‘æ˜¯ç›´æ¥æŠŠåœ°å€å’ŒæŒ‡ä»¤æ¨ç»™ç”¨æˆ·å±‚å¤„ç†. 2ã€é©±åŠ¨ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/miscdevice.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/timer.h&gt;#include &lt;linux/wait.h&gt;static struct &#123; int gpio; int irq; wait_queue_head_t rwait; struct timer_list timer; u32 pulse; // è„‰å†²ä¸Šå‡æ²¿æŒç»­æ—¶é•¿ u32 space; // è„‰å†²ä¸‹é™æ²¿æŒç»­æ—¶é•¿ size_t count; // è„‰å†²ä¸ªæ•° u32 data; // è„‰å†²è§£ç åçš„å€¼&#125; ir;#define is_head(p, s) (p &gt; 8900 &amp;&amp; p &lt; 9100 &amp;&amp; s &gt; 4400 &amp;&amp; s &lt; 4600)#define is_repeat(p, s) (p &gt; 8900 &amp;&amp; p &lt; 9100 &amp;&amp; s &gt; 2150 &amp;&amp; s &lt; 2350)#define is_bfalse(p, s) (p &gt; 500 &amp;&amp; p &lt; 650 &amp;&amp; s &gt; 500 &amp;&amp; s &lt; 650)#define is_btrue(p, s) (p &gt; 500 &amp;&amp; p &lt; 650 &amp;&amp; s &gt; 1500 &amp;&amp; s &lt; 1750)// çº¢å¤–æ¥æ”¶å‡½æ•°(å³GPIO18çš„åŒè¾¹æ²¿ä¸­æ–­å¤„ç†å‡½æ•°)// è®°å½•GPIOæ¯æ¬¡ä¸­æ–­æ˜¯â€œä¸Šå‡è¿˜æ˜¯ä¸‹é™â€ï¼Œä»¥åŠæŒç»­çš„æ—¶é•¿static irqreturn_t ir_rx(int irq, void* dev) &#123; static ktime_t last = 0; u32 duration = (u32)ktime_to_us(ktime_get() - last); // âš ï¸æ³¨æ„ï¼š1838çº¢å¤–å¤´é«˜ä½ç”µå¹³é€»è¾‘å–å if (!gpio_get_value(ir.gpio)) &#123; ir.space = duration; &#125; else &#123; // åˆ‡æ¢ä¸‹é™æ²¿æ—¶ï¼Œè„‰å†²åªæœ‰é«˜ç”µå¹³éƒ¨åˆ†ï¼Œæ‰€ä»¥ä¸åšå¤„ç† ir.pulse = duration; goto irq_out; &#125; if (is_head(ir.pulse, ir.space)) &#123; ir.count = ir.data = 0; &#125; else if (is_repeat(ir.pulse, ir.space)) &#123; ir.count = 32; &#125; else if (is_btrue(ir.pulse, ir.space)) &#123; ir.data |= 1 &lt;&lt; ir.count++; &#125; else if (is_bfalse(ir.pulse, ir.space)) &#123; ir.data |= 0 &lt;&lt; ir.count++; &#125; else &#123; goto irq_out; &#125; if (ir.count &gt;= 32) &#123; wake_up(&amp;ir.rwait); &#125;irq_out: mod_timer(&amp;ir.timer, jiffies + (HZ / 10)); last = ktime_get(); return IRQ_HANDLED;&#125;// å®šæ—¶æ¸…é™¤çº¢å¤–åè®®å¸§çš„ç›¸å…³ä¿¡æ¯ï¼Œä¾¿äºæ¥æ”¶ä¸‹ä¸€å¸§static void clear_flag(struct timer_list *timer) &#123; ir.pulse = 0; ir.space = 0; ir.count = 0; ir.data = 0;&#125;static ssize_t ir_read(struct file *filp, char __user *buf, size_t len, loff_t *off) &#123; int rc = 0; if ((filp-&gt;f_flags &amp; O_NONBLOCK) &amp;&amp; ir.count &lt; 32) &#123; return -EAGAIN; &#125; else &#123; DECLARE_WAITQUEUE(wq, current); add_wait_queue(&amp;ir.rwait, &amp;wq); wait_event(ir.rwait, ir.count == 32); remove_wait_queue(&amp;ir.rwait, &amp;wq); &#125; rc = copy_to_user(buf, &amp;ir.data, sizeof(u32)); if (rc &lt; 0) &#123; return rc; &#125; ir.count = 0; *off += sizeof(u32); return sizeof(u32);&#125;static const struct file_operations fops = &#123; .owner = THIS_MODULE, .read = ir_read,&#125;;static struct miscdevice irdev = &#123; .minor = MISC_DYNAMIC_MINOR, .name = &quot;IR1838-NEC&quot;, .fops = &amp;fops, .nodename = &quot;ir0&quot;, .mode = 0744,&#125;;static int __init ir_init(void) &#123; int rc = 0; // åˆå§‹åŒ–è„‰å†²å¤„ç†å‡½æ•° init_waitqueue_head(&amp;ir.rwait); // åˆå§‹åŒ–å®šæ—¶å™¨ï¼Œç”¨äºæ–­å¸§ timer_setup(&amp;ir.timer, clear_flag, 0); add_timer(&amp;ir.timer); // ç”³è¯·GPIOåŠå…¶åŒè¾¹æ²¿ä¸­æ–­ ir.gpio = 18; if ((rc = gpio_request_one(ir.gpio, GPIOF_IN, &quot;IR&quot;)) &lt; 0) &#123; printk(KERN_ERR &quot;ERROR%d: can not request gpio%d\\n&quot;, rc, ir.gpio); return rc; &#125; ir.irq = gpio_to_irq(ir.gpio); if ((rc = request_irq(ir.irq, ir_rx, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, &quot;IR&quot;, NULL)) &lt; 0) &#123; printk(KERN_ERR &quot;ERROR%d: can not request irq\\n&quot;, ir.irq); return rc; &#125; if ((rc = misc_register(&amp;irdev)) &lt; 0) &#123; return rc; &#125; return 0;&#125;module_init(ir_init);static void __exit ir_exit(void) &#123; misc_deregister(&amp;irdev); free_irq(ir.irq, NULL); gpio_free(ir.gpio); del_timer(&amp;ir.timer);&#125;module_exit(ir_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); ä»¥ä¸Šä»£ç æœ‰ä¸ªå¾ˆå¤§çš„é£é™©ï¼Œä¸ºäº†ç®€åŒ–ç¨‹åºï¼ŒIRQä¸­æ–­å¹¶æ²¡æœ‰é‡‡å–â€œåº•åŠéƒ¨â€æ¥å¤„ç†å¤æ‚çš„çº¢å¤–è§£ç ä¸šåŠ¡ï¼Œå¦‚æœä¸šåŠ¡é€»è¾‘è¿›ä¸€æ­¥åŠ å¤§ï¼Œå¯èƒ½ä¼šå¯¼è‡´å†…æ ¸å´©æºƒã€‚ 3ã€æµ‹è¯•ä»£ç 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/fcntl.h&gt;// car-mp3é¥æ§å™¨æŒ‡ä»¤ç static const char* keyname[] = &#123;[0x45] = &quot;Channel-&quot;, [0x46] = &quot;Channel&quot;, [0x47] = &quot;Channel+&quot;,[0x44] = &quot;Speed-&quot;, [0x40] = &quot;Speed+&quot;, [0x43] = &quot;Play/Pause&quot;,[0x15] = &quot;Vol+&quot;, [0x07] = &quot;Vol-&quot;, [0x09] = &quot;EQ&quot;,[0x16] = &quot;No.0&quot;, [0x19] = &quot;100+&quot;, [0x0d] = &quot;200+&quot;,[0x0c] = &quot;No.1&quot;, [0x18] = &quot;No.2&quot;, [0x5e] = &quot;No.3&quot;,[0x08] = &quot;No.4&quot;, [0x1c] = &quot;No.5&quot;, [0x5a] = &quot;No.6&quot;,[0x42] = &quot;No.7&quot;, [0x52] = &quot;No.8&quot;, [0x4a] = &quot;No.9&quot;,&#125;;int main(int argc, char* argv[]) &#123; int ir = open(&quot;/dev/ir0&quot;, O_RDONLY); while (1) &#123; int frame = 0; if (read(ir, &amp;frame, sizeof(int)) &lt; 0) &#123; perror(&quot;read ir&quot;); break; &#125; int cmd = (frame &gt;&gt; 16) &amp; 0xFF; printf(&quot;%s\\n&quot;, keyname[cmd]); &#125; close(ir); return 0;&#125;","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[å®è·µ]","slug":"Linuxé©±åŠ¨-å®è·µ","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linuxé©±åŠ¨[å®è·µ]:04--æ ‘è“æ´¾GPIOæ‚é¡¹é©±åŠ¨misc","slug":"linuxDrive/Linuxé©±åŠ¨-å®è·µ-04-æ ‘è“æ´¾GPIOæ‚é¡¹é©±åŠ¨misc","date":"2022-11-01T07:14:15.000Z","updated":"2022-11-04T00:58:01.402Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-å®è·µ-04-æ ‘è“æ´¾GPIOæ‚é¡¹é©±åŠ¨misc/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-04-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E6%9D%82%E9%A1%B9%E9%A9%B1%E5%8A%A8misc/","excerpt":"","text":"ä¸€ã€ä¿®æ”¹è®¾å¤‡æ ‘1ã€æŸ¥çœ‹ioå¼•è„šä¿¡æ¯ 2ã€å°†ioä¿¡æ¯åŠ å…¥è®¾å¤‡æ ‘123456789 pinCtrl: gpioCtrl&#123; compatible = &quot;raspberrypi,model-zero-w&quot;, &quot;brcm,bcm2835&quot;; label = &quot;2022&quot;; pinctrl-name =&quot;ledGpioCtrl&quot;; wodfa=&quot;null!&quot;; gpios = &lt;&amp;gpio 20 GPIO_ACTIVE_LOW &amp;gpio 21 GPIO_ACTIVE_LOW&gt;;&#125;; 3ã€ç¼–è¯‘å¹¶æ›´æ–°è®¾å¤‡æ ‘1make dtbs äºŒã€ç¼–å†™é©±åŠ¨ä¸åº”ç”¨ç¨‹åº1ã€ç¼–å†™é©±åŠ¨ç¨‹åº123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;linux/kernel.h&gt;#include&lt;linux/module.h&gt;#include&lt;linux/miscdevice.h&gt;#include&lt;linux/fs.h&gt;#include&lt;linux/export.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_address.h&gt;#include &lt;linux/of_gpio.h&gt;#include &lt;linux/gpio.h&gt;#define LEDOFF 0 #define LEDON 1 struct gpioled_dev &#123; struct device_node *nd; int led_gpio; int led_gpio1;&#125;;struct gpioled_dev gpioled;static int misc_open(struct inode *node, struct file *fp)&#123; fp-&gt;private_data = &amp;gpioled; printk(KERN_DEBUG &quot;this dev is open\\n&quot;); return 0;&#125;static int misc_close(struct inode *node, struct file *fp)&#123; printk(KERN_DEBUG &quot;this dev is close\\n&quot;); return 0;&#125;ssize_t misc_read(struct file *fp, char __user *buf, size_t size, loff_t *loff)&#123; printk(KERN_DEBUG &quot;this dev is read\\n&quot;); return 0;&#125;ssize_t misc_write(struct file *fp, const char __user *buf, size_t size, loff_t *loff)&#123; int retvalue=0; unsigned char databuf[1]; unsigned char ledstat; struct gpioled_dev *dev = fp-&gt;private_data; printk(KERN_DEBUG &quot;this dev is write\\n&quot;); retvalue = copy_from_user(databuf, buf, size); if(retvalue &lt; 0) &#123; printk(KERN_DEBUG &quot;kernel write failed!\\r\\n&quot;); return -EFAULT; &#125; ledstat = databuf[0]; if(ledstat == LEDON) &#123; gpio_set_value(dev-&gt;led_gpio, 0); gpio_set_value(dev-&gt;led_gpio1, 1); printk(KERN_DEBUG &quot;driver: LED ON\\n&quot;); &#125; else if(ledstat == LEDOFF) &#123; gpio_set_value(dev-&gt;led_gpio, 1); gpio_set_value(dev-&gt;led_gpio1, 0); printk(KERN_DEBUG &quot;driver: LED OFF\\n&quot;); &#125; return 0;&#125;struct file_operations fops = &#123; .owner=THIS_MODULE, .open=misc_open, .read=misc_read, .write=misc_write, .release=misc_close,&#125;;struct miscdevice mymisc=&#123; .minor=MISC_DYNAMIC_MINOR, .name=&quot;mymisc&quot;, .fops=&amp;fops,&#125;;static int __init misc_init(void)&#123; int ret = 0; gpioled.nd = of_find_node_by_path(&quot;/gpioCtrl&quot;); if(gpioled.nd == NULL) &#123; printk(KERN_DEBUG &quot;gpioCtrl node not find!\\n&quot;); return -EINVAL; &#125; else &#123; printk(KERN_DEBUG &quot;gpioCtrl node find!\\n&quot;); &#125; gpioled.led_gpio = of_get_named_gpio(gpioled.nd, &quot;gpios&quot;, 0); gpioled.led_gpio1 = of_get_named_gpio(gpioled.nd, &quot;gpios&quot;, 1); if(gpioled.led_gpio &lt; 0) &#123; printk(KERN_DEBUG &quot;can&#x27;t get gpios&quot;); return -EINVAL; &#125; printk(KERN_DEBUG &quot;gpios num = %d\\n&quot;, gpioled.led_gpio); printk(KERN_DEBUG &quot;gpios num = %d\\n&quot;, gpioled.led_gpio1); ret = gpio_direction_output(gpioled.led_gpio, 1); gpio_direction_output(gpioled.led_gpio1, 1); if(ret &lt; 0) &#123; printk(KERN_DEBUG &quot;can&#x27;t set gpio!\\n&quot;); &#125; if(misc_register(&amp;mymisc)) &#123; printk(KERN_DEBUG &quot;this module is insmod fail\\n&quot;); return -1; &#125; printk(KERN_DEBUG &quot;this module is success\\n&quot;); return 0;&#125;static void __exit misc_exit(void)&#123; misc_deregister(&amp;mymisc); printk(&quot;this module is exit\\r\\n&quot;);&#125;module_init(misc_init);module_exit(misc_exit);MODULE_LICENSE(&quot;GPL&quot;); 2ã€ç¼–å†™åº”ç”¨ç¨‹åº123456789101112131415161718192021222324252627282930313233343536#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[])&#123; int fd , retvalue, j=0; char *filename = &quot;/dev/mymisc&quot;; fd = open(filename, O_RDWR); if(fd &lt; 0) &#123; printf(&quot;file %s open failed!\\n&quot;, filename); return -1; &#125; unsigned char on[1] = &#123;1&#125;, off[1] = &#123;0&#125;; int len = sizeof(unsigned char); while (1) &#123; write(fd, on, len); printf(&quot;led on!\\n&quot;); sleep(5); write(fd, off, len); printf(&quot;led off!\\n&quot;); sleep(5); &#125; close(fd); return 0;&#125; 3ã€ç¼–å†™Makefile123456789101112KDIR := /media/dataDisk/lufahai/raspberry/linux-5.10obj-m := misc.oappfile :=app.cbuild: kernel_moduleskernel_modules: make -C $(KDIR) M=$(PWD) modules ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- arm-linux-gnueabihf-gcc app.c -o appclean: rm -rf *.ko *.o *.mod.o *.mod.c *.symvers modul* .tmp_* .misc* *.mod 4ã€åŠ è½½é©±åŠ¨å¹¶éªŒè¯ä¸‰ã€é—®é¢˜åŠè§£å†³1ã€appç¨‹åºå‡ºç°æ®µé”™è¯¯issueï¼š åœ¨è¿›è¡Œäº¤å‰ç¼–è¯‘åï¼Œç›´æ¥æŠŠå¯æ‰§è¡Œæ–‡ä»¶æ”¾åˆ°æ ‘è“æ´¾ä¸Šè¿è¡Œä¼šå‡ºç°æ®µé”™è¯¯ï¼Œåº”è¯¥å’Œç¼–è¯‘å™¨ç‰ˆæœ¬æœ‰å…³ã€‚ solveï¼š å°†æºæ–‡ä»¶æ”¾åˆ°æ ‘è“æ´¾ä¸Šç¼–è¯‘å†æ‰§è¡Œã€‚","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[å®è·µ]","slug":"Linuxé©±åŠ¨-å®è·µ","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linuxé©±åŠ¨[å®è·µ]:03--æ ‘è“æ´¾GPIOé©±åŠ¨PWDå‘¼å¸ç¯","slug":"linuxDrive/Linuxé©±åŠ¨-å®è·µ-03-æ ‘è“æ´¾GPIOé©±åŠ¨PWDå‘¼å¸ç¯","date":"2022-11-01T07:14:02.000Z","updated":"2022-11-03T01:41:22.907Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-å®è·µ-03-æ ‘è“æ´¾GPIOé©±åŠ¨PWDå‘¼å¸ç¯/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-03-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E9%A9%B1%E5%8A%A8PWD%E5%91%BC%E5%90%B8%E7%81%AF/","excerpt":"","text":"ä¸€ã€æ ‘è“æ´¾ä¸Šçš„PWM1ã€ç¡¬ä»¶èµ„æºæ ‘è“æ´¾æ‰©å±•æ¥å£å…±æœ‰4ä¸ªGPIOå¼•å‡ºPWMï¼Œå…·ä½“å¦‚ä¸‹ 2ã€å¯ç”¨pwmæ ‘è“æ´¾å†…æ ¸é»˜è®¤æœªå¯ç”¨pwm,ä¹Ÿå°±æ˜¯æ— æ³•é€šè¿‡Linuxå†…æ ¸è·å–åˆ°pwmèµ„æºï¼Œéœ€è¦å…ˆå¯ç”¨ï¼š 123sudo vim /boot/config.txt åœ¨æœ€åä¸€è¡ŒåŠ å…¥ï¼š dtoverlay=pwmsudo reboot é‡å¯åæŸ¥çœ‹pwmç¡®è®¤å·²å¯ç”¨ï¼š æ–¹æ³•1ï¼š 1lsmod | grep pwm æ–¹æ³•2ï¼š 1ls /sys/class/pwm/ 3ã€pwmä½¿ç”¨æ­¥éª¤1) è¯·æ±‚pwm0çš„èµ„æº 2) è®¾ç½®è„‰å†²å‘¨æœŸ 3) è®¾ç½®å ç©ºæ¯” 4) æ‰“å¼€pwm0 4ã€æŒ‡ä»¤æ§åˆ¶pwm123456789cd /sys/class/pwm/pwmchip0/echo 0 &gt; export #load pwmecho 10000000 &gt; pwm0/period #set period as 10msecho 8000000 &gt; pwm0/duty_cycle #set duty as 8msecho 1 &gt; pwm0/enable #enable pwmecho 0 &gt; pwm0/enable #disable pwmecho 0 &gt; unexport #unload pwm äºŒã€Linuxé©±åŠ¨æ§åˆ¶pwm1ã€pwmç›¸å…³çš„API12345678910111213141516171819202122232425262728293031323334353637383940// PWM channel objectstruct pwm_device &#123; const char *label; // name of the PWM device unsigned long flags; // flags associated with the PWM device unsigned int hwpwm; // per-chip relative index of the PWM device unsigned int pwm; // global index of the PWM device struct pwm_chip *chip; // PWM chip providing this PWM device void *chip_data; // chip-private data associated with the PWM device struct pwm_args args; // PWM arguments struct pwm_state state; // curent PWM channel state&#125;;/*** é€šè¿‡pwmé€šé“å·è·å–pwmé€šé“å¯¹è±¡* @pwm_id é€šé“å·* @label pwmé€šé“åˆ«å*/struct pwm_device *pwm_request(int pwm_id, const char *label);/*** é‡Šæ”¾pwmé€šé“å¯¹è±¡*/void pwm_free(struct pwm_device *pwm);/*** è®¾ç½®pwmé€šé“çš„ç›¸å…³å‚æ•°* @duty_ns ä»¥çº³ç§’ä¸ºå•ä½çš„å ç©ºæ¯”* @period_ns ä»¥çº³ç§’ä¸ºå•ä½çš„è„‰å†²å‘¨æœŸ*/int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)/*** æ‰“å¼€pwmé€šé“ï¼Œå¼€å§‹è¾“å‡ºè„‰å†²*/int pwm_enable(struct pwm_device *pwm)/*** å…³é—­pwmé€šé“ï¼Œåœæ­¢è¾“å‡ºè„‰å†²*/void pwm_disable(struct pwm_device *pwm) 2ã€é©±åŠ¨ç¨‹åºæ¡ˆä¾‹12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/miscdevice.h&gt;#include &lt;linux/pwm.h&gt;#define PWMLED_PERIOD 1000000 // è„‰å†²å‘¨æœŸå›ºå®šä¸º1ms#define PWMLED_MAX_BRIGHTNESS 1000typedef enum &#123; PWMLED_CMD_SET_BRIGHTNESS = 0x1, PWMLED_CMD_GET_BRIGHTNESS,&#125; pwmled_cmd_t;static struct &#123; struct pwm_device* pwm; unsigned int brightness;&#125; pwmled;long pwmled_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) &#123;switch (cmd) &#123;case PWMLED_CMD_SET_BRIGHTNESS: // æ‰€è°“è°ƒèŠ‚äº®åº¦ï¼Œå°±æ˜¯é…ç½®å ç©ºæ¯”ï¼Œç„¶åä½¿èƒ½pwm0 pwmled.brightness = arg &lt; PWMLED_MAX_BRIGHTNESS ? arg : PWMLED_MAX_BRIGHTNESS; pwm_config(pwmled.pwm, pwmled.brightness * 1000, PWMLED_PERIOD); if (pwmled.brightness &gt; 0) &#123; pwm_enable(pwmled.pwm); &#125; else &#123; pwm_disable(pwmled.pwm); &#125;case PWMLED_CMD_GET_BRIGHTNESS: return pwmled.brightness;default: return -EINVAL;&#125;return pwmled.brightness;&#125;static struct file_operations fops = &#123; .owner = THIS_MODULE, .unlocked_ioctl = pwmled_ioctl,&#125;;static struct miscdevice dev = &#123; .minor = 0, .name = &quot;pwmled&quot;, .fops = &amp;fops, .nodename = &quot;pwmled&quot;, .mode = 0666,&#125;;int __init pwmled_init(void) &#123;// è¯·æ±‚PWM0é€šé“struct pwm_device* pwm = pwm_request(0, &quot;pwm0&quot;);if (IS_ERR_OR_NULL(pwm)) &#123; printk(KERN_ERR &quot;failed to request pwm\\n&quot;); return PTR_ERR(pwm);&#125;pwmled.pwm = pwm;pwmled.brightness = 0;misc_register(&amp;dev); return 0;&#125;module_init(pwmled_init);void __exit pwmled_exit(void) &#123; misc_deregister(&amp;dev); // åœæ­¢å¹¶é‡Šæ”¾PWM0é€šé“ pwm_disable(pwmled.pwm); pwm_free(pwmled.pwm);&#125;module_exit(pwmled_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); 3ã€æµ‹è¯•ç¨‹åº12345678910111213141516171819202122232425int main(int argc, char* argv[]) &#123; int fd = open(&quot;/dev/pwmled&quot;, O_RDWR); int brightness = 0; char key = 0; while ((key = getchar()) != &#x27;q&#x27;) &#123; switch (key) &#123; case &#x27;=&#x27;: brightness += brightness &lt; PWMLED_MAX_BRIGHTNESS ? 10 : 0; break; case &#x27;-&#x27;: brightness -= brightness &gt; 0 ? 10 : 0; break; &#125; if (ioctl(fd, PWMLED_CMD_SET_BRIGHTNESS, brightness) &lt; 0) &#123; perror(&quot;ioctl&quot;); break; &#125; &#125; close(fd); return 0;&#125;","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[å®è·µ]","slug":"Linuxé©±åŠ¨-å®è·µ","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linuxé©±åŠ¨[å®è·µ]:02--æ ‘è“æ´¾GPIOé©±åŠ¨ä¸­æ–­","slug":"linuxDrive/Linuxé©±åŠ¨-å®è·µ-02-æ ‘è“æ´¾GPIOé©±åŠ¨ä¸­æ–­","date":"2022-11-01T07:13:09.000Z","updated":"2022-11-02T13:31:08.570Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-å®è·µ-02-æ ‘è“æ´¾GPIOé©±åŠ¨ä¸­æ–­/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-02-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E9%A9%B1%E5%8A%A8%E4%B8%AD%E6%96%AD/","excerpt":"","text":"ä¸€ã€å®ç°IOå¼•è„šä¸Šå‡æ²¿ä¸­æ–­æ­¥éª¤1) è®¾ç½®GPIOå¤ç”¨åŠŸèƒ½ä¸ºè¾“å…¥æ¨¡å¼ gpio_request() 2) è·å–GPIOå¯¹åº”çš„ä¸­æ–­å· gpio_to_irq() 3) ç”³è¯·ä¸­æ–­å·ã€ä¸­æ–­ç±»å‹ã€ç»‘å®šå¤„ç†å‡½æ•° request_irq() 4) é‡Šæ”¾ä¸­æ–­(å¸è½½é©±åŠ¨æ—¶) free_irq() äºŒã€GPIOæ“ä½œç›¸å…³çš„æ¥å£12345678910111213141516171819#include &lt;linux/gpio.h&gt;struct gpio &#123; unsigned gpio; // GPIOç¼–å· unsigned long flags; // GPIOå¤ç”¨åŠŸèƒ½é…ç½® const char *label; // GPIOæ ‡ç­¾å&#125;;// å•ä¸ªGPIOèµ„æºç”³è¯·/é‡Šæ”¾int gpio_request_one(unsigned gpio, unsigned long flags, const char *label);void gpio_free(unsigned gpio);// å¤šä¸ªGPIOèµ„æºç”³è¯·/é‡Šæ”¾int gpio_request_array(const struct gpio *array, size_t num);void gpio_free_array(const struct gpio *array, size_t num);// GPIOçŠ¶æ€è¯»å†™int gpio_get_value(unsigned gpio);void gpio_set_value(unsigned gpio, int value); ä¸‰ã€æŒ‰é”®é˜²æŠ–1ã€Linuxé©±åŠ¨é˜²æŠ–å’Œå•ç‰‡æœºé˜²æŠ–å¯¹æ¯”å•ç‰‡æœºå®ç°æŒ‰é”®é˜²æŠ–æ— éå°±æ˜¯sleep 50msï¼Œå†ç¡®è®¤æ˜¯å¦çœŸçš„æŒ‰ä¸‹ã€‚ ä½†æ˜¯Linuxæ˜¯ä¸€ä¸ªå¤šä»»åŠ¡ç³»ç»Ÿï¼Œæ°¸è¿œä¸è¦è¯•å›¾åœ¨ä¸­æ–­å‡½æ•°ä¸­ç¡çœ ï¼Œé˜²æŠ–åªèƒ½æ”¾åœ¨Linuxä¸­æ–­çš„åº•åŠéƒ¨ã€‚ æ­¤å¤–Linuxé©±åŠ¨ä¸­æ…ç”¨ç¡çœ å‡½æ•°ï¼Œé™¤éä½ å¾ˆæ¸…æ¥šå®ƒä¸æ˜¯å¿™ç­‰å¾…ã€‚ Linuxä¸‹é˜²æŠ–çš„é€»è¾‘åº”è¯¥æ˜¯è§¦å‘ä¸­æ–­åï¼Œè®©å‡ºCPUèµ„æº50msï¼Œç„¶åå†ç¡®è®¤ã€‚ 2ã€Linuxåº•åŠéƒ¨æœºåˆ¶1) è½¯ä¸­æ–­ï¼Œæ˜¯æœ‰å†…æ ¸è½¯ä»¶æ¨¡æ‹Ÿçš„ä¸€ç§ä¸­æ–­æœºåˆ¶ï¼Œæ³¨æ„ä¸è¦å’ŒARMæŒ‡ä»¤è§¦å‘çš„ä¸­æ–­æ··æ·†ï¼Œåè€…æœ¬è´¨ä¸Šæ˜¯ç¡¬ä¸­æ–­ 2) tasklet åŸºäºè½¯ä¸­æ–­å®ç°çš„ä¸­æ–­è°ƒåº¦æœºåˆ¶ï¼Œæœ¬è´¨ä¸Šè¿˜æ˜¯ä¸­æ–­ï¼Œä¸å…è®¸åœ¨å¤„ç†å‡½æ•°ä¸­sleep 3) å·¥ä½œé˜Ÿåˆ—ï¼Œç±»ä¼¼äºtaskletï¼ŒåŒºåˆ«åœ¨äºå·¥ä½œé˜Ÿåˆ—åº•å±‚åŸºäºçº¿ç¨‹ï¼Œå¯ä»¥åœ¨å¤„ç†å‡½æ•°ä¸­sleep 4) çº¿ç¨‹IRQï¼Œä¸ç”¨è§£é‡Šäº†ï¼Œå°±æ˜¯ä¸ªçº¿ç¨‹ã€‚ 3ã€å·¥ä½œé˜Ÿåˆ—API1234567891011121314151617181920#include &lt;linux/workqueue.h&gt;// å·¥ä½œé˜Ÿåˆ—åŸå‹struct work_struct &#123; atomic_long_t data; struct list_head entry; work_func_t func;#ifdef CONFIG_LOCKDEP struct lockdep_map lockdep_map;#endif&#125;;// å·¥ä½œé˜Ÿåˆ—å›è°ƒå‡½æ•°åŸå‹typedef void (*work_func_t)(struct work_struct *work);// åˆå§‹åŒ–ä¸€ä¸ªå·¥ä½œé˜Ÿåˆ—ï¼Œç»‘å®šå›è°ƒINIT_WORK(work, func);// å¯åŠ¨é˜Ÿåˆ—ï¼Œä¹‹åä¼šç”±å†…æ ¸å®Œæˆè°ƒåº¦schedule_work(&amp;my_wq); 4ã€å®šæ—¶å™¨API1234567891011121314151617181920212223242526272829303132#include &lt;linux/timer.h&gt;// å…¨å±€å˜é‡// è®°å½•ä¸Šç”µåå®šæ—¶å™¨ä¸­æ–­æ¬¡æ•°ï¼Œä¹Ÿå°±æ˜¯å¼€æœºæ—¶é•¿ï¼Œä½†ä¸æ˜¯å¾®ç§’æˆ–çº³ç§’çš„æ¦‚å¿µextern unsigned long volatile jiffies;// è¡¨ç¤ºCPUä¸€ç§’é’Ÿæœ‰å¤šå°‘ä¸ªå®šæ—¶å™¨ä¸­æ–­#define HZ 1000// ç®€å•æ¥è¯´ï¼Œå¦‚æœè¦å®šä¹‰ä¸€ä¸ª100msçš„å»¶æ—¶ï¼Œç›¸å½“äºä»¥ä¸‹å…¬å¼ï¼š// jiffies + (HZ/10)// ç›¸å½“äºä»¥ç°åœ¨çš„jiffiesåšåç§»ï¼Œè€Œ1sçš„ååˆ†ä¹‹ä¸€å°±æ˜¯100ms// å®šæ—¶å™¨åŸå‹struct timer_list &#123; struct hlist_node entry; unsigned long expires; void (*function)(struct timer_list *); u32 flags;#ifdef CONFIG_LOCKDEP struct lockdep_map lockdep_map;#endif&#125;;// å‘å†…æ ¸æ³¨å†Œä¸€ä¸ªå®šæ—¶å™¨#define timer_setup(timer, callback, flags)void add_timer(struct timer_list *timer);// å‘å†…æ ¸åˆ é™¤ä¸€ä¸ªå®šæ—¶å™¨int del_timer(struct timer_list *timer);// ä¿®æ”¹å®šæ—¶å™¨çš„ä¸‹æ¬¡çš„jiffiesint mod_timer(struct timer_list *timer, unsigned long expires) ä¸‰ã€å®Œæ•´ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/miscdevice.h&gt; // æ··æ‚è®¾å¤‡ç›¸å…³ç»“æ„#include &lt;linux/gpio.h&gt; // å„ç§gpioçš„æ•°æ®ç»“æ„åŠå‡½æ•°#include &lt;linux/interrupt.h&gt; // å†…æ ¸ä¸­æ–­ç›¸å…³æ¥å£#include &lt;linux/workqueue.h&gt;#include &lt;linux/timer.h&gt;// å®šä¹‰æŒ‰é”®çš„GPIOå¼•è„šstatic const struct gpio key = &#123; .gpio = 17, // å¼•è„šå·ä¸ºBCM - 17 .flags = GPIOF_IN, // åŠŸèƒ½å¤ç”¨ä¸ºè¾“å…¥ .label = &quot;Key0&quot; // æ ‡ç¤ºä¸ºKey0&#125;;// å®šä¹‰ä¸‰è‰²LEDçš„GPIOå¼•è„šstatic const struct gpio leds[] = &#123; &#123; 2, GPIOF_OUT_INIT_HIGH, &quot;LED_RED&quot; &#125;, &#123; 3, GPIOF_OUT_INIT_HIGH, &quot;LED_GREEN&quot; &#125;, &#123; 4, GPIOF_OUT_INIT_HIGH, &quot;LED_BLUE&quot; &#125;,&#125;;static unsigned int keyirq = 0; // GPIOæŒ‰é”®ä¸­æ–­å·static struct work_struct keywork; // æŒ‰é”®å·¥ä½œé˜Ÿåˆ—static struct timer_list timer; // å®šæ—¶å™¨ä½œä¸ºä¸­æ–­å»¶æ—¶// æŒ‰é”®ä¸­æ–­â€œé¡¶åŠéƒ¨â€å¤„ç†å‡½æ•°ï¼Œå¯ç”¨å·¥ä½œé˜Ÿåˆ—static irqreturn_t on_key_press(int irq, void* dev)&#123; schedule_work(&amp;keywork); return IRQ_HANDLED;&#125;// æŒ‰é”®ä¸­æ–­â€œåº•åŠéƒ¨â€å·¥ä½œé˜Ÿåˆ—ï¼Œå¯åŠ¨ä¸€ä¸ª50msçš„å»¶æ—¶å®šæ—¶å™¨void start_timer(struct work_struct *work)&#123; mod_timer(&amp;timer, jiffies + (HZ/20));&#125;// æŒ‰é”®é˜²æŠ–å®šæ—¶å™¨ï¼ŒåŠå¤„ç†å‡½æ•°void on_delay_50ms(struct timer_list *timer)&#123; static int i = 0; if (gpio_get_value(key.gpio)) &#123; gpio_set_value(leds[i].gpio, 0); i = ++i == 3 ? 0 : i; gpio_set_value(leds[i].gpio, 1); &#125;&#125;static int __init gpiokey_init(void)&#123; int rc = 0; // å‘å†…æ ¸ç”³è¯·GPIO if ((rc = gpio_request_one(key.gpio, key.flags, key.label)) &lt; 0 || (rc = gpio_request_array(leds, 3)) &lt; 0) &#123; printk(KERN_ERR &quot;ERROR%d: cannot request gpio\\n&quot;, rc); return rc; &#125; // è·å–ä¸­æ–­å· keyirq = gpio_to_irq(key.gpio); if (keyirq &lt; 0) &#123; printk(KERN_ERR &quot;can not get irq num.\\n&quot;); return -EFAULT; &#125; // ç”³è¯·ä¸Šå‡æ²¿è§¦å‘ if (request_irq(keyirq, on_key_press, IRQF_TRIGGER_RISING, &quot;onKeyPress&quot;, NULL) &lt; 0) &#123; printk(KERN_ERR &quot;can not request irq\\n&quot;); return -EFAULT; &#125; // åˆå§‹åŒ–æŒ‰é”®ä¸­æ–­åº•åŠéƒ¨(å·¥ä½œé˜Ÿåˆ—) INIT_WORK(&amp;keywork, start_timer); // åˆå§‹åŒ–å®šæ—¶å™¨ timer_setup(&amp;timer, on_delay_50ms, 0); add_timer(&amp;timer); return 0;&#125;module_init(gpiokey_init);static void __exit gpiokey_exit(void)&#123; free_irq(keyirq, NULL); gpio_free_array(leds, 3); gpio_free(key.gpio); del_timer(&amp;timer);&#125;module_exit(gpiokey_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;);","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[å®è·µ]","slug":"Linuxé©±åŠ¨-å®è·µ","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linuxé©±åŠ¨[å®è·µ]:01--æ ‘è“æ´¾GPIOé©±åŠ¨LED","slug":"linuxDrive/Linuxé©±åŠ¨-å®è·µ-01-æ ‘è“æ´¾GPIOé©±åŠ¨LED","date":"2022-11-01T07:12:47.000Z","updated":"2022-11-02T01:15:56.026Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-å®è·µ-01-æ ‘è“æ´¾GPIOé©±åŠ¨LED/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-01-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E9%A9%B1%E5%8A%A8LED/","excerpt":"","text":"ä¸€ã€Linuxä¸­çš„åœ°å€Linuxå†…æ ¸ä¸­ï¼Œåˆä¸‰ç§åœ°å€:æ€»çº¿åœ°å€ã€ç‰©ç†åœ°å€å’Œè™šæ‹Ÿåœ°å€ã€‚ 1) æ€»çº¿åœ°å€ï¼š ä¸€ç§è®¡ç®—æœºæ€»çº¿ï¼ŒCPUæˆ–è€…æœ‰DMAèƒ½åŠ›çš„å•å…ƒä¸­çš„å†…å­˜ç»„ä»¶æˆ–è€…ç‰©ç†åœ°å€åœ¨æ€»çº¿ä¸Šæœ‰ç›¸å¯¹åº”çš„åœ°å€ã€‚ æ¯”å¦‚CPUçš„å¯„å­˜å™¨ä¹Ÿä¼šåœ¨æ€»çº¿ä¸Šæœ‰å•ç‹¬çš„åœ°å€ï¼Œä½†æ˜¯æ€»çº¿åœ°å€ä¸ç­‰äºçœŸå®çš„å¯„å­˜å™¨ã€‚ åˆæ¯”å¦‚ç±»ä¼¼äºIICè®¾å¤‡åœ¨IICæ€»çº¿ä¸Šçš„åœ°å€ã€‚æ€»çº¿çš„å®½åº¦å†³å®šäº†CPUèƒ½å¤Ÿè®¿é—®å†…å­˜çš„èŒƒå›´ï¼Œ32ä½çš„æœ€å¤§åªèƒ½è¯†åˆ«4Gçš„å†…å­˜ï¼› 1) ç‰©ç†åœ°å€ï¼š ç¡¬ä»¶ä¸­çš„å®é™…åœ°å€æˆ–ç»å¯¹åœ°å€:æ¯”å¦‚ç£ç›˜åœ°å€ï¼Œæ¯”å¦‚51çš„å¯„å­˜å™¨ï¼Œå°±æ˜¯ç‰©ç†åœ°å€ï¼› 2) è™šæ‹Ÿåœ°å€ï¼š æ“ä½œç³»ç»Ÿè¿è¡Œåœ¨ä¿æŠ¤æ¨¡å¼ä¸‹æ‰€ä½¿ç”¨çš„åœ°å€ï¼Œä¹Ÿå«é€»è¾‘åœ°å€ï¼Œå®ƒæ˜¯åŸºäºç®—æ³•çš„ï¼Œå¤„äºè½¯ä»¶å±‚é¢ã€‚ æ ‘è“æ´¾IOå£çš„åœ°å€ä»‹ç»æ˜¯ç‰©ç†åœ°å€ï¼ŒæŒ‚è½½åˆ°Linuxå†…æ ¸è™šæ‹Ÿåœ°å€ï¼Œç¼–ç¨‹ä½¿ç”¨çš„æ˜¯è™šæ‹Ÿåœ°å€ã€‚ äºŒã€æ ‘è“æ´¾GPIOå¯„å­˜å™¨åœ°å€1ã€GPFSELx IOå£æ¨¡å¼é…ç½®å¯„å­˜å™¨Address ï¼šå¯„å­˜å™¨çš„åŸºåœ°å€ï¼Œä¹Ÿæ˜¯å¯„å­˜å™¨çš„ç‰©ç†åœ°å€ï¼›Field Name:å¯„å­˜å™¨åï¼›Descriptin: å¯„å­˜å™¨è¯´æ˜ï¼› GPFSEL0 æ˜¯ pin0 ~ pin9çš„é…ç½®å¯„å­˜å™¨ï¼ŒGPFSEL1æ˜¯pin10 ~ pin19çš„é…ç½®å¯„å­˜å™¨ï¼Œä»¥æ­¤ç±»æ¨ï¼ŒGPFSEL5å°±æ˜¯pin50 ~ pin53çš„é…ç½®å¯„å­˜å™¨ã€‚æ¯ä¸ªpinåœ¨å¯„å­˜å™¨ä¸Šçš„ä½ç½®åŠæ¨¡å¼è¯´æ˜ï¼š 2ã€GPSET0,GPSET1 IOè®¾ç½®å¯„å­˜å™¨ GPSET0: pin0~pin31çš„è®¾ç½®å¯„å­˜å™¨ï¼Œ1ä½é«˜ç”µå¹³ï¼Œ0ä¸ºä½ç”µå¹³ï¼Œå¤ä½åä¸º0ï¼š GPSET1: pin32~pin53çš„è®¾ç½®å¯„å­˜å™¨ï¼Œ1ä½é«˜ç”µå¹³ï¼Œ0ä¸ºä½ç”µå¹³ï¼Œå¤ä½åä¸º0ï¼š 3ã€GPCLR0,GPCLR1 IOå£æ¸…é™¤å¯„å­˜å™¨ GPCLR0: pin0~pin31çš„æ¸…é™¤å¯„å­˜å™¨ï¼Œ1ä½é«˜ç”µå¹³ï¼Œ0ä¸ºä½ç”µå¹³ï¼Œå¤ä½åä¸º0ï¼› GPCLR1: pin31~pin54çš„æ¸…é™¤å¯„å­˜å™¨ï¼Œ1ä½é«˜ç”µå¹³ï¼Œ0ä¸ºä½ç”µå¹³ï¼Œå¤ä½åä¸º0ï¼› æœ‰è¿™ä¸‰ç§å¯„å­˜å™¨ï¼Œå°±æ“ä½œæ ‘è“æ´¾çš„IOå£è¾“å…¥é«˜ä½ç”µå¹³äº†ï¼Œä½†æ˜¯ä¸è¦å¿˜äº†ï¼Œæ“ä½œæ ‘è“æ´¾çš„IOæ˜¯æ“ä½œè™šæ‹Ÿåœ°å€ï¼Œè€Œä¸æ˜¯ä¸Šé¢çš„ 0x7E20â€¦ï¼Œå› æ­¤åœ¨ç¼–ç¨‹ä¹‹å‰ä¸€å®šè¦æŸ¥çœ‹ç‰©ç†åœ°å€çš„æ˜ å°„ ä½¿ç”¨ï¼š 1cat /proc/iomem æ ‘è“æ´¾3Bå¯¹ 0x7e200000çš„æ˜ å°„åœ¨è™šæ‹Ÿåœ°å€ 0x3f200000ä¸Šã€‚æ‰€ä»¥ç¼–ç¨‹æ—¶ï¼Œä»¥ä¸Šå‡ ç§å¯„å­˜å™¨çš„åŸºåœ°å€åº”è¯¥æ˜¯ï¼š0x3f20000; äºŒã€GPIOé©±åŠ¨LEDæ¡ˆä¾‹1ã€é©±åŠ¨ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;asm/io.h&gt;#define BCM2837_GPIO_BASE 0x3F200000#define BCM2837_GPIO_FSEL0_OFFSET 0x0#define BCM2837_GPIO_SET0_OFFSET 0x1C#define BCM2837_GPIO_CLR0_OFFSET 0x28#define LED_RED_PIN 2#define LED_GREEN_PIN 3#define LED_BLUE_PIN 4static void* gpio = 0;static bool ledstate[3] = &#123;0&#125;;static struct &#123;const char* name; const bool pins[3];&#125; colors[] = &#123; &#123; &quot;white&quot;, &#123;1,1,1&#125; &#125;, &#123; &quot;black&quot;, &#123;0,0,0&#125; &#125;, &#123; &quot;red&quot;, &#123;1,0,0&#125; &#125;, &#123; &quot;green&quot;, &#123;0,1,0&#125; &#125;, &#123; &quot;blue&quot;, &#123;0,0,1&#125; &#125;, &#123; &quot;yellow&quot;, &#123;1,1,0&#125; &#125;, &#123; &quot;cyan&quot;, &#123;0,1,1&#125; &#125;, &#123; &quot;purple&quot;, &#123;1,0,1&#125; &#125;,&#125;;void gpioctl(int pin, bool stat)&#123; void* reg = gpio + (stat ? BCM2837_GPIO_SET0_OFFSET : BCM2837_GPIO_CLR0_OFFSET); ledstate[pin-2] = stat; iowrite32(1 &lt;&lt; pin, reg);&#125;ssize_t rgbled_read(struct file* filp, char __user* buf, size_t len, loff_t* off)&#123; int rc = 0; int i = 0; /* if file has been read, return */ if (*off &gt; 0) &#123; return 0; &#125; for (i = 0; i &lt; sizeof(colors) / sizeof(colors[0]); i++) &#123; const char* name = colors[i].name; const bool* pins = colors[i].pins; if (ledstate[0] == pins[0] &amp;&amp; ledstate[1] == pins[1] &amp;&amp; ledstate[2] == pins[2]) &#123; char color[32] = &#123;0&#125;; sprintf(color, &quot;%s\\n&quot;, name); *off = strlen(color); rc = copy_to_user(buf, color, *off); return rc &lt; 0 ? rc : *off; &#125; &#125; return -EFAULT;&#125;ssize_t rgbled_write(struct file* filp, const char __user* buf, size_t len, loff_t* off)&#123; char color[32] = &#123;0&#125;; int rc = 0; int i = 0; rc = copy_from_user(color, buf, len); if (rc &lt; 0) &#123; return rc; &#125; /* reset offset after read */ *off = 0; for (i = 0; i &lt; sizeof(colors) / sizeof(colors[0]); i++) &#123; const char* name = colors[i].name; const bool* pins = colors[i].pins; if (!strncasecmp(color, name, strlen(name))) &#123; gpioctl(LED_RED_PIN, pins[0]); gpioctl(LED_GREEN_PIN, pins[1]); gpioctl(LED_BLUE_PIN, pins[2]); return len; &#125; &#125; return -EINVAL;&#125;// ç”¨æˆ·å±‚é€šè¿‡ioctlå‡½æ•°å•ç‹¬æ§åˆ¶ç¯çš„çŠ¶æ€long rgbled_ioctl(struct file* filp, unsigned int cmd, unsigned long arg)&#123; if (cmd &gt;= 2 &amp;&amp; cmd &lt;= 4) &#123; gpioctl(cmd, arg); &#125; else &#123; return -ENODEV; &#125; return 0;&#125;static const struct file_operations fops = &#123; .owner = THIS_MODULE, .read = rgbled_read, .write = rgbled_write, .unlocked_ioctl = rgbled_ioctl,&#125;;static dev_t devno = 0;static struct cdev cdev;static int __init rgbled_init(void)&#123; // æ˜ å°„GPIOç‰©ç†å†…å­˜åˆ°è™šæ‹Ÿåœ°å€ï¼Œå¹¶å°†å…¶ç½®ä¸ºâ€œè¾“å‡ºæ¨¡å¼â€ // ä»£ç å†™å¾—æ¯”è¾ƒä¸‘ï¼Œè§£é‡Šä»¥ä¸‹ï¼š // å°±æ˜¯å…ˆæŠŠä¸‰ä¸ªGPIOçš„â€œåŠŸèƒ½é€‰æ‹©ä½â€å…¨éƒ¨ç½®000 // ç„¶åå†å°†å…¶ç½®ä¸º001 int val = ~((7 &lt;&lt; (LED_RED_PIN*3)) | (7 &lt;&lt; (LED_GREEN_PIN*3)) | (7 &lt;&lt; LED_BLUE_PIN*3)); gpio = ioremap(BCM2837_GPIO_BASE, 0xB0); val &amp;= ioread32(gpio + BCM2837_GPIO_FSEL0_OFFSET); val |= (1 &lt;&lt; (LED_RED_PIN*3)) | (1 &lt;&lt; (LED_GREEN_PIN*3)) | (1 &lt;&lt; (LED_BLUE_PIN*3)); iowrite32(val, gpio); if (alloc_chrdev_region(&amp;devno, 0, 1, &quot;rgbled&quot;)) &#123; printk(KERN_ERR&quot;failed to register kernel module!\\n&quot;); return -1; &#125; cdev_init(&amp;cdev, &amp;fops); cdev_add(&amp;cdev, devno, 1); printk(KERN_INFO&quot;rgbled device major &amp; minor is [%d:%d]\\n&quot;, MAJOR(devno), MINOR(devno)); return 0;&#125;module_init(rgbled_init);static void __exit rgbled_exit(void)&#123; // å–æ¶ˆgpioç‰©ç†å†…å­˜æ˜ å°„ iounmap(gpio); // é‡Šæ”¾å­—ç¬¦è®¾å¤‡ cdev_del(&amp;cdev); unregister_chrdev_region(devno, 1); printk(KERN_INFO&quot;rgbled free\\n&quot;);&#125;module_exit(rgbled_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); 2ã€æµ‹è¯•ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;int main(int argc, char* argv[])&#123; if (argc &lt; 3) &#123; fprintf(stderr, &quot;\\n./rgbled_test &lt;r|g|b&gt; &lt;0|1&gt;\\n\\n&quot;); exit(0); &#125; int fd = open(&quot;/dev/rgbled&quot;, O_RDWR); if (fd &lt; 0) &#123; perror(&quot;open device&quot;); return -1; &#125; switch (argv[1][0]) &#123; case &#x27;r&#x27;: case &#x27;R&#x27;: ioctl(fd, 2, atoi(argv[2])); break; case &#x27;g&#x27;: case &#x27;G&#x27;: ioctl(fd, 3, atoi(argv[2])); break; case &#x27;b&#x27;: case &#x27;B&#x27;: ioctl(fd, 4, atoi(argv[2])); break; &#125; close(fd); return 0;&#125;","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[å®è·µ]","slug":"Linuxé©±åŠ¨-å®è·µ","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linuxé©±åŠ¨[ç†è®º]:15--Linuxè®¾å¤‡é©±åŠ¨è°ƒè¯•","slug":"linuxDrive/Linuxé©±åŠ¨-ç†è®º-15-Linuxè®¾å¤‡é©±åŠ¨è°ƒè¯•","date":"2022-11-01T05:16:20.000Z","updated":"2022-11-01T07:41:19.234Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-ç†è®º-15-Linuxè®¾å¤‡é©±åŠ¨è°ƒè¯•/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-15-Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95/","excerpt":"","text":"","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[ç†è®º]","slug":"Linuxé©±åŠ¨-ç†è®º","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linuxé©±åŠ¨[ç†è®º]:14--ARM Linuxè®¾å¤‡æ ‘","slug":"linuxDrive/Linuxé©±åŠ¨-ç†è®º-14-ARM-Linuxè®¾å¤‡æ ‘","date":"2022-11-01T05:15:59.000Z","updated":"2022-11-01T07:10:58.668Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-ç†è®º-14-ARM-Linuxè®¾å¤‡æ ‘/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-14-ARM-Linux%E8%AE%BE%E5%A4%87%E6%A0%91/","excerpt":"","text":"","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[ç†è®º]","slug":"Linuxé©±åŠ¨-ç†è®º","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linuxé©±åŠ¨[ç†è®º]:13--I2C SPI USBæ¶æ„ç±»æ¯”","slug":"linuxDrive/Linuxé©±åŠ¨-ç†è®º-13-I2C-SPI-USBæ¶æ„ç±»æ¯”","date":"2022-11-01T05:15:31.000Z","updated":"2022-11-01T07:10:54.792Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-ç†è®º-13-I2C-SPI-USBæ¶æ„ç±»æ¯”/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-13-I2C-SPI-USB%E6%9E%B6%E6%9E%84%E7%B1%BB%E6%AF%94/","excerpt":"","text":"","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[ç†è®º]","slug":"Linuxé©±åŠ¨-ç†è®º","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linuxé©±åŠ¨[ç†è®º]:12--USBä¸»æœºåŠè®¾å¤‡ä¸Gadgeté©±åŠ¨","slug":"linuxDrive/Linuxé©±åŠ¨-ç†è®º-12-USBä¸»æœºåŠè®¾å¤‡ä¸Gadgeté©±åŠ¨","date":"2022-11-01T05:14:51.000Z","updated":"2022-11-01T07:10:51.660Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-ç†è®º-12-USBä¸»æœºåŠè®¾å¤‡ä¸Gadgeté©±åŠ¨/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-12-USB%E4%B8%BB%E6%9C%BA%E5%8F%8A%E8%AE%BE%E5%A4%87%E4%B8%8EGadget%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[ç†è®º]","slug":"Linuxé©±åŠ¨-ç†è®º","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linuxé©±åŠ¨[ç†è®º]:11--I2Cæ ¸å¿ƒåŠæ€»çº¿ä¸è®¾å¤‡é©±åŠ¨","slug":"linuxDrive/Linuxé©±åŠ¨-ç†è®º-11-I2Cæ ¸å¿ƒåŠæ€»çº¿ä¸è®¾å¤‡é©±åŠ¨","date":"2022-11-01T05:14:15.000Z","updated":"2022-11-01T07:10:48.396Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-ç†è®º-11-I2Cæ ¸å¿ƒåŠæ€»çº¿ä¸è®¾å¤‡é©±åŠ¨/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-11-I2C%E6%A0%B8%E5%BF%83%E5%8F%8A%E6%80%BB%E7%BA%BF%E4%B8%8E%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[ç†è®º]","slug":"Linuxé©±åŠ¨-ç†è®º","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linuxé©±åŠ¨[ç†è®º]:10--ç½‘ç»œè®¾å¤‡","slug":"linuxDrive/Linuxé©±åŠ¨-ç†è®º-10-ç½‘ç»œè®¾å¤‡","date":"2022-11-01T05:13:24.000Z","updated":"2022-11-01T07:10:45.564Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-ç†è®º-10-ç½‘ç»œè®¾å¤‡/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-10-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/","excerpt":"","text":"","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[ç†è®º]","slug":"Linuxé©±åŠ¨-ç†è®º","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linuxé©±åŠ¨[ç†è®º]:09--å—è®¾å¤‡é©±åŠ¨","slug":"linuxDrive/Linuxé©±åŠ¨-ç†è®º-09-å—è®¾å¤‡é©±åŠ¨","date":"2022-11-01T05:13:10.000Z","updated":"2022-11-01T07:10:42.460Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-ç†è®º-09-å—è®¾å¤‡é©±åŠ¨/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-09-%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[ç†è®º]","slug":"Linuxé©±åŠ¨-ç†è®º","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linuxé©±åŠ¨[ç†è®º]:08--è®¾å¤‡é©±åŠ¨è½¯ä»¶æ¶æ„","slug":"linuxDrive/Linuxé©±åŠ¨-ç†è®º-08-è®¾å¤‡é©±åŠ¨è½¯ä»¶æ¶æ„","date":"2022-11-01T05:12:54.000Z","updated":"2022-11-01T07:10:38.952Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-ç†è®º-08-è®¾å¤‡é©±åŠ¨è½¯ä»¶æ¶æ„/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-08-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/","excerpt":"","text":"","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[ç†è®º]","slug":"Linuxé©±åŠ¨-ç†è®º","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linuxé©±åŠ¨[ç†è®º]:07--å†…å­˜ä¸IOè®¿é—®","slug":"linuxDrive/Linuxé©±åŠ¨-ç†è®º-07-å†…å­˜ä¸IOè®¿é—®","date":"2022-11-01T05:12:27.000Z","updated":"2022-11-01T07:10:35.764Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-ç†è®º-07-å†…å­˜ä¸IOè®¿é—®/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-07-%E5%86%85%E5%AD%98%E4%B8%8EIO%E8%AE%BF%E9%97%AE/","excerpt":"","text":"","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[ç†è®º]","slug":"Linuxé©±åŠ¨-ç†è®º","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linuxé©±åŠ¨[ç†è®º]:06--æ—¶é’Ÿ","slug":"linuxDrive/Linuxé©±åŠ¨-ç†è®º-06-æ—¶é’Ÿ","date":"2022-11-01T05:12:18.000Z","updated":"2022-11-01T07:37:20.934Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-ç†è®º-06-æ—¶é’Ÿ/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-06-%E6%97%B6%E9%92%9F/","excerpt":"","text":"ä¸€ã€å†…æ ¸å®šæ—¶å™¨ç¼–ç¨‹1ã€åˆå§‹åŒ–å®šæ—¶å™¨4.14ä¹‹å‰çš„å†…æ ¸ç‰ˆæœ¬ä½¿ç”¨ä»¥ä¸‹æ–¹å¼åˆå§‹åŒ–ï¼š 12init_timer(&amp;second_devp-&gt;s_timer);second_devp-&gt;s_timer.function = &amp;second_timer_handler; 4.14ä¹‹åçš„å†…æ ¸ç‰ˆæœ¬ä½¿ç”¨ä»¥ä¸‹æ–¹å¼åˆå§‹åŒ–ï¼š 1timer_setup(&amp;second_devp-&gt;s_timer, second_timer_handler, 0); 2ã€å¢åŠ å®šæ—¶å™¨1void add_timer(struct timer_list *list); ç”¨äºæ³¨å†Œå†…æ ¸å®šæ—¶å™¨ï¼Œå°†å®šæ—¶å™¨åŠ å…¥åˆ°å†…æ ¸åŠ¨æ€å®šæ—¶å™¨é“¾è¡¨ä¸­ã€‚ 3ã€åˆ é™¤å®šæ—¶å™¨1void del_timer(struct timer_list *list); ç”¨äºåˆ é™¤å®šæ—¶å™¨ï¼Œå…¶ä¸­del_timer_sync()æ˜¯ä¸Šè¿°å‡½æ•°çš„åŒæ­¥ç‰ˆï¼Œåœ¨åˆ é™¤ä¸€ä¸ªå®šæ—¶å™¨æ—¶éœ€è¦ç­‰å¾…å…¶è¢«å¤„ç†å®Œï¼Œ å› æ­¤è¯¥å‡½æ•°çš„è°ƒç”¨ä¸èƒ½å‘ç”Ÿåœ¨ä¸­æ–­ä¸Šä¸‹æ–‡ä¸­ã€‚ 4ã€ä¿®æ”¹å®šæ—¶å™¨çš„expire1int mod_timer(struct timer_list *list, unsigned long expires); ç”¨äºä¿®æ”¹å®šæ—¶å™¨çš„åˆ°æœŸæ—¶é—´ï¼Œåœ¨æ–°çš„è¢«ä¼ å…¥çš„expireåˆ°æ¥åæ‰ä¼šæ‰§è¡Œå®šæ—¶å™¨å‡½æ•°ã€‚ 5ã€å†…æ ¸å®šæ—¶å™¨æ¨¡æ¿12345678910111213141516171819202122232425262728293031323334struct xxx_dev &#123; struct cdev cdev; ... struct timer_list s_timer;&#125;;static int xxx_fun1(...)&#123; struct xxx_dev *dev = file-&gt;private_data; /* åˆå§‹åŒ–å®šæ—¶å™¨ */ timer_setup(&amp;second_devp-&gt;s_timer, second_timer_handler, 0); second_devp-&gt;s_timer.expires = jiffies + HZ; /* æ³¨å†Œå®šæ—¶å™¨ */ add_timer(&amp;second_devp-&gt;s_timer); ....&#125;static int xxx_fun2(...)&#123; .... /* åˆ é™¤å®šæ—¶å™¨ */ del_timer(&amp;second_devp-&gt;s_timer); ....&#125;static void xxx_timer_handler(struct timer_list *timer)&#123; /* è°ƒåº¦å®šæ—¶å™¨å†æ¬¡æ‰§è¡Œ */ mod_timer(&amp;second_devp-&gt;s_timer, jiffies + HZ); atomic_inc(&amp;second_devp-&gt;counter);&#125; äºŒã€å®ä¾‹ï¼šç§’å­—ç¬¦è®¾å¤‡1ã€é©±åŠ¨å±‚ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/mm.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/timer.h&gt;#include &lt;linux/uaccess.h&gt;#define SECOND_MAJOR 234static int second_major = SECOND_MAJOR;module_param(second_major, int, S_IRUGO);struct second_dev &#123; struct cdev cdev; atomic_t counter; struct timer_list s_timer;&#125;;static struct second_dev *second_devp;static void second_timer_handler(struct timer_list *timer)&#123; printk(KERN_INFO &quot;current jiffies is %ld\\n&quot;, jiffies); mod_timer(&amp;second_devp-&gt;s_timer, jiffies + HZ); atomic_inc(&amp;second_devp-&gt;counter);&#125;static int second_open(struct inode *inode, struct file *filp)&#123; timer_setup(&amp;second_devp-&gt;s_timer, second_timer_handler, 0); second_devp-&gt;s_timer.expires = jiffies + HZ; add_timer(&amp;second_devp-&gt;s_timer); atomic_set(&amp;second_devp-&gt;counter, 0); return 0;&#125;static int second_release(struct inode *inode, struct file *filp)&#123; del_timer(&amp;second_devp-&gt;s_timer); return 0;&#125;static ssize_t second_read(struct file *filp, char __user * buf, size_t count, loff_t * ppos)&#123; int counter; counter = atomic_read(&amp;second_devp-&gt;counter); if (put_user(counter, (int *)buf)) return -EFAULT; else return sizeof(unsigned int);&#125;static const struct file_operations second_fops = &#123; .owner = THIS_MODULE, .open = second_open, .release = second_release, .read = second_read,&#125;;static void second_setup_cdev(struct second_dev *dev, int index)&#123; int err, devno = MKDEV(second_major, index); cdev_init(&amp;dev-&gt;cdev, &amp;second_fops); dev-&gt;cdev.owner = THIS_MODULE; err = cdev_add(&amp;dev-&gt;cdev, devno, 1); if (err) printk(KERN_ERR &quot;Failed to add second device\\n&quot;);&#125;static int __init second_init(void)&#123; int ret; dev_t devno = MKDEV(second_major, 0); if (second_major) ret = register_chrdev_region(devno, 1, &quot;second&quot;); else &#123; ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;second&quot;); second_major = MAJOR(devno); &#125; if (ret &lt; 0) return ret; second_devp = kzalloc(sizeof(*second_devp), GFP_KERNEL); if (!second_devp) &#123; ret = -ENOMEM; goto fail_malloc; &#125; second_setup_cdev(second_devp, 0); return 0;fail_malloc: unregister_chrdev_region(devno, 1); return ret;&#125;module_init(second_init);static void __exit second_exit(void)&#123; cdev_del(&amp;second_devp-&gt;cdev); kfree(second_devp); unregister_chrdev_region(MKDEV(second_major, 0), 1);&#125;module_exit(second_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); 2ã€åº”ç”¨å±‚æµ‹è¯•ä»£ç 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;sys/stat.h&gt;int main()&#123; int fd; unsigned int counter = 0; unsigned int old_counter = 0; fd = open(&quot;/dev/second&quot;, O_RDONLY); if (fd &lt; 0) &#123; printf(&quot;Device open failure\\n&quot;); return -1; &#125; while (1) &#123; read(fd, &amp;counter, sizeof(unsigned int)); if(counter!= old_counter) &#123; printf(&quot;seconds after open /dev/second :%d\\n&quot;, counter); old_counter = counter; &#125; msleep(200); &#125; return 0;&#125;","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[ç†è®º]","slug":"Linuxé©±åŠ¨-ç†è®º","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linuxé©±åŠ¨[ç†è®º]:05--ä¸­æ–­å¤„ç†","slug":"linuxDrive/Linuxé©±åŠ¨-ç†è®º-05-ä¸­æ–­å¤„ç†","date":"2022-11-01T05:11:40.000Z","updated":"2022-11-01T07:10:28.276Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-ç†è®º-05-ä¸­æ–­å¤„ç†/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-05-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/","excerpt":"","text":"","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[ç†è®º]","slug":"Linuxé©±åŠ¨-ç†è®º","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linuxé©±åŠ¨[ç†è®º]:04--å¼‚æ­¥é€šçŸ¥ä¸å¼‚æ­¥IO","slug":"linuxDrive/Linuxé©±åŠ¨-ç†è®º-04-å¼‚æ­¥é€šçŸ¥ä¸å¼‚æ­¥IO","date":"2022-11-01T05:11:11.000Z","updated":"2022-11-01T07:10:25.416Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-ç†è®º-04-å¼‚æ­¥é€šçŸ¥ä¸å¼‚æ­¥IO/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-04-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5%E4%B8%8E%E5%BC%82%E6%AD%A5IO/","excerpt":"","text":"","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[ç†è®º]","slug":"Linuxé©±åŠ¨-ç†è®º","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linuxé©±åŠ¨[ç†è®º]:03--é˜»å¡ä¸éé˜»å¡IO","slug":"linuxDrive/Linuxé©±åŠ¨-ç†è®º-03-é˜»å¡ä¸éé˜»å¡IO","date":"2022-11-01T05:10:52.000Z","updated":"2022-11-01T07:40:56.399Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-ç†è®º-03-é˜»å¡ä¸éé˜»å¡IO/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-03-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EIO/","excerpt":"","text":"","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[ç†è®º]","slug":"Linuxé©±åŠ¨-ç†è®º","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linuxé©±åŠ¨[ç†è®º]:02--é©±åŠ¨å¹¶å‘æ§åˆ¶","slug":"linuxDrive/Linuxé©±åŠ¨-ç†è®º-02-é©±åŠ¨å¹¶å‘æ§åˆ¶","date":"2022-11-01T05:10:30.000Z","updated":"2022-11-01T08:01:11.585Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-ç†è®º-02-é©±åŠ¨å¹¶å‘æ§åˆ¶/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-02-%E9%A9%B1%E5%8A%A8%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/","excerpt":"","text":"ä¸€ã€é©±åŠ¨çš„å¹¶å‘æ§åˆ¶1ã€åŸå› 1) å¤šè¿›ç¨‹ã€å¤šçº¿ç¨‹ç¨‹åºæ‰§è¡Œæ—¶ä¼šå‡ºç°å¹¶å‘ä¸ç«æ€çš„æƒ…å†µã€‚ 2) ç¨‹åºåœ¨ç¼–è¯‘å’Œæ‰§è¡Œé˜¶æ®µå¯èƒ½ä¼šå‡ºç°â€œç¼–è¯‘ä¹±åºâ€å’Œâ€œæ‰§è¡Œä¹±åºâ€çš„é—®é¢˜ 2ã€è§£å†³æ–¹æ³•1) ä¸­æ–­å±è”½ 2) åŸå­æ“ä½œ 3) è‡ªæ—‹é” 4) ä¿¡å·é‡ 5) äº’æ–¥ä½“ 6) å®Œæˆé‡ 3ã€åŠ å…¥å¹¶å‘æ§åˆ¶çš„å­—ç¬¦è®¾å¤‡é©±åŠ¨ç¨‹åº123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/uaccess.h&gt;#define GLOBALMEM_SIZE 0x1000#define MEM_CLEAR 0x1#define GLOBALMEM_MAJOR 230static int globalmem_major = GLOBALMEM_MAJOR;module_param(globalmem_major, int, S_IRUGO);struct globalmem_dev &#123; struct cdev cdev; unsigned char mem[GLOBALMEM_SIZE]; struct mutex mutex;&#125;;struct globalmem_dev *globalmem_devp;static int globalmem_open(struct inode *inode, struct file *filp)&#123; filp-&gt;private_data = globalmem_devp; return 0;&#125;int globalmem_release(struct inode *inode, struct file *filp)&#123; return 0;&#125;static long globalmem_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; struct globalmem_dev *dev = filp-&gt;private_data; switch (cmd) &#123; case MEM_CLEAR: mutex_lock(&amp;dev-&gt;mutex); memset(dev-&gt;mem, 0, GLOBALMEM_SIZE); mutex_unlock(&amp;dev-&gt;mutex); printk(KERN_INFO &quot;globalmem is set to zero\\n&quot;); break; default: return -EINVAL; &#125; return 0;&#125;static ssize_t globalmem_read(struct file *filp, char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; mutex_lock(&amp;dev-&gt;mutex); if (copy_to_user(buf, dev-&gt;mem + p, count)) &#123; ret = -EFAULT; &#125; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;read %u bytes(s) from %lu\\n&quot;, count, p); &#125; mutex_unlock(&amp;dev-&gt;mutex); return ret;&#125;static ssize_t globalmem_write(struct file *filp, const char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; mutex_lock(&amp;dev-&gt;mutex); if (copy_from_user(dev-&gt;mem + p, buf, count)) ret = -EFAULT; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;written %u bytes(s) from %lu\\n&quot;, count, p); &#125; mutex_unlock(&amp;dev-&gt;mutex); return ret;&#125;static loff_t globalmem_llseek(struct file *filp, loff_t offset, int orig)&#123; loff_t ret = 0; switch (orig) &#123; case 0: if (offset &lt; 0) &#123; ret = -EINVAL; break; &#125; if ((unsigned int)offset &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos = (unsigned int)offset; ret = filp-&gt;f_pos; break; case 1: if ((filp-&gt;f_pos + offset) &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; if ((filp-&gt;f_pos + offset) &lt; 0) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos += offset; ret = filp-&gt;f_pos; break; default: ret = - EINVAL; break; &#125; return ret;&#125;static const struct file_operations globalmem_fops = &#123; .owner = THIS_MODULE, .llseek = globalmem_llseek, .read = globalmem_read, .write = globalmem_write, .unlocked_ioctl = globalmem_ioctl, .open = globalmem_open, .release = globalmem_release,&#125;;static void globalmem_setup_cdev(struct globalmem_dev *dev, int index)&#123; int err, devno = MKDEV(globalmem_major, index); cdev_init(&amp;dev-&gt;cdev, &amp;globalmem_fops); dev-&gt;cdev.owner = THIS_MODULE; err = cdev_add(&amp;dev-&gt;cdev, devno, 1); if (err) printk(KERN_NOTICE &quot;Error %d adding globalmem%d&quot;, err, index);&#125;static int __init globalmem_init(void)&#123; int ret; dev_t devno = MKDEV(globalmem_major, 0); if (globalmem_major) ret = register_chrdev_region(devno, 1, &quot;globalmem&quot;); else &#123; ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;globalmem&quot;); globalmem_major = MAJOR(devno); &#125; if (ret &lt; 0) return ret; globalmem_devp = kzalloc(sizeof(struct globalmem_dev), GFP_KERNEL); if (!globalmem_devp) &#123; ret = -ENOMEM; goto fail_malloc; &#125; globalmem_setup_cdev(globalmem_devp, 0); mutex_init(&amp;globalmem_devp-&gt;mutex); return 0;fail_malloc: unregister_chrdev_region(devno, 1); return ret;&#125;module_init(globalmem_init);static void __exit globalmem_exit(void)&#123; cdev_del(&amp;globalmem_devp-&gt;cdev); kfree(globalmem_devp); unregister_chrdev_region(MKDEV(globalmem_major, 0), 1);&#125;module_exit(globalmem_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;);","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[ç†è®º]","slug":"Linuxé©±åŠ¨-ç†è®º","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linuxé©±åŠ¨[ç†è®º]:01--å­—ç¬¦è®¾å¤‡é©±åŠ¨","slug":"linuxDrive/Linuxé©±åŠ¨-ç†è®º-01-å­—ç¬¦è®¾å¤‡é©±åŠ¨","date":"2022-11-01T05:10:04.000Z","updated":"2022-11-01T07:40:37.964Z","comments":true,"path":"2022/11/01/linuxDrive/Linuxé©±åŠ¨-ç†è®º-01-å­—ç¬¦è®¾å¤‡é©±åŠ¨/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-01-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"ä¸€ã€å­—ç¬¦è®¾å¤‡é©±åŠ¨çš„ç»„æˆ1ã€æ¨¡å—åŠ è½½ä¸å¸è½½å‡½æ•°åŠ è½½å‡½æ•°ï¼š å®ç°è®¾å¤‡å·çš„ç”³è¯·å’Œcdevçš„æ³¨å†Œã€‚ å¸è½½å‡½æ•°ï¼š å®ç°è®¾å¤‡å·çš„é‡Šæ”¾cdevçš„æ³¨é”€ã€‚ 12345678910111213141516171819202122232425262728293031struct xxx_dev_t &#123; struct cdev cdev;&#125; xxx_dev;/* åŠ è½½å‡½æ•° */static int __init xxx_init(void) &#123; ... cdev_init(&amp;xxx_dev.cdev, &amp;xxx_fops); xxx_dev.cdev.owner = THIS_MODULE; /* è·å–å­—ç¬¦è®¾å¤‡å· */ if (xxx_major) &#123; register_chrdev_region(xxx_dev_no, 1, DEV_NAME); &#125; else &#123; alloc_chrdev_region(&amp;xxx_dev_no, 0, 1, DEV_NAME); &#125; ret = cdev_add(&amp;xxx_dev.cdev, &amp;xxx_dev_no, 1); ...&#125;/* å¸è½½å‡½æ•° */static void __exit xxx_exit(void) &#123; unregister_chrdev_region(xxx_dev_no, 1); cdev_del(&amp;xxx_dev.cdev); ...&#125; 2ã€file_operationsç»“æ„ä½“ä¸­çš„æˆå‘˜å‡½æ•°1234567891011121314151617181920212223242526272829303132333435/* device read */ssize_t xxx_read(struct file *fp, char __user *buf, size_t size, loff_t *loff)&#123; ... copy_to_user(buf, ..., ...); ...&#125;/* device write */ssize_t xxx_write(struct file *fp, char __user *buf, size_t size, loff_t *loff)&#123; ... copy_from_user(buf, ..., ...); ...&#125;/* ioctrl */long xxx_ioctrl(struct file *fp, unsigned int cmd, unsigned long arg)&#123; ... switch(cmd) &#123; case xxx_CMD1: .... break; case xxx_CMD2: .... break; default: return -ENOTTY; break; &#125; return 0;&#125; 3ã€å­—ç¬¦è®¾å¤‡é©±åŠ¨çš„ç»“æ„å›¾ äºŒã€å­—ç¬¦è®¾å¤‡é©±åŠ¨å®ä¾‹1ã€ç¼–å†™å­—ç¬¦è®¾å¤‡é©±åŠ¨ç¨‹åº123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/uaccess.h&gt;#define GLOBALMEM_SIZE 0x1000#define MEM_CLEAR 0x1#define GLOBALMEM_MAJOR 230static int globalmem_major = GLOBALMEM_MAJOR;module_param(globalmem_major, int, S_IRUGO);struct globalmem_dev &#123; struct cdev cdev; unsigned char mem[GLOBALMEM_SIZE];&#125;;struct globalmem_dev *globalmem_devp;static int globalmem_open(struct inode *inode, struct file *filp)&#123; filp-&gt;private_data = globalmem_devp; return 0;&#125;static int globalmem_release(struct inode *inode, struct file *filp)&#123; return 0;&#125;static long globalmem_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; struct globalmem_dev *dev = filp-&gt;private_data; switch (cmd) &#123; case MEM_CLEAR: memset(dev-&gt;mem, 0, GLOBALMEM_SIZE); printk(KERN_INFO &quot;globalmem is set to zero\\n&quot;); break; default: return -EINVAL; &#125; return 0;&#125;static ssize_t globalmem_read(struct file *filp, char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; if (copy_to_user(buf, dev-&gt;mem + p, count)) &#123; ret = -EFAULT; &#125; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;read %u bytes(s) from %lu\\n&quot;, count, p); &#125; return ret;&#125;static ssize_t globalmem_write(struct file *filp, const char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; if (copy_from_user(dev-&gt;mem + p, buf, count)) ret = -EFAULT; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;written %u bytes(s) from %lu\\n&quot;, count, p); &#125; return ret;&#125;static loff_t globalmem_llseek(struct file *filp, loff_t offset, int orig)&#123; loff_t ret = 0; switch (orig) &#123; case 0: if (offset &lt; 0) &#123; ret = -EINVAL; break; &#125; if ((unsigned int)offset &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos = (unsigned int)offset; ret = filp-&gt;f_pos; break; case 1: if ((filp-&gt;f_pos + offset) &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; if ((filp-&gt;f_pos + offset) &lt; 0) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos += offset; ret = filp-&gt;f_pos; break; default: ret = -EINVAL; break; &#125; return ret;&#125;static const struct file_operations globalmem_fops = &#123; .owner = THIS_MODULE, .llseek = globalmem_llseek, .read = globalmem_read, .write = globalmem_write, .unlocked_ioctl = globalmem_ioctl, .open = globalmem_open, .release = globalmem_release,&#125;;static void globalmem_setup_cdev(struct globalmem_dev *dev, int index)&#123; int err, devno = MKDEV(globalmem_major, index); cdev_init(&amp;dev-&gt;cdev, &amp;globalmem_fops); dev-&gt;cdev.owner = THIS_MODULE; err = cdev_add(&amp;dev-&gt;cdev, devno, 1); if (err) printk(KERN_NOTICE &quot;Error %d adding globalmem%d&quot;, err, index);&#125;static int __init globalmem_init(void)&#123; int ret; dev_t devno = MKDEV(globalmem_major, 0); if (globalmem_major) ret = register_chrdev_region(devno, 1, &quot;globalmem&quot;); else &#123; ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;globalmem&quot;); globalmem_major = MAJOR(devno); &#125; if (ret &lt; 0) return ret; globalmem_devp = kzalloc(sizeof(struct globalmem_dev), GFP_KERNEL); if (!globalmem_devp) &#123; ret = -ENOMEM; goto fail_malloc; &#125; globalmem_setup_cdev(globalmem_devp, 0); return 0;fail_malloc: unregister_chrdev_region(devno, 1); return ret;&#125;module_init(globalmem_init);static void __exit globalmem_exit(void)&#123; cdev_del(&amp;globalmem_devp-&gt;cdev); kfree(globalmem_devp); unregister_chrdev_region(MKDEV(globalmem_major, 0), 1);&#125;module_exit(globalmem_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); 2ã€åœ¨ç”¨æˆ·ç©ºé—´ä¸­è®¤è¯1) åŠ è½½ç¨‹åº 1sudo insmod globalmem.ko 2) åˆ›å»ºèŠ‚ç‚¹ 1sudo mknod /dev/globalmem c 230 0 3) å†™å…¥å­—ç¬¦ 1echo &quot;hello Linux drive world&quot; &gt; /dev/globalmem 4) æŸ¥çœ‹å­—ç¬¦ 1cat /dev/globalmem 3ã€é™„å½•1ã€å¤šä¸ªé©±åŠ¨å­—ç¬¦è®¾å¤‡é©±åŠ¨ç¨‹åº123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/uaccess.h&gt;#define GLOBALMEM_SIZE 0x1000#define MEM_CLEAR 0x1#define GLOBALMEM_MAJOR 230#define DEVICE_NUM 10static int globalmem_major = GLOBALMEM_MAJOR;module_param(globalmem_major, int, S_IRUGO);struct globalmem_dev &#123; struct cdev cdev; unsigned char mem[GLOBALMEM_SIZE];&#125;;struct globalmem_dev *globalmem_devp;static int globalmem_open(struct inode *inode, struct file *filp)&#123; struct globalmem_dev *dev = container_of(inode-&gt;i_cdev, struct globalmem_dev, cdev); filp-&gt;private_data = dev; return 0;&#125;static int globalmem_release(struct inode *inode, struct file *filp)&#123; return 0;&#125;static long globalmem_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; struct globalmem_dev *dev = filp-&gt;private_data; switch (cmd) &#123; case MEM_CLEAR: memset(dev-&gt;mem, 0, GLOBALMEM_SIZE); printk(KERN_INFO &quot;globalmem is set to zero\\n&quot;); break; default: return -EINVAL; &#125; return 0;&#125;static ssize_t globalmem_read(struct file *filp, char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; if (copy_to_user(buf, dev-&gt;mem + p, count)) &#123; ret = -EFAULT; &#125; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;read %u bytes(s) from %lu\\n&quot;, count, p); &#125; return ret;&#125;static ssize_t globalmem_write(struct file *filp, const char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; if (copy_from_user(dev-&gt;mem + p, buf, count)) ret = -EFAULT; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;written %u bytes(s) from %lu\\n&quot;, count, p); &#125; return ret;&#125;static loff_t globalmem_llseek(struct file *filp, loff_t offset, int orig)&#123; loff_t ret = 0; switch (orig) &#123; case 0: if (offset &lt; 0) &#123; ret = -EINVAL; break; &#125; if ((unsigned int)offset &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos = (unsigned int)offset; ret = filp-&gt;f_pos; break; case 1: if ((filp-&gt;f_pos + offset) &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; if ((filp-&gt;f_pos + offset) &lt; 0) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos += offset; ret = filp-&gt;f_pos; break; default: ret = -EINVAL; break; &#125; return ret;&#125;static const struct file_operations globalmem_fops = &#123; .owner = THIS_MODULE, .llseek = globalmem_llseek, .read = globalmem_read, .write = globalmem_write, .unlocked_ioctl = globalmem_ioctl, .open = globalmem_open, .release = globalmem_release,&#125;;static void globalmem_setup_cdev(struct globalmem_dev *dev, int index)&#123; int err, devno = MKDEV(globalmem_major, index); cdev_init(&amp;dev-&gt;cdev, &amp;globalmem_fops); dev-&gt;cdev.owner = THIS_MODULE; err = cdev_add(&amp;dev-&gt;cdev, devno, 1); if (err) printk(KERN_NOTICE &quot;Error %d adding globalmem%d&quot;, err, index);&#125;static int __init globalmem_init(void)&#123; int ret; int i; dev_t devno = MKDEV(globalmem_major, 0); if (globalmem_major) ret = register_chrdev_region(devno, DEVICE_NUM, &quot;globalmem&quot;); else &#123; ret = alloc_chrdev_region(&amp;devno, 0, DEVICE_NUM, &quot;globalmem&quot;); globalmem_major = MAJOR(devno); &#125; if (ret &lt; 0) return ret; globalmem_devp = kzalloc(sizeof(struct globalmem_dev) * DEVICE_NUM, GFP_KERNEL); if (!globalmem_devp) &#123; ret = -ENOMEM; goto fail_malloc; &#125; for (i = 0; i &lt; DEVICE_NUM; i++) globalmem_setup_cdev(globalmem_devp + i, i); return 0;fail_malloc: unregister_chrdev_region(devno, DEVICE_NUM); return ret;&#125;module_init(globalmem_init);static void __exit globalmem_exit(void)&#123; int i; for (i = 0; i &lt; DEVICE_NUM; i++) cdev_del(&amp;(globalmem_devp + i)-&gt;cdev); kfree(globalmem_devp); unregister_chrdev_region(MKDEV(globalmem_major, 0), DEVICE_NUM);&#125;module_exit(globalmem_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;);","categories":[{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linuxé©±åŠ¨[ç†è®º]","slug":"Linuxé©±åŠ¨-ç†è®º","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"ubuntu18å®‰è£…ch340é©±åŠ¨","slug":"ubuntu/ubuntu18å®‰è£…ch340é©±åŠ¨","date":"2022-10-26T12:49:31.000Z","updated":"2022-11-22T06:45:32.617Z","comments":true,"path":"2022/10/26/ubuntu/ubuntu18å®‰è£…ch340é©±åŠ¨/","link":"","permalink":"http://example.com/2022/10/26/ubuntu/ubuntu18%E5%AE%89%E8%A3%85ch340%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"ä¸€ã€å®‰è£…è¿‡ç¨‹1ã€ä¸‹è½½é©±åŠ¨ç¨‹åºå…ˆåˆ°è¿™ä¸ªç½‘ç«™ä¸‹é©±åŠ¨æºæ–‡ä»¶åŒ… https://www.wch.cn/download/CH341SER_LINUX_ZIP.html 2ã€æ›¿æ¢æºæ–‡ä»¶æ ¹æ®å†…æ ¸çš„ä¸åŒç‰ˆæœ¬ï¼Œæ›¿æ¢æ‰é‡Œè¾¹çš„æºæ–‡ä»¶ https://elixir.bootlin.com/linux/v5.4.42/source/drivers/usb/serial/ch341.c 3ã€ç¼–è¯‘åŠå®‰è£…æ ¹æ®readmeå†…å®¹çš„æç¤ºï¼Œmake &amp;&amp; sudo make load 4ã€å¼€æœºè‡ªåŠ¨åŠ è½½å°†é©±åŠ¨æ–‡ä»¶å¤åˆ¶åˆ° /lib/modules/5.4.0-42-generic/kernel/drivers/usb/serial/ ç„¶åè¿è¡Œ sudo depmod -a äºŒã€å¤šä¸ªUSBä¸²å£ç»‘å®š1ã€æŸ¥çœ‹å½“å‰USBä¸²å£ä¿¡æ¯123456789101112131415161718192021222324252627282930313233343536lufahai@station:/dev$ udevadm info /dev/ttyUSB0P: /devices/pci0000:00/0000:00:14.0/usb1/1-5/1-5:1.0/ttyUSB0/tty/ttyUSB0N: ttyUSB0L: 0S: serial/by-id/usb-1a86_USB_Serial-if00-port0S: serial/by-path/pci-0000:00:14.0-usb-0:5:1.0-port0E: DEVPATH=/devices/pci0000:00/0000:00:14.0/usb1/1-5/1-5:1.0/ttyUSB0/tty/ttyUSB0E: DEVNAME=/dev/ttyUSB0E: MAJOR=188E: MINOR=0E: SUBSYSTEM=ttyE: USEC_INITIALIZED=529937465118E: ID_BUS=usbE: ID_VENDOR_ID=1a86E: ID_MODEL_ID=7523E: ID_PCI_CLASS_FROM_DATABASE=Serial bus controllerE: ID_PCI_SUBCLASS_FROM_DATABASE=USB controllerE: ID_PCI_INTERFACE_FROM_DATABASE=XHCIE: ID_VENDOR_FROM_DATABASE=QinHeng ElectronicsE: ID_VENDOR=1a86E: ID_VENDOR_ENC=1a86E: ID_MODEL=USB_SerialE: ID_MODEL_ENC=USB\\x20SerialE: ID_REVISION=8033E: ID_SERIAL=1a86_USB_SerialE: ID_TYPE=genericE: ID_USB_INTERFACES=:ff0102:E: ID_USB_INTERFACE_NUM=00E: ID_USB_DRIVER=ch341E: ID_USB_CLASS_FROM_DATABASE=Vendor Specific ClassE: ID_MODEL_FROM_DATABASE=HL-340 USB-Serial adapterE: ID_PATH=pci-0000:00:14.0-usb-0:5:1.0E: ID_PATH_TAG=pci-0000_00_14_0-usb-0_5_1_0E: ID_MM_CANDIDATE=1E: DEVLINKS=/dev/serial/by-id/usb-1a86_USB_Serial-if00-port0 /dev/serial/by-path/pci-0000:00:14.0-usb-0:5:1.0-port0E: TAGS=:systemd: ç¬¬ä¸€è¡Œï¼Œä¸²å£åºåˆ—å·æ˜¯ 1-5:1.0 2ã€åˆ›å»ºudevé…ç½®æ–‡ä»¶1sudo gedit /etc/udev/rules.d/myserial.rules å¢åŠ ä»¥ä¸‹å†…å®¹ï¼š 1ACTION==&quot;add&quot;,KERNELS==&quot;1-5:1.0&quot;,SUBSYSTEMS==&quot;usb&quot;,MODE:=&quot;0777&quot;,SYMLINK+=&quot;stm32Serial&quot; 3ã€ä¿å­˜ä¸æ›´æ–°å…ˆæ‹”å‡ºUSBä¸²å£ï¼Œç„¶åæ‰§è¡Œä¸‹é¢æŒ‡ä»¤ï¼š 123sudo service udev reloadsudo service udev restart","categories":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"ubuntu18å®‰è£…ROS1å’ŒROS2","slug":"ubuntu/ubuntu18å®‰è£…ROS1å’ŒROS2","date":"2022-10-19T11:09:38.000Z","updated":"2022-10-27T15:13:14.361Z","comments":true,"path":"2022/10/19/ubuntu/ubuntu18å®‰è£…ROS1å’ŒROS2/","link":"","permalink":"http://example.com/2022/10/19/ubuntu/ubuntu18%E5%AE%89%E8%A3%85ROS1%E5%92%8CROS2/","excerpt":"","text":"ä¸€ã€å®‰è£…ROS11ã€æ·»åŠ æº1sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; 2ã€è®¾ç½®å…¬é’¥1sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 3ã€å®‰è£…1) å®‰è£… 12sudo apt updatesudo apt install ros-melodic-desktop-full 4ã€å®‰è£…å¿…è¦ç»„ä»¶1sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential 5ã€åˆå§‹åŒ–1sudo rosdep init å¦‚æœé‡åˆ°é—®é¢˜ï¼Œé‚£å°±åœ¨ /etc/hostsåé¢æ·»åŠ  123456789101112131415161718192021222324252627282930313233343536373839199.232.28.133 raw.githubusercontent.com192.30.253.118 gist.github.com185.199.110.153 github.io151.101.113.194 github.global.ssl.fastly.net52.216.227.168 github-cloud.s3.amazonaws.com52.74.223.119 github.com199.232.28.133 avatars1.githubusercontent.com199.232.28.133 avatars2.githubusercontent.com199.232.28.133 avatars0.githubusercontent.com199.232.28.133 avatars3.githubusercontent.com199.232.28.133 user-images.githubusercontent.com199.232.28.133 avatars.githubusercontent.com199.232.28.133 github.map.fastly.net199.232.28.133 avatars7.githubusercontent.com54.239.31.69 aws.amazon.com54.239.30.25 console.aws.amazon.com54.239.96.90 ap-northeast-1.console.aws.amazon.com54.240.226.81 ap-southeast-1.console.aws.amazon.com54.240.193.125 ap-southeast-2.console.aws.amazon.com54.239.54.102 eu-central-1.console.aws.amazon.com177.72.244.194 sa-east-1.console.aws.amazon.com176.32.114.59 eu-west-1.console.aws.amazon.com54.239.31.128 us-west-1.console.aws.amazon.com54.240.254.230 us-west-2.console.aws.amazon.com54.239.38.102 s3-console-us-standard.console.aws.amazon.com54.231.49.3 s3.amazonaws.com52.219.0.4 s3-ap-northeast-1.amazonaws.com54.231.242.170 s3-ap-southeast-1.amazonaws.com54.231.251.21 s3-ap-southeast-2.amazonaws.com54.231.193.37 s3-eu-central-1.amazonaws.com52.218.16.140 s3-eu-west-1.amazonaws.com52.92.72.2 s3-sa-east-1.amazonaws.com54.231.236.6 s3-us-west-1.amazonaws.com54.231.168.160 s3-us-west-2.amazonaws.com52.216.80.48 github-cloud.s3.amazonaws.com54.231.40.3 github-com.s3.amazonaws.com52.216.20.171 github-production-release-asset-2e65be.s3.amazonaws.com52.216.228.168 github-production-user-asset-6210df.s3.amazonaws.com æ¥ç€ä¿®æ”¹/etc/resolv.conf åœ¨å…¶åå¢åŠ  12nameserver 8.8.8.8nameserver 8.8.4.4 å†æ¬¡æ‰§è¡Œ sudo rosdep init 5ã€updateæ ¹æ®æç¤ºæ‰§è¡Œ 1rosdep update å¯èƒ½ä¼šæ˜¾ç¤ºæŠ¥é”™ read operation timed outï¼ŒåŸå› æ˜¯raw.githubusercontent.comç½‘ç«™è¢«å¢™æ‰äº†ï¼Œè§£å†³å¦‚ä¸‹ï¼š 1sudo cp -r ../ros_github/ /etc/ros/ 1) ä¿®æ”¹è·¯å¾„Pythoné…ç½®è·¯å¾„ 1sudo gedit /usr/lib/python2.7/dist-packages/rosdistro/__init__.py æ³¨é‡Šç¬¬68è¡Œè·¯å¾„ä»£ç ï¼Œç„¶åæ”¹ä¸º file:///etc/ros/ros_github/index-v4.yamlï¼Œå¦‚ä¸‹å›¾ï¼š 1) ä¿®æ”¹20-defaultè·¯å¾„ æ”¹ä¸ºä¸‹é¢çš„è·¯å¾„ï¼š 12345678sudo gedit /etc/ros/rosdep/sources.list.d/20-default.listyaml file:///etc/ros/ros_github/osx-homebrew.yaml osx#genericyaml file:///etc/ros/ros_github/base.yamlyaml file:///etc/ros/ros_github/python.yamlyaml file:///etc/ros/ros_github/ruby.yamlgbpdistro file:///etc/ros/ros_github/fuerte.yaml fuerte å†æ¬¡æ‰§è¡Œ rosdep update ä¸‰ã€å®‰è£…ROS21ã€è®¾ç½®ç¼–ç 123sudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8export LANG=en_US.UTF-8 2ã€æ›´æ–°è½¯ä»¶æº1234sudo apt update &amp;&amp; sudo apt install curl gnupg2 lsb-releasecurl http://repo.ros2.org/repos.key | sudo apt-key add -sudo sh -c &#x27;echo &quot;deb [arch=amd64,arm64] http://packages.ros.org/ros2/ubuntu `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros2-latest.list&#x27; 3ã€å®‰è£…1sudo apt install ros-dashing-desktop 4ã€å®‰è£…å…¶ä»–å·¥å…·1234567sudo apt install python3-argcompletesource /opt/ros/dashing/setup.bashsudo apt updatesudo apt install ros-dashing-ros1-bridge 3ã€é…ç½®ROS1å’ŒROS2å…±å­˜ç•Œé¢1234567891011121314#source /opt/ros/melodic/setup.bash#source /opt/ros/dashing/setup.bash# ROS 1.0 melodic or ROS 2.0 Dashingecho Hello alvin! ROS 1.0 or ROS 2.0? 1=Melodic 2=Dashing read ROSif (($ROS==1));thensource /opt/ros/melodic/setup.bashecho &quot;Melodic&quot;elif (($ROS==2));thensource /opt/ros/dashing/setup.bashecho &quot;Dashing&quot;elseecho &quot;Non-ROS&quot;fi","categories":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"è®¾è®¡æ¨¡å¼:23--è®¿é—®è€…æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-23-è®¿é—®è€…æ¨¡å¼","date":"2022-10-15T14:21:29.000Z","updated":"2022-10-21T05:56:56.309Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-23-è®¿é—®è€…æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-23-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µè¡¨ç¤ºä¸€ä¸ªä½œç”¨äºæŸå¯¹è±¡ç»“æ„ä¸­çš„å„å…ƒç´ çš„æ“ä½œï¼Œå®ƒä½¿ä½ å¯ä»¥åœ¨ä¸æ”¹å˜å„å…ƒç´ ç±»çš„å‰æä¸‹å®šä¹‰ä½œç”¨äºè¿™ä¸ªå…ƒç´ çš„æ–°æ“ä½œã€‚ 2ã€åº”ç”¨åœºæ™¯3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹11 2ã€æ¡ˆä¾‹21","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:22--æ¨¡æ¿æ–¹æ³•æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-22-æ¨¡æ¿æ–¹æ³•æ¨¡å¼","date":"2022-10-15T14:21:07.000Z","updated":"2022-10-21T05:53:20.860Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-22-æ¨¡æ¿æ–¹æ³•æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-22-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µå®šä¹‰ä¸€ä¸ªæ“ä½œä¸­çš„ç®—æ³•çš„éª¨æ¶ï¼Œè€Œå°†ä¸€äº›æ­¥éª¤å»¶è¿Ÿåˆ°å­ç±»ä¸­ï¼ŒTemplateMethodä½¿å¾—å­ç±»å¯ä»¥ä¸æ”¹å˜ä¸€ä¸ªç®—æ³•çš„ç»“æ„å³å¯ä»¥é‡å®šä¹‰è¯¥ç®—æ³•çš„æŸäº›ç‰¹å®šæ­¥éª¤ 2ã€åº”ç”¨åœºæ™¯ä¸€ä¸ªæ“ä½œçš„æ­¥éª¤ç¨³å®šï¼Œè€Œå…·ä½“ç»†èŠ‚çš„æ”¹å˜å»¶è¿Ÿçš„å­ç±» 3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹11 2ã€æ¡ˆä¾‹21","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:21--ç­–ç•¥æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-21-ç­–ç•¥æ¨¡å¼","date":"2022-10-15T14:20:44.000Z","updated":"2022-10-21T05:57:03.557Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-21-ç­–ç•¥æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-21-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µå®šä¹‰ä¸€ç³»åˆ—çš„ç®—æ³•ï¼ŒæŠŠä»–ä»¬ä¸€ä¸ªä¸ªå°è£…èµ·æ¥ï¼Œå¹¶ä½¿ä»–ä»¬å¯ä»¥äº’ç›¸æ›¿æ¢ï¼Œæœ¬æ¨¡å¼ä½¿å¾—ç®—æ³•å¯ä»¥ç‹¬ç«‹äºä½¿ç”¨å®ƒä»¬çš„å®¢æˆ·ã€‚ 2ã€åº”ç”¨åœºæ™¯3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹11 2ã€æ¡ˆä¾‹21","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:20--çŠ¶æ€æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-20-çŠ¶æ€æ¨¡å¼","date":"2022-10-15T14:20:27.000Z","updated":"2022-10-21T05:52:35.500Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-20-çŠ¶æ€æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-20-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µå…è®¸å¯¹è±¡åœ¨å…¶å†…éƒ¨çŠ¶æ€æ”¹å˜æ—¶æ”¹å˜ä»–çš„è¡Œä¸ºã€‚å¯¹è±¡çœ‹èµ·æ¥ä¼¼ä¹æ”¹å˜äº†ä»–çš„ç±»ã€‚ 2ã€åº”ç”¨åœºæ™¯ä¸€ä¸ªå¯¹è±¡çš„å†…éƒ¨çŠ¶æ€æ”¹å˜æ—¶ï¼Œä»–çš„è¡Œä¸ºå‰§çƒˆçš„å˜åŒ–ã€‚ 3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹11 2ã€æ¡ˆä¾‹21","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:19--è§‚å¯Ÿè€…æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-19-è§‚å¯Ÿè€…æ¨¡å¼","date":"2022-10-15T14:20:06.000Z","updated":"2022-10-21T05:57:20.101Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-19-è§‚å¯Ÿè€…æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-19-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µå®šä¹‰å¯¹è±¡é—´ä¸€å¯¹å¤šçš„ä¾èµ–å…³ç³»ï¼Œå½“ä¸€ä¸ªå¯¹è±¡çš„çŠ¶æ€å‘ç”Ÿæ”¹å˜æ—¶ï¼Œæ‰€æœ‰ä¾èµ–äºå®ƒçš„å¯¹è±¡éƒ½å¾—åˆ°é€šçŸ¥è‡ªåŠ¨æ›´æ–°ã€‚ 2ã€åº”ç”¨åœºæ™¯3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹11 2ã€æ¡ˆä¾‹21","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:18--å¤‡å¿˜å½•æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-18-å¤‡å¿˜å½•æ¨¡å¼","date":"2022-10-15T14:19:47.000Z","updated":"2022-10-21T05:57:22.825Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-18-å¤‡å¿˜å½•æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-18-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µåœ¨ä¸ç ´åå¯¹è±¡çš„å‰æä¸‹ï¼Œæ•è·ä¸€ä¸ªå¯¹è±¡çš„å†…éƒ¨çŠ¶æ€ï¼Œå¹¶åœ¨è¯¥å¯¹è±¡ä¹‹å¤–ä¿å­˜è¿™ä¸ªçŠ¶æ€ã€‚ 2ã€åº”ç”¨åœºæ™¯3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹11 2ã€æ¡ˆä¾‹21","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:17--ä¸­ä»‹æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-17-ä¸­ä»‹æ¨¡å¼","date":"2022-10-15T14:19:32.000Z","updated":"2022-10-21T05:57:26.293Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-17-ä¸­ä»‹æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-17-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µç”¨ä¸€ä¸ªä¸­ä»‹å¯¹è±¡å°è£…ä¸€äº›åˆ—çš„å¯¹è±¡äº¤äº’ã€‚ 2ã€åº”ç”¨åœºæ™¯3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹11 2ã€æ¡ˆä¾‹21","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:16--è¿­ä»£æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-16-è¿­ä»£æ¨¡å¼","date":"2022-10-15T14:19:03.000Z","updated":"2022-10-21T05:50:41.411Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-16-è¿­ä»£æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-16-%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µæä¾›ä¸€ä¸ªæ–¹æ³•é¡ºåºè®¿é—®ä¸€ä¸ªèšåˆå¯¹è±¡çš„å„ä¸ªå…ƒç´ ï¼Œè€Œåˆä¸éœ€è¦æš´éœ²è¯¥å¯¹è±¡çš„å†…éƒ¨è¡¨ç¤º 2ã€åº”ç”¨åœºæ™¯è¿­ä»£ã€‚ 3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹11 2ã€æ¡ˆä¾‹21","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:15--è§£é‡Šå™¨æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-15-è§£é‡Šå™¨æ¨¡å¼","date":"2022-10-15T14:18:43.000Z","updated":"2022-10-21T05:57:30.665Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-15-è§£é‡Šå™¨æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-15-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µç»™å®šä¸€ä¸ªè¯­è¨€ï¼Œå®šä¹‰ä»–çš„æ–‡æ³•çš„ä¸€ä¸ªè¡¨ç¤ºï¼Œå¹¶å®šä¹‰ä¸€ä¸ªè§£é‡Šå™¨ï¼Œè¿™ä¸ªè§£é‡Šå™¨ä½¿ç”¨è¯¥è¡¨ç¤ºæ¥è§£é‡Šè¯­è¨€ä¸­çš„å¥å­ã€‚ 2ã€åº”ç”¨åœºæ™¯3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹11 2ã€æ¡ˆä¾‹2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class Variable;class Context&#123;public: void registerVariable(Variable *var, int value) &#123; m_map.insert(&#123; var, value &#125;); &#125; int lookUpValue(Variable *var) &#123; auto itor = m_map.find(var); if (itor != m_map.end()) &#123; return itor-&gt;second; &#125; return 0; &#125;private: std::unordered_map&lt;Variable *, int&gt; m_map;&#125;;class Expression&#123;public: virtual ~Expression() &#123;&#125; virtual int interpret(Context *ctx) = 0;&#125;;class Variable : public Expression&#123;public: virtual int interpret(Context *ctx) &#123; return ctx-&gt;lookUpValue(this); &#125;&#125;;class Constant : public Expression&#123;public: Constant(int value) : m_value(value) &#123;&#125; virtual int interpret(Context *ctx) override &#123; return m_value; &#125;private: int m_value;&#125;;class Add : public Expression&#123;public: Add(Expression *left, Expression *right) : m_left(left), m_right(right) &#123;&#125; virtual int interpret(Context *ctx) override &#123; return m_left-&gt;interpret(ctx) + m_right-&gt;interpret(ctx); &#125;private: Expression *m_left, *m_right;&#125;;class Sub : public Expression&#123;public: Sub(Expression *left, Expression *right) : m_left(left), m_right(right) &#123;&#125; virtual int interpret(Context *ctx) override &#123; return m_left-&gt;interpret(ctx) - m_right-&gt;interpret(ctx); &#125;private: Expression *m_left, *m_right;&#125;;class Mul : public Expression&#123;public: Mul(Expression *left, Expression *right) : m_left(left), m_right(right) &#123;&#125; virtual int interpret(Context *ctx) override &#123; return m_left-&gt;interpret(ctx) * m_right-&gt;interpret(ctx); &#125;private: Expression *m_left, *m_right;&#125;;class Div : public Expression&#123;public: Div(Expression *left, Expression *right) : m_left(left), m_right(right) &#123;&#125; virtual int interpret(Context *ctx) override &#123; assert(m_right-&gt;interpret(ctx) != 0); return m_left-&gt;interpret(ctx) / m_right-&gt;interpret(ctx); &#125;private: Expression *m_left, *m_right;&#125;;int main()&#123; Context ctx; Variable a; Variable b; Constant c(1024); ctx.registerVariable(&amp;a, 22); ctx.registerVariable(&amp;b, 11); Expression *e1 = new Mul(&amp;a, &amp;b); //242 Expression *e2 = new Div(&amp;a, &amp;b); //1 Expression *e3 = new Add(e2, &amp;c); //1025 Expression *e = new Sub(e1, e3); std::cout &lt;&lt; e-&gt;interpret(&amp;ctx) &lt;&lt; std::endl; delete e1, e2, e3, e; return 0;&#125;","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:14--å‘½ä»¤æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-14-å‘½ä»¤æ¨¡å¼","date":"2022-10-15T14:18:23.000Z","updated":"2022-10-21T05:49:39.071Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-14-å‘½ä»¤æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-14-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µå°†ä¸€ä¸ªè¯·æ±‚å°è£…ä¸ºä¸€ä¸ªå¯¹è±¡ï¼Œä»è€Œä½¿ä½ å¯ä»¥ç”¨ä¸åŒçš„è¯·æ±‚å¯¹å®¢æˆ·è¿›è¡Œå‚æ•°åŒ–ï¼Œå¯¹è¯·æ±‚æ’é˜Ÿå’Œè®°å½•è¯·æ±‚æ—¥å¿—ï¼Œä»¥åŠæ”¯æŒå¯æ’¤é”€çš„æ“ä½œã€‚ 2ã€åº”ç”¨åœºæ™¯å°†å‘½ä»¤è€…ä¸æ‰§è¡Œè€…å®Œå…¨è§£è€¦ã€‚ 3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹11 2ã€æ¡ˆä¾‹2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class ICommand&#123;public: virtual ~ICommand() &#123;&#125; virtual void execute() = 0;&#125;;class Drawable&#123;public: virtual ~Drawable() &#123;&#125; virtual void draw(int x, int y) = 0;&#125;;class MacroCommand : public ICommand&#123;public: ~MacroCommand() &#123; clear(); &#125; virtual void execute() override &#123; for (auto cmd : m_commandList) &#123; cmd-&gt;execute(); &#125; &#125; void addCommand(ICommand *cmd) &#123; m_commandList.push_back(cmd); &#125; void clear() &#123; for (auto cmd : m_commandList) &#123; delete cmd; &#125; m_commandList.clear(); &#125; void undo() &#123; if (!m_commandList.empty()) &#123; auto cmd = m_commandList.back(); delete cmd; m_commandList.pop_back(); &#125; &#125;private: std::vector&lt;ICommand *&gt; m_commandList;&#125;;class DrawCommand : public ICommand&#123;public: DrawCommand(int x, int y, Drawable *drawable) : m_x(x), m_y(y), m_drawable(drawable) &#123;&#125; virtual void execute() override &#123; m_drawable-&gt;draw(m_x, m_y); &#125;private: int m_x; int m_y; Drawable *m_drawable;&#125;;class DrawCanvas : public Drawable&#123;public: DrawCanvas(MacroCommand *macroCommand) : m_macroCommand(macroCommand) &#123;&#125; virtual void draw(int x, int y) override &#123; std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; std::endl; &#125; void paint() &#123; m_macroCommand-&gt;execute(); &#125;private: MacroCommand *m_macroCommand;&#125;;int main()&#123; MacroCommand macroCommand; DrawCanvas canvas(&amp;macroCommand); macroCommand.addCommand(new DrawCommand(1, 2, &amp;canvas)); canvas.draw(20, 10); canvas.paint(); return 0;&#125;","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:13--è´£ä»»é“¾æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-13-è´£ä»»é“¾æ¨¡å¼","date":"2022-10-15T14:18:06.000Z","updated":"2022-10-21T05:57:35.517Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-13-è´£ä»»é“¾æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-13-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µä½¿å¤šä¸ªå¯¹è±¡éƒ½æœ‰æœºä¼šå¤„ç†è¯·æ±‚ï¼Œä»è€Œé¿å…è¯·æ±‚çš„é€å‘è€…å’Œæ¥æ”¶è€…ä¹‹é—´çš„è€¦åˆå…³ç³» 2ã€åº”ç”¨åœºæ™¯3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹11 2ã€æ¡ˆä¾‹2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class Trouble &#123;public: Trouble(int number) : m_number(number) &#123;&#125; int getNumber() const &#123; return m_number; &#125; std::string toString() const &#123; return &quot;[ Trouble &quot; + std::to_string(m_number) + &quot; ]&quot;; &#125;private: int m_number;&#125;;class Support &#123;public: virtual ~Support() &#123;&#125; Support(const std::string &amp;name) : m_name(name) &#123;&#125; Support *setNext(Support *next) &#123; m_next = next; return next; &#125; void support(Trouble *trouble) &#123; if (resolve(trouble)) done(trouble); else if (m_next) m_next-&gt;support(trouble); else fail(trouble); &#125; std::string toString() const &#123; return &quot;[&quot; + m_name + &quot;]&quot;; &#125; virtual bool resolve(Trouble *trouble) = 0;protected: void done(Trouble *trouble) &#123; std::cout &lt;&lt; trouble-&gt;toString() &lt;&lt; &quot; is solved by &quot; &lt;&lt; toString() &lt;&lt; std::endl; &#125; void fail(Trouble *trouble) &#123; std::cout &lt;&lt; trouble-&gt;toString() &lt;&lt; &quot; cannot be resolved.&quot; &lt;&lt; std::endl; &#125;private: std::string m_name; Support *m_next = nullptr;&#125;;class NoSupport : public Support &#123;public: using Support::Support; virtual bool resolve(Trouble *trouble) override &#123; return false; &#125;&#125;;class OddSupport : public Support &#123;public: using Support::Support; virtual bool resolve(Trouble *trouble) override &#123; return (trouble-&gt;getNumber() % 2 == 0); &#125;&#125;;class LimitSupport : public Support &#123;public: LimitSupport(const std::string &amp;name, int limit) : Support(name), m_limit(limit)&#123;&#125; virtual bool resolve(Trouble *trouble) override &#123; return (trouble-&gt;getNumber() &lt;= m_limit); &#125;private: int m_limit;&#125;;class SpecialSupport : public Support &#123;public: SpecialSupport(const std::string &amp;name, int num) : Support(name), m_num (num) &#123;&#125; virtual bool resolve(Trouble *trouble) override &#123; return (trouble-&gt;getNumber() == m_num); &#125; private: int m_num;&#125;;int main()&#123; Support *s1 = new NoSupport(&quot;Alance&quot;); Support *s2 = new LimitSupport(&quot;Bob&quot;, 30); Support *s3 = new OddSupport(&quot;Charlie&quot;); Support *s4 = new SpecialSupport(&quot;David&quot;, 55); s1-&gt;setNext(s2)-&gt;setNext(s3)-&gt;setNext(s4); for (int i = 0; i &lt; 100; ++i) &#123; Trouble t(i); s1-&gt;support(&amp;t); &#125; delete s1; delete s2; delete s3; delete s4; return 0;&#125;","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:12--ä»£ç†æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-12-ä»£ç†æ¨¡å¼","date":"2022-10-15T14:17:42.000Z","updated":"2022-10-21T05:57:39.993Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-12-ä»£ç†æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-12-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µä¸ºå…¶ä»–å¯¹è±¡æä¾›ä¸€ç§ä»£ç†ä»¥æ§åˆ¶å¯¹è¿™ä¸ªå¯¹è±¡çš„è®¿é—® 2ã€åº”ç”¨åœºæ™¯3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹11 2ã€æ¡ˆä¾‹2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class Printable &#123;public: virtual ~Printable() &#123;&#125; virtual void setPrinterName(const std::string &amp;name) = 0; virtual const std::string &amp;getPrinterName() const = 0; virtual void print() = 0;&#125;;class Printer : public Printable &#123;public: Printer(const std::string &amp;name) : m_name(name) &#123; heavyJob(); &#125; virtual void setPrinterName(const std::string &amp;name) override &#123; m_name = name; &#125; virtual const std::string &amp;getPrinterName() const &#123; return m_name; &#125; void print() override &#123; std::cout &lt;&lt; __FUNCTION__ &lt;&lt; getPrinterName() &lt;&lt; std::endl; &#125;private: void heavyJob() &#123; std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot; start &quot; &lt;&lt; std::endl; for (int i = 0; i &lt; 5; ++i) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(300)); &#125; std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot; end &quot; &lt;&lt; std::endl; &#125;private: std::string m_name;&#125;;class PrinterProxy : public Printable &#123;public: PrinterProxy(const std::string &amp;name) : m_name(name) &#123;&#125; ~PrinterProxy() &#123; delete m_printer; &#125; virtual void setPrinterName(const std::string &amp;name) override &#123; if (m_printer != nullptr) &#123; m_printer-&gt;setPrinterName(name); &#125; m_name = name; &#125; virtual const std::string &amp;getPrinterName() const override &#123; return m_name; &#125; void print() override &#123; if (nullptr == m_printer)&#123; m_printer = new Printer(m_name); &#125; m_printer-&gt;print(); &#125;private: Printer *m_printer = nullptr; std::string m_name;&#125;;int main()&#123; Printable *p = new PrinterProxy(&quot;123&quot;); std::cout &lt;&lt; p-&gt;getPrinterName() &lt;&lt; std::endl; p-&gt;setPrinterName(&quot;456&quot;); std::cout &lt;&lt; p-&gt;getPrinterName() &lt;&lt; std::endl; p-&gt;print(); p-&gt;setPrinterName(&quot;789&quot;); p-&gt;print(); delete p; return 0;&#125;","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:11--äº«å…ƒæ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-11-äº«å…ƒæ¨¡å¼","date":"2022-10-15T14:17:27.000Z","updated":"2022-10-21T05:57:42.773Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-11-äº«å…ƒæ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-11-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µæä¾›ä¸€ä¸ªåˆ›å»ºä¸€ç³»åˆ—ç›¸å…³æˆ–ç›¸äº’ä¾èµ–å¯¹è±¡çš„æ¥å£ï¼Œè€Œæ— é¡»æŒ‡å®šå®ƒä»¬çš„å…·ä½“ç±»ã€‚ 2ã€åº”ç”¨åœºæ™¯3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹11 2ã€æ¡ˆä¾‹2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;static const char *strList[] = &#123; &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;......##........\\n&quot; &quot;..######........\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;..##########....\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..........##....\\n&quot; &quot;......####......\\n&quot; &quot;....##..........\\n&quot; &quot;..##............\\n&quot; &quot;..##########....\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..........##....\\n&quot; &quot;......####......\\n&quot; &quot;..........##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;........##......\\n&quot; &quot;......####......\\n&quot; &quot;....##..##......\\n&quot; &quot;..##....##......\\n&quot; &quot;..########......\\n&quot; &quot;........##......\\n&quot; &quot;......######....\\n&quot; &quot;................\\n&quot;, &quot;..##########....\\n&quot; &quot;..##............\\n&quot; &quot;..##............\\n&quot; &quot;..########......\\n&quot; &quot;..........##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##............\\n&quot; &quot;..########......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;..##########....\\n&quot; &quot;..##......##....\\n&quot; &quot;..........##....\\n&quot; &quot;........##......\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....########....\\n&quot; &quot;..........##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;................\\n&quot; &quot;................\\n&quot; &quot;................\\n&quot; &quot;................\\n&quot; &quot;..##########....\\n&quot; &quot;................\\n&quot; &quot;................\\n&quot; &quot;................\\n&quot; &#125;;class BigChar&#123;public: BigChar(int order) : m_char(strList[order % 11]) &#123;&#125; void show() &#123; std::cout &lt;&lt; m_char &lt;&lt; std::endl; &#125;private: const char *m_char;&#125;;class BigCharFactory&#123;public: ~BigCharFactory() &#123; for (auto i : m_map) &#123; delete i.second; &#125; m_map.clear(); &#125; BigChar *getBigChar(int order) &#123; BigChar *b = nullptr; int tOrder = order % 11; auto it = m_map.find(tOrder); if (it == m_map.end()) &#123; b = new BigChar(tOrder); m_map.insert(&#123; tOrder, b &#125;); return b; &#125; else &#123; return it-&gt;second; &#125; &#125;private: std::unordered_map&lt;int, BigChar *&gt; m_map;&#125;;int main()&#123; BigCharFactory f; for (int i = 0; i &lt; 20; ++i) &#123; for (int j = 0; j &lt; 2; ++j) &#123; BigChar *b = f.getBigChar(i); std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; std::endl; b-&gt;show(); &#125; &#125; return 0;&#125;","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:10--å¤–è§‚æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-10-å¤–è§‚æ¨¡å¼","date":"2022-10-15T14:16:48.000Z","updated":"2022-10-21T05:57:45.621Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-10-å¤–è§‚æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-10-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µä¸ºå­ç³»ç»Ÿä¸­çš„ä¸€ç»„æ¥å£æä¾›ä¸€è‡´çš„ç•Œé¢ï¼Œfa?adeæä¾›äº†ä¸€é«˜å±‚æ¥å£ï¼Œè¿™ä¸ªæ¥å£ä½¿å¾—å­ç³»ç»Ÿæ›´å®¹æ˜“ä½¿ç”¨ã€‚ 2ã€åº”ç”¨åœºæ™¯3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹11 2ã€æ¡ˆä¾‹2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;using namespace std;class DataBase &#123;public: ~DataBase() = default; static DataBase &amp;GetInstance() &#123; static DataBase db; return db; &#125; std::string getNameByEmail(const std::string &amp;email) const &#123; auto it = m_map.find(email); if (it != m_map.end()) return it-&gt;second; else return &#123;&#125;; &#125;protected: DataBase(const DataBase &amp;) = delete; DataBase(DataBase &amp;&amp;) = delete; DataBase &amp;operator=(const DataBase &amp;) = delete; DataBase &amp;operator=(DataBase &amp;&amp;) = delete;private: DataBase() &#123;&#125;private: std::unordered_map&lt;std::string, std::string&gt; m_map&#123; &#123; &quot;zhangsan@zhangsan.com&quot;, &quot;zhangsan&quot; &#125;, &#123; &quot;lisi@lisi.com&quot;, &quot;lisi&quot; &#125;, &#123; &quot;wangwu@wangwu.com&quot;, &quot;wangwu&quot; &#125; &#125;;&#125;;class HtmlWriter&#123;public: void title(const std::string &amp;title) &#123; m_ss &lt;&lt; &quot;&lt;html&gt;&quot; &lt;&lt; &quot;&lt;head&gt;&quot; &lt;&lt; &quot;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&quot; &lt;&lt; &quot;&lt;/head&gt;&quot; &lt;&lt; &quot;&lt;body&gt;\\n&quot; &lt;&lt; &quot;&lt;h1&gt;&quot; + title + &quot;&lt;/h1&gt;\\n&quot;; &#125; void paragraph(const std::string &amp;msg) &#123; m_ss &lt;&lt; &quot;&lt;p&gt;&quot; + msg + &quot;&lt;/p&gt;\\n&quot;; &#125; void link(const std::string &amp;herf, const std::string &amp;caption) &#123; paragraph(&quot;&lt;a herf=\\&quot;&quot; + herf + &quot;\\&quot;&gt;&quot; + caption + &quot;&lt;/a&gt;&quot;); &#125; void mailto(const std::string &amp;mailAddr, const std::string &amp;userName)&#123; link(&quot;mailto:&quot; + mailAddr, userName); &#125; void close() &#123; m_ss &lt;&lt; &quot;&lt;/body&gt;&quot; &lt;&lt; &quot;&lt;/html&gt;\\n&quot;; &#125; std::string toString() const &#123; return m_ss.str(); &#125;private: std::stringstream m_ss;&#125;;class PageMaker&#123;public: ~PageMaker() = default; PageMaker(const PageMaker &amp;) = delete; PageMaker(PageMaker &amp;&amp;) = delete; PageMaker &amp;operator=(const PageMaker &amp;) = delete; PageMaker &amp;operator=(PageMaker &amp;&amp;) = delete; static PageMaker &amp;GetInstance() &#123; static PageMaker pm; return pm; &#125; void makeWelcomePage(const std::string &amp;mailAddr) &#123; auto name = DataBase::GetInstance().getNameByEmail(mailAddr); HtmlWriter writer; writer.title(&quot;Welcome to &quot; + name + &quot;&#x27;s page!&quot;); writer.paragraph(name + u8&quot;æ¬¢è¿æ¥åˆ°&quot; + name + u8&quot;çš„ä¸»é¡µ.&quot;); writer.paragraph(u8&quot;ç­‰ç€ä½ çš„é‚®ä»¶å“¦ï¼&quot;); writer.mailto(mailAddr, name); writer.close(); std::cout &lt;&lt; writer.toString() &lt;&lt; std::endl; &#125;protected: PageMaker() &#123;&#125;private:&#125;;int main()&#123; assert(DataBase::GetInstance().getNameByEmail(&quot;&quot;).empty()); PageMaker::GetInstance().makeWelcomePage(&quot;zhangsan@zhangsan.com&quot;); return 0;&#125;","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:09--è£…é¥°æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-09-è£…é¥°æ¨¡å¼","date":"2022-10-15T14:16:29.000Z","updated":"2022-10-21T05:57:49.037Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-09-è£…é¥°æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-09-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µåŠ¨æ€åœ°ç»™ä¸€ä¸ªå¯¹è±¡å¢åŠ ä¸€äº›é¢å¤–çš„èŒè´£ï¼Œå°±å¢åŠ çš„åŠŸèƒ½æ¥è¯´ï¼ŒDecoratoræ¨¡å¼ç›¸æ¯”ç”Ÿæˆå­ç±»æ›´åŠ çµæ´»ã€‚ 2ã€åº”ç”¨åœºæ™¯3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹11 2ã€æ¡ˆä¾‹2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;class IDisplay &#123;public: virtual ~IDisplay() &#123;&#125; virtual int getRows() const = 0; virtual int getColumns() const = 0; virtual std::string getRow(int index) const = 0; void show() &#123; int r = getRows(); for (int i = 0; i &lt; r; ++i) &#123; std::cout &lt;&lt; getRow(i) &lt;&lt; std::endl; &#125; &#125;&#125;;class StringDisplay : public IDisplay &#123;public: StringDisplay(const std::string &amp;str) : m_str(str) &#123;&#125; virtual int getRows() const override &#123; return 1; &#125; virtual int getColumns() const override &#123; return static_cast&lt;int&gt;(m_str.length()); &#125; virtual std::string getRow(int index) const override &#123; if (index == 0) return m_str; else return &#123;&#125;; &#125;private: std::string m_str;&#125;;class Border : public IDisplay &#123;public: Border(IDisplay *display) : m_display(display) &#123;&#125; virtual ~Border() &#123; delete m_display; &#125;protected: IDisplay *m_display;&#125;;class FullBorder : public Border &#123;public: FullBorder(IDisplay *display) : Border(display) &#123;&#125; virtual int getRows() const override &#123; return 1 + m_display-&gt;getRows() + 1; &#125; virtual int getColumns() const override &#123; return 1 + m_display-&gt;getColumns() + 1; &#125; virtual std::string getRow(int index) const override &#123; if (index == 0) return &quot;+&quot; + makeLine(&#x27;-&#x27;, m_display-&gt;getColumns()) + &quot;+&quot;; else if (index == m_display-&gt;getRows() + 1) return &quot;+&quot; + makeLine(&#x27;-&#x27;, m_display-&gt;getColumns()) + &quot;+&quot;; else return &quot;|&quot; + m_display-&gt;getRow(index - 1) + &quot;|&quot;; &#125;private: std::string makeLine(char ch, int count) const &#123; std::string str; str.resize(count, ch); return str; &#125;&#125;;class SideBorder : public Border &#123;public: SideBorder(IDisplay *display, const char &amp;borderChar) : Border(display), m_borderChar(borderChar) &#123;&#125; virtual int getRows() const override &#123; return m_display-&gt;getRows(); &#125; virtual int getColumns() const override &#123; return 1 + m_display-&gt;getColumns() + 1; &#125; virtual std::string getRow(int index) const override &#123; return m_borderChar + m_display-&gt;getRow(index) + m_borderChar; &#125;private: char m_borderChar;&#125;;int main()&#123; IDisplay *d1 = new StringDisplay(&quot;Hello&quot;); assert(d1-&gt;getRow(-1).empty()); IDisplay *d2 = new SideBorder(d1, &#x27;#&#x27;); IDisplay *d3 = new FullBorder(d2); d1-&gt;show(); d2-&gt;show(); d3-&gt;show(); IDisplay *d4 = new SideBorder(new FullBorder(new FullBorder(new SideBorder(new FullBorder(new StringDisplay(&quot;Hello,World&quot;)), &#x27;*&#x27;))), &#x27;/&#x27;); d4-&gt;show(); delete d1; delete d4; return 0;&#125;","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:08--ç»„åˆæ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-08-ç»„åˆæ¨¡å¼","date":"2022-10-15T14:16:07.000Z","updated":"2022-10-21T05:57:51.833Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-08-ç»„åˆæ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-08-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µå°†å¯¹è±¡ç»„åˆæˆæ ‘å½¢ç»“æ„ä»¥è¡¨ç¤ºéƒ¨åˆ†æ•´ä½“çš„å…³ç³»ï¼ŒCompositeä½¿å¾—ç”¨æˆ·å¯¹å•ä¸ªå¯¹è±¡å’Œç»„åˆå¯¹è±¡çš„ä½¿ç”¨å…·æœ‰ä¸€è‡´æ€§ 2ã€åº”ç”¨åœºæ™¯3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class Component &#123;public: Component()&#123;&#125; Component(string iName) &#123; this-&gt;name = iName; &#125; virtual ~Component()&#123;&#125; virtual void add(Component*) = 0; virtual void remove(Component*) = 0; virtual Component* getChild(int) = 0; virtual void operation() = 0; string getName() &#123; return name; &#125;private: string name;&#125;;class Office : public Component &#123;public: Office(string iName) &#123; this-&gt;name = iName; &#125; Office() &#123;&#125; void add(Component* c) &#123; printf(&quot;not support!\\n&quot;); &#125; void remove(Component* c) &#123; printf(&quot;not support!\\n&quot;); &#125; Component* getChild(int i) &#123; printf(&quot;not support!\\n&quot;); return NULL; &#125;private: string name;&#125;;class AdminOffice :public Office &#123;public: AdminOffice(string iName) &#123; this-&gt;name = iName; &#125; void operation() &#123; printf(&quot;-----Administration Office:%s\\n&quot;, name.c_str()); &#125;private: string name;&#125;;class DeanOffice :public Office &#123;public: DeanOffice(string iName) &#123; this-&gt;name = iName; &#125; void operation() &#123; printf(&quot;-----Dean Office:%s\\n&quot;, name.c_str()); &#125;private: string name;&#125;;class SubComponent :public Component &#123;public: SubComponent(string iName) &#123; this-&gt;name = iName; &#125; void add(Component *c) &#123; componentList.push_back(c); &#125; void remove(Component *c) &#123; for (int i = 0; i &lt; componentList.size(); i++) &#123; if (componentList[i]-&gt;getName() == c-&gt;getName()) &#123; componentList.erase(componentList.begin() + i); break; &#125; &#125; &#125; Component* getChild(int i) &#123; return (Component*)componentList[i]; &#125; void operation() &#123; printf(&quot;%s\\n&quot;, this-&gt;name.c_str()); for (int i = 0; i &lt; componentList.size(); i++) &#123; ((Component*)componentList[i])-&gt;operation(); &#125; &#125;private: string name; vector&lt;Component*&gt;componentList;&#125;;int main()&#123; Component *head, *sichuanBranch, *cdBranch, *myBranch, *office1, *office2, *office3, *office4, *office5, *office6, *office7, *office8; head = new SubComponent(&quot;æ€»éƒ¨&quot;); sichuanBranch = new SubComponent(&quot;å››å·åˆ†éƒ¨&quot;); office1 = new AdminOffice(&quot;è¡Œæ”¿åŠå…¬å®¤&quot;); office2 = new DeanOffice(&quot;æ•™åŠ¡åŠå…¬å®¤&quot;); cdBranch = new SubComponent(&quot;æˆéƒ½åˆ†éƒ¨&quot;); myBranch = new SubComponent(&quot;ç»µé˜³åˆ†éƒ¨&quot;); office3 = new AdminOffice(&quot;è¡Œæ”¿åŠå…¬å®¤&quot;); office4 = new DeanOffice(&quot;æ•™åŠ¡åŠå…¬å®¤&quot;); office5 = new AdminOffice(&quot;è¡Œæ”¿åŠå…¬å®¤&quot;); office6 = new DeanOffice(&quot;æ•™åŠ¡åŠå…¬å®¤&quot;); office7 = new AdminOffice(&quot;è¡Œæ”¿åŠå…¬å®¤&quot;); office8 = new DeanOffice(&quot;æ•™åŠ¡åŠå…¬å®¤&quot;); cdBranch-&gt;add(office5); cdBranch-&gt;add(office6); myBranch-&gt;add(office7); myBranch-&gt;add(office8); sichuanBranch-&gt;add(office3); sichuanBranch-&gt;add(office4); sichuanBranch-&gt;add(cdBranch); sichuanBranch-&gt;add(myBranch); head-&gt;add(office1); head-&gt;add(office2); head-&gt;add(sichuanBranch); head-&gt;operation(); delete head; delete sichuanBranch; delete cdBranch; delete myBranch; delete office1; delete office2; delete office3; delete office4; delete office5; delete office6; delete office7; delete office8; return 0;&#125; 2ã€æ¡ˆä¾‹2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;class Entry &#123;public: virtual ~Entry() &#123;&#125; virtual std::string getName() const = 0; virtual int getSize() const = 0; virtual void addEntryy(Entry *entry) &#123;&#125; virtual void printList(const std::string &amp;str) = 0; void printList() &#123; printList(&quot;&quot;); &#125; std::string toString() const &#123; return getName() + &quot; (&quot; + std::to_string(getSize()) + &quot;)&quot;; &#125;&#125;;class File : public Entry &#123;public: File(const std::string &amp;name, int size) : m_name(name), m_size(size) &#123;&#125; virtual std::string getName() const override &#123; return m_name; &#125; virtual int getSize() const override &#123; return m_size; &#125; virtual void printList(const std::string &amp;str) override &#123; std::cout &lt;&lt; str &lt;&lt; &quot;/&quot; &lt;&lt; toString() &lt;&lt; std::endl; &#125;private: std::string m_name; int m_size;&#125;;class Directory : public Entry &#123;public: Directory(const std::string &amp;name) : m_name(name) &#123;&#125; ~Directory() &#123; for (auto it : m_dirs) &#123; delete it; &#125; m_dirs.clear(); &#125; virtual std::string getName() const override &#123; return m_name; &#125; virtual int getSize() const &#123; int size = 0; for (auto it : m_dirs) &#123; size += it-&gt;getSize(); &#125; return size; &#125; virtual void addEntryy(Entry *entry) override &#123; m_dirs.push_back(entry); &#125; virtual void printList(const std::string &amp;str) override &#123; std::cout &lt;&lt; str &lt;&lt; &quot;/&quot; &lt;&lt; toString() &lt;&lt; std::endl; for (auto it : m_dirs) &#123; it-&gt;printList(str + &quot;/&quot; + m_name); &#125; &#125;private: std::string m_name; std::vector&lt;Entry *&gt; m_dirs;&#125;;int main()&#123; Directory *root = new Directory(&quot;root&quot;); Directory *bin = new Directory(&quot;bin&quot;); Directory *tmp = new Directory(&quot;tmp&quot;); Directory *usr = new Directory(&quot;usr&quot;); root-&gt;addEntryy(bin); root-&gt;addEntryy(tmp); root-&gt;addEntryy(usr); bin-&gt;addEntryy(new File(&quot;vi&quot;, 3000)); bin-&gt;addEntryy(new File(&quot;latex&quot;, 2000)); static_cast&lt;Entry *&gt;(root)-&gt;printList(); Directory *yuki = new Directory(&quot;yuki&quot;); Directory *hanako = new Directory(&quot;hanako&quot;); Directory *tomura = new Directory(&quot;tomura&quot;); usr-&gt;addEntryy(yuki); usr-&gt;addEntryy(hanako); usr-&gt;addEntryy(tomura); yuki-&gt;addEntryy(new File(&quot;diary.html&quot;, 100)); hanako-&gt;addEntryy(new File(&quot;memo.tex&quot;, 1024)); tomura-&gt;addEntryy(new File(&quot;junk.mail&quot;, 40)); static_cast&lt;Entry *&gt;(root)-&gt;printList(); // for test coverage &#123; File *f = new File(&quot;123.txt&quot;, 1); f-&gt;addEntryy(root); f-&gt;printList(&quot;&quot;); delete f; &#125; &#123; yuki-&gt;printList(&quot;&quot;); &#125; &#123; File *f = new File(&quot;123.txt&quot;, 1); Entry *e = new Directory(&quot;test&quot;); e-&gt;addEntryy(f); e-&gt;printList(&quot;&quot;); e-&gt;toString(); delete e; &#125; delete root; return 0;&#125;","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:07--æ¡¥æ¥æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-07-æ¡¥æ¥æ¨¡å¼","date":"2022-10-15T14:15:47.000Z","updated":"2022-10-21T05:57:54.617Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-07-æ¡¥æ¥æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-07-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µå°†æŠ½è±¡éƒ¨åˆ†ä¸å®ƒçš„å®ç°éƒ¨åˆ†ç›¸åˆ†ç¦»ï¼Œä½¿ä»–ä»¬å¯ä»¥ç‹¬ç«‹çš„å˜åŒ– 2ã€åº”ç”¨åœºæ™¯3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;class Game &#123;public: Game()&#123;&#125; virtual ~Game()&#123;&#125; virtual void play() = 0;private:&#125;;class GameA : public Game &#123;public: GameA()&#123;&#125; void play()&#123; printf(&quot;Jungle play gameA\\n&quot;); &#125;&#125;;class GameB : public Game &#123;public: GameB()&#123;&#125; void play()&#123; printf(&quot;Jungle play gameB\\n&quot;); &#125;&#125;;class Phone &#123;public: Phone()&#123;&#125; virtual ~Phone()&#123;&#125; virtual void setupGame(Game *igame) = 0; virtual void play() = 0;private: Game *game;&#125;;class PhoneA:public Phone &#123;public: PhoneA()&#123;&#125; void setupGame(Game *igame)&#123; this-&gt;game = igame; &#125; void play()&#123; this-&gt;game-&gt;play(); &#125;private: Game *game;&#125;;class PhoneB :public Phone &#123;public: PhoneB()&#123;&#125; void setupGame(Game *igame)&#123; this-&gt;game = igame; &#125; void play()&#123; this-&gt;game-&gt;play(); &#125;private: Game *game;&#125;;int main()&#123; Game *game; Phone *phone; phone = new PhoneA(); game = new GameA(); phone-&gt;setupGame(game); phone-&gt;play(); printf(&quot;++++++++++++++++++++++++++++++++++\\n&quot;); delete game; game = new GameB(); phone-&gt;setupGame(game); phone-&gt;play(); delete phone; delete game; return 0;&#125; 2ã€æ¡ˆä¾‹2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;class IDisplayImpl &#123;public: virtual ~IDisplayImpl() &#123;&#125; virtual void rawOpen() = 0; virtual void rawPrint() = 0; virtual void rawClose() = 0;&#125;;class Display &#123;public: virtual ~Display() &#123;&#125; Display(IDisplayImpl *impl) : m_pImpl(impl) &#123;&#125; virtual void open() &#123; m_pImpl-&gt;rawOpen(); &#125; virtual void print() &#123; m_pImpl-&gt;rawPrint(); &#125; virtual void close() &#123; m_pImpl-&gt;rawClose(); &#125; void display() &#123; open(); print(); close(); &#125;private: IDisplayImpl *m_pImpl;&#125;;class CountDisplay : public Display &#123;public: using Display::Display; void mulitDisplay(unsigned int count) &#123; open(); for (unsigned int i = 0; i &lt; count; ++i) print(); close(); &#125;&#125;;class StringDisplayImpl : public IDisplayImpl&#123;public: StringDisplayImpl(const std::string &amp;str) : m_str(str) &#123;&#125; virtual void rawOpen() override &#123; printLine(); &#125; virtual void rawPrint() override &#123; cout &lt;&lt; &quot;|&quot; &lt;&lt; m_str &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; &#125; virtual void rawClose() override &#123; printLine(); &#125;private: void printLine() &#123; cout &lt;&lt; &quot;+&quot;; for (int i = 0; i &lt; m_str.length(); ++i) cout &lt;&lt; &quot;-&quot;; cout &lt;&lt; &quot;+&quot; &lt;&lt; endl; &#125;private: std::string m_str;&#125;;int main()&#123; std::shared_ptr&lt;IDisplayImpl&gt; impl1(new StringDisplayImpl(&quot;Hello, China&quot;)); std::shared_ptr&lt;Display&gt; d1(new Display(impl1.get())); std::shared_ptr&lt;IDisplayImpl&gt; impl2(new StringDisplayImpl(&quot;Hello, Tao&quot;)); std::shared_ptr&lt;Display&gt; d2(new CountDisplay(impl2.get())); std::shared_ptr&lt;IDisplayImpl&gt; impl3(new StringDisplayImpl(&quot;Hello,Universe&quot;)); std::shared_ptr&lt;CountDisplay&gt; d3(new CountDisplay(impl3.get())); d1-&gt;display(); d2-&gt;display(); d3-&gt;display(); d3-&gt;mulitDisplay(4); return 0;&#125;","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:06--é€‚é…å™¨æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-06-é€‚é…å™¨æ¨¡å¼","date":"2022-10-15T14:15:26.000Z","updated":"2022-10-21T05:57:58.977Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-06-é€‚é…å™¨æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-06-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µå°†ä¸€ç±»çš„æ¥å£è½¬æ¢æˆå®¢æˆ·å¸Œæœ›çš„å¦å¤–ä¸€ä¸ªæ¥å£ï¼ŒAdapteræ¨¡å¼ä½¿å¾—åŸæœ¬ç”±äºæ¥å£ä¸å…¼å®¹è€Œä¸èƒ½ä¸€èµ·å·¥ä½œé‚£äº›ç±»å¯ä»¥ä¸€èµ·å·¥ä½œã€‚ 2ã€åº”ç”¨åœºæ™¯3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;class Controller &#123;public: Controller()&#123;&#125; virtual ~Controller()&#123;&#125; virtual void pathPlanning() = 0;&#125;;class DxfParser &#123;public: DxfParser()&#123;&#125; void parseFile()&#123; printf(&quot;parseFile\\n&quot;); &#125;&#125;;class PathPlanner &#123;public: PathPlanner()&#123;&#125; void calculate()&#123; printf(&quot;calculate\\n&quot;); &#125;&#125;;class Adapter:public Controller &#123;public: Adapter()&#123; dxfParser = new DxfParser(); pathPlanner = new PathPlanner(); &#125; void pathPlanning()&#123; printf(&quot;pathPlanning\\n&quot;); dxfParser-&gt;parseFile(); pathPlanner-&gt;calculate(); &#125;private: DxfParser *dxfParser; PathPlanner *pathPlanner;&#125;;int main()&#123; Controller *controller = new Adapter(); controller-&gt;pathPlanning(); delete controller; return 0;&#125; 2ã€æ¡ˆä¾‹212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;class Banner &#123;public: Banner(const std::string &amp;str) : m_str(str) &#123;&#125; void showWithParen() &#123; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; m_str &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; &#125; void showWithAster() &#123; std::cout &lt;&lt; &quot;*&quot; &lt;&lt; m_str &lt;&lt; &quot;*&quot; &lt;&lt; std::endl; &#125;private: std::string m_str;&#125;;class Painter &#123;public: virtual ~Painter() &#123;&#125; virtual void printStrong() = 0; virtual void printWeak() = 0;&#125;;class PainterBanner : public Banner, public Painter &#123;public: PainterBanner(const std::string &amp;str) : Banner(str) &#123;&#125; virtual void printStrong() override &#123; showWithParen(); &#125; virtual void printWeak() override &#123; showWithAster(); &#125;&#125;;int main()&#123; Painter *painter = new PainterBanner(std::string(&quot;HelloWorld&quot;)); painter-&gt;printStrong(); painter-&gt;printWeak(); delete painter; return 0;&#125;","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:05--å•ä¾‹æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-05-å•ä¾‹æ¨¡å¼","date":"2022-10-15T14:14:36.000Z","updated":"2022-10-21T05:45:06.174Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-05-å•ä¾‹æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-05-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µä¿è¯ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›ä¸€ä¸ªè®¿é—®å®ƒçš„å…¨å±€è®¿é—®ç‚¹ 2ã€åº”ç”¨åœºæ™¯ä¸€ä¸ªæ— çŠ¶æ€çš„ç±»ä½¿ç”¨å•ä¾‹æ¨¡å¼èŠ‚çœå†…å­˜èµ„æº 3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹112345678910111213141516171819202122class Singleton &#123;public: static Singleton* getInstance() &#123; if (instance == NULL) &#123; m_mutex.lock(); if (instance == NULL)&#123; printf(&quot;create Singleton\\n&quot;); instance = new Singleton(); &#125; m_mutex.unlock(); &#125; return instance; &#125;private: Singleton()&#123;&#125; static Singleton* instance; static std::mutex m_mutex;&#125;;Singleton* Singleton::instance = NULL;std::mutex Singleton::m_mutex; 2ã€æ¡ˆä¾‹21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;template &lt;class T&gt;class SingleTon &#123;public: static T &amp;GetInstance() &#123; static T ins; return ins; &#125; SingleTon(const SingleTon &amp;) = delete; SingleTon &amp;operator=(const SingleTon &amp;) = delete; virtual ~SingleTon() &#123;&#125;protected: SingleTon() &#123;&#125;&#125;;class Apple : public SingleTon&lt;Apple&gt; &#123; friend SingleTon&lt;Apple&gt;;public: void show() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125; ~Apple() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125;protected: Apple() &#123;&#125;&#125;;class Orange : public SingleTon&lt;Orange&gt; &#123; friend SingleTon&lt;Orange&gt;;public: ~Orange() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125; void show() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125;protected: Orange()&#123;&#125;&#125;;int main()&#123; Apple::GetInstance().show(); cout &lt;&lt; &amp;Apple::GetInstance() &lt;&lt; endl; Apple::GetInstance().show(); cout &lt;&lt; &amp;Apple::GetInstance() &lt;&lt; endl; Orange::GetInstance().show(); Orange::GetInstance().show(); Orange::GetInstance().show(); return 0;&#125;","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:04--åŸå‹æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-04-åŸå‹æ¨¡å¼","date":"2022-10-15T14:14:15.000Z","updated":"2022-10-21T05:44:45.269Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-04-åŸå‹æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-04-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µç”¨åŸå‹å®ä¾‹æŒ‡å®šåˆ›å»ºå¯¹è±¡çš„ç§ç±»ï¼Œå¹¶ä¸”é€šè¿‡æ‹·è´è¿™äº›åŸå‹æ¥åˆ›å»ºæ–°çš„å¯¹è±¡ 2ã€åº”ç”¨åœºæ™¯ç”¨newåˆ›å»ºä¸€ä¸ªå¯¹è±¡éœ€è¦éå¸¸ç¹ççš„æ•°æ®å‡†å¤‡æˆ–è€…æƒé™ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨åŸå‹æ¨¡å¼ 3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class WorkModel &#123;public: char *modelName; void setWorkModelName(char *iName)&#123; this-&gt;modelName = iName; &#125;&#125;;class PrototypeWork &#123;public: PrototypeWork()&#123;&#125; virtual PrototypeWork *clone() = 0;&#125;;class ConcreteWork :public PrototypeWork &#123;public: ConcreteWork()&#123;&#125; ConcreteWork(char* iName, int iIdNum, char* modelName)&#123; this-&gt;name = iName; this-&gt;idNum = iIdNum; this-&gt;workModel = new WorkModel(); this-&gt;workModel-&gt;setWorkModelName(modelName); &#125; ConcreteWork *clone()&#123; ConcreteWork *work = new ConcreteWork(); work-&gt;setName(this-&gt;name); work-&gt;setIdNum(this-&gt;idNum); work-&gt;workModel = this-&gt;workModel; return work; &#125; void setName(char* iName)&#123; this-&gt;name = iName; &#125; void setIdNum(int iIdNum)&#123; this-&gt;idNum = iIdNum; &#125; void setModel(WorkModel *iWorkModel)&#123; this-&gt;workModel = iWorkModel; &#125; void printWorkInfo()&#123; printf(&quot;name:%s\\n&quot;, this-&gt;name); printf(&quot;idNum:%d\\n&quot;, this-&gt;idNum); printf(&quot;modelName:%s\\n&quot;, this-&gt;workModel-&gt;modelName); &#125;private: char* name; int idNum; WorkModel *workModel;&#125;;int main()&#123; ConcreteWork *singleWork = new ConcreteWork(&quot;Single&quot;, 1001, &quot;Single_Model&quot;); printf(&quot;\\nSingleConcreteWork\\n&quot;); ConcreteWork *jungleWork = singleWork-&gt;clone(); printf(&quot;\\nJungleConcreteWork\\n&quot;); printf(&quot;\\njungleClone&quot;); jungleWork-&gt;setName(&quot;jungle&quot;); jungleWork-&gt;setIdNum(1002); WorkModel *jungleModel = new WorkModel(); jungleModel-&gt;setWorkModelName(&quot;Jungle_Model&quot;); jungleWork-&gt;setModel(jungleModel); printf(&quot;\\nSingleInfo\\n&quot;); singleWork-&gt;printWorkInfo(); printf(&quot;\\nJungleInfo\\n&quot;); jungleWork-&gt;printWorkInfo(); return 0;&#125; 2ã€æ¡ˆä¾‹2``` C #include &lt;iostream&gt; #include &lt;functional&gt; #include &lt;memory&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;unordered_map&gt; #include &lt;cassert&gt; using namespace std; class IProduct &#123; public: virtual ~IProduct() &#123;&#125; virtual IProduct *Clone() = 0; virtual void Use(const std::string &amp;str) = 0; &#125;; class MessageBox : public IProduct &#123; public: MessageBox(const std::string &amp;str) : m_name(str) &#123;&#125; IProduct *Clone() override &#123; return new MessageBox(m_name); &#125; void Use(const std::string &amp;str) &#123; std::cout &lt;&lt; &quot;Message box &quot; &lt;&lt; m_name &lt;&lt; &quot; &quot; &lt;&lt; str &lt;&lt; std::endl; &#125; private: std::string m_name; &#125;; class ProductMgr &#123; public: void Register(const std::string &amp;name, IProduct *pro) &#123; m_map.insert(&#123; name, pro &#125;); &#125; IProduct *Create(const std::string &amp;name) &#123; auto it = m_map.find(name); if (it != m_map.end()) return it-&gt;second-&gt;Clone(); else return nullptr; &#125; private: std::unordered_map&lt;std::string, IProduct *&gt; m_map; &#125;; int main() &#123; ProductMgr mgr; IProduct *p1 = new MessageBox(&quot;Hello&quot;); mgr.Register(&quot;MB&quot;, p1); p1-&gt;Use(&quot;World&quot;); auto p2 = mgr.Create(&quot;MB&quot;); p2-&gt;Use(&quot;World&quot;); cout &lt;&lt; p1 &lt;&lt; endl; cout &lt;&lt; p2 &lt;&lt; endl; auto pp = mgr.Create(&quot;Not&quot;); assert(pp == nullptr); delete p1; delete p2; return 0; &#125; ...","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:03--å»ºé€ è€…æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-03-å»ºé€ è€…æ¨¡å¼","date":"2022-10-15T14:13:17.000Z","updated":"2022-10-21T05:58:03.057Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-03-å»ºé€ è€…æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-03-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µå°†ä¸€ä¸ªå¤æ‚å¯¹è±¡çš„æ„å»ºä¸ä»–çš„è¡¨ç¤ºç›¸åˆ†ç¦»ï¼Œä½¿å¾—åŒæ ·çš„æ„å»ºè¿‡ç¨‹å¯ä»¥åˆ›å»ºä¸åŒçš„è¡¨ç¤ºã€‚ 2ã€åº”ç”¨åœºæ™¯ä¸€ä¸ªç±»çš„å„ä¸ªç»„æˆéƒ¨åˆ†çš„å…·ä½“å®ç°ç±»æˆ–è€…ç®—æ³•ç»å¸¸é¢ä¸´ç€å˜åŒ–ï¼Œä½†æ˜¯å°†ä»–ä»¬ç»„åˆåœ¨ä¸€èµ·çš„ç®—æ³•å´ç›¸å¯¹ç¨³å®šã€‚æä¾›ä¸€ç§å°è£…æœºåˆ¶ å°†ç¨³å®šçš„ç»„åˆç®—æ³•äºæ˜“å˜çš„å„ä¸ªç»„æˆéƒ¨åˆ†éš”ç¦»å¼€æ¥ã€‚ 3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class House &#123;public: House() &#123;&#125; void setFloor(string iFloor) &#123; this-&gt;floor = iFloor; &#125; void setWall(string iWall) &#123; this-&gt;wall = iWall; &#125; void setRoof(string iRoof) &#123; this-&gt;roof = iRoof; &#125; void printfHouseInfo() &#123; printf(&quot;Floor:%s\\t\\n&quot;, this-&gt;floor.c_str()); printf(&quot;Wall:%s\\t\\n&quot;, this-&gt;wall.c_str()); printf(&quot;Roof:%s\\t\\n&quot;, this-&gt;roof.c_str()); &#125;private: string floor; string wall; string roof;&#125;;class AbstractBuilder &#123;public: AbstractBuilder() &#123; house = new House(); &#125; virtual ~AbstractBuilder() &#123; if (house != nullptr) &#123; delete house; house = nullptr; &#125; &#125; virtual void buildFloor() = 0; virtual void buildWall() = 0; virtual void buildRoof() = 0; virtual House *getHouse() = 0; House *house;&#125;;class ConcreteBuilderA : public AbstractBuilder &#123;public: ConcreteBuilderA() &#123; printf(&quot;ConcreteBuilderA\\n&quot;); &#125; ~ConcreteBuilderA() &#123; &#125; void buildFloor() &#123; this-&gt;house-&gt;setFloor(&quot;Floor_A&quot;); &#125; void buildWall() &#123; this-&gt;house-&gt;setWall(&quot;Wall_A&quot;); &#125; void buildRoof() &#123; this-&gt;house-&gt;setRoof(&quot;Roof_A&quot;); &#125; House *getHouse() &#123; return this-&gt;house; &#125;&#125;;class ConcreteBuilderB : public AbstractBuilder &#123;public: ConcreteBuilderB() &#123; printf(&quot;ConcreteBuilderB\\n&quot;); &#125; ~ConcreteBuilderB() &#123; &#125; void buildFloor() &#123; this-&gt;house-&gt;setFloor(&quot;Floor_B&quot;); &#125; void buildWall() &#123; this-&gt;house-&gt;setWall(&quot;Wall_B&quot;); &#125; void buildRoof() &#123; this-&gt;house-&gt;setRoof(&quot;Roof_B&quot;); &#125; House *getHouse() &#123; return this-&gt;house; &#125;&#125;;class Director &#123;public: Director() :builder(nullptr) &#123;&#125; ~Director() &#123; if (this-&gt;builder != nullptr) &#123; delete builder; builder = nullptr; &#125; &#125; void setBuilder(AbstractBuilder *iBuilder) &#123; this-&gt;builder = iBuilder; &#125; House *construct() &#123; builder-&gt;buildFloor(); builder-&gt;buildWall(); builder-&gt;buildRoof(); return builder-&gt;getHouse(); &#125;private: AbstractBuilder *builder;&#125;;int main()&#123; AbstractBuilder *builder; Director *director = new Director(); House *house; builder = new ConcreteBuilderA(); director-&gt;setBuilder(builder); house = director-&gt;construct(); house-&gt;printfHouseInfo(); delete builder; builder = new ConcreteBuilderB(); director-&gt;setBuilder(builder); house = director-&gt;construct(); house-&gt;printfHouseInfo(); delete director; return 0;&#125; 2ã€æ¡ˆä¾‹2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;class IBuilder &#123;public: virtual ~IBuilder() &#123;&#125; virtual void makeTitle(const std::string &amp;title) = 0; virtual void makeString(const std::string &amp;str) = 0; virtual void makeItems(const std::vector&lt;std::string&gt; &amp;items) = 0; virtual void close() = 0;&#125;;class TextBuilder : public IBuilder &#123;public: void makeTitle(const std::string &amp;title) override &#123; m_str.append(&quot;============================\\n&quot;); m_str.append(&quot;[&quot; + title + &quot;]\\n&quot;); m_str.append(&quot;\\n&quot;); &#125; void makeString(const std::string &amp;str) override &#123; m_str.append(&quot; * &quot; + str + &quot;\\n&quot;); m_str.append(&quot;\\n&quot;); &#125; void makeItems(const std::vector&lt;std::string&gt; &amp;items) override &#123; for (auto item : items) &#123; m_str.append(&quot; . &quot; + item + &quot;\\n&quot;); &#125; m_str.append(&quot;\\n&quot;); &#125; void close() override &#123; m_str.append(&quot;============================\\n&quot;); &#125; std::string getResult() const &#123; return m_str; &#125;private: std::string m_str;&#125;;class Director &#123;public: Director(IBuilder *builder) : m_builder(builder) &#123;&#125; void construct() &#123; m_builder-&gt;makeTitle(&quot;Greeting&quot;); m_builder-&gt;makeString(u8&quot;ä»æ—©ä¸Šåˆ°ä¸‹åˆ&quot;); m_builder-&gt;makeItems(std::vector&lt;std::string&gt;&#123; u8&quot;æ—©ä¸Šå¥½&quot;, u8&quot;ä¸‹åˆå¥½&quot; &#125;); m_builder-&gt;makeString(u8&quot;æ™šä¸Š&quot;); m_builder-&gt;makeItems(std::vector&lt;std::string&gt;&#123; u8&quot;æ™šä¸Šå¥½&quot;, u8&quot;æ™šå®‰&quot;, u8&quot;å†è§&quot; &#125;); m_builder-&gt;close(); &#125;private: IBuilder *m_builder;&#125;;int main()&#123; TextBuilder *builder = new TextBuilder; Director director(builder); director.construct(); std::string result = builder-&gt;getResult(); std::cout &lt;&lt; result &lt;&lt; std::endl; delete builder; return 0;&#125;","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:02--æŠ½è±¡å·¥å‚æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-02-æŠ½è±¡å·¥å‚æ¨¡å¼","date":"2022-10-15T14:11:56.000Z","updated":"2022-10-21T05:41:11.352Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-02-æŠ½è±¡å·¥å‚æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-02-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µæä¾›ä¸€ä¸ªåˆ›å»ºä¸€ç³»åˆ—ç›¸å…³æˆ–ç›¸äº’ä¾èµ–å¯¹è±¡çš„æ¥å£ï¼Œè€Œæ— é¡»æŒ‡å®šå®ƒä»¬çš„å…·ä½“ç±»ã€‚ 2ã€åº”ç”¨åœºæ™¯ä¸€ç³»åˆ—ç›¸äº’ä¾èµ–çš„å¯¹è±¡æœ‰ä¸åŒçš„å…·ä½“å®ç°ã€‚æä¾›ä¸€ç§â€œå°è£…æœºåˆ¶â€æ¥é¿å…å®¢æˆ·ç¨‹åºå’Œè¿™ç§â€œå¤šç³»åˆ—å…·ä½“å¯¹è±¡åˆ›å»ºå·¥ä½œâ€çš„ç´§è€¦åˆã€‚ 3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class AbstractBall &#123;public: virtual ~AbstractBall()&#123;&#125; AbstractBall()&#123;&#125; void play()&#123;&#125;;&#125;;class Basketball : public AbstractBall &#123;public: Basketball() &#123; play(); &#125; void play()&#123; printf(&quot;Jungle play Basketball\\n\\n&quot;); &#125;&#125;;class Football : public AbstractBall &#123;public: Football()&#123; play(); &#125; void play()&#123; printf(&quot;Jungle play Football\\n\\n&quot;); &#125;&#125;;class AbstractShirt &#123;public: virtual ~AbstractShirt()&#123;&#125; AbstractShirt()&#123;&#125; void wearShirt()&#123;&#125;;&#125;;class BasketballShirt :public AbstractShirt &#123;public: BasketballShirt()&#123; wearShirt(); &#125; void wearShirt()&#123; printf(&quot;Jungle wear Basketball Shirt\\n\\n&quot;); &#125;&#125;;class FootballShirt :public AbstractShirt &#123;public: FootballShirt()&#123; wearShirt(); &#125; void wearShirt()&#123; printf(&quot;Jungle wear Football Shirt\\n\\n&quot;); &#125;&#125;;class AbstractFactory &#123;public: virtual ~AbstractFactory()&#123;&#125; virtual AbstractBall *getBall() = 0; virtual AbstractShirt *getShirt() = 0;&#125;;class BasketballFactory :public AbstractFactory &#123;public: BasketballFactory()&#123; printf(&quot;BasketballFactory\\n&quot;); &#125; AbstractBall *getBall()&#123; printf(&quot;Jungle get basketball\\n&quot;); return new Basketball(); &#125; AbstractShirt *getShirt()&#123; printf(&quot;Jungle get basketball shirt\\n&quot;); return new BasketballShirt(); &#125;&#125;;class FootballFactory :public AbstractFactory &#123;public: FootballFactory()&#123; printf(&quot;FootballFactory\\n&quot;); &#125; AbstractBall *getBall()&#123; printf(&quot;Jungle get football\\n&quot;); return new Football(); &#125; AbstractShirt *getShirt()&#123; printf(&quot;Jungle get football shirt\\n&quot;); return new FootballShirt(); &#125;&#125;;int main()&#123; AbstractFactory *fac = NULL; AbstractBall *ball = NULL; AbstractShirt *shirt = NULL; fac = new BasketballFactory(); ball = fac-&gt;getBall(); shirt = fac-&gt;getShirt(); delete fac; delete ball; delete shirt; fac = new FootballFactory(); ball = fac-&gt;getBall(); shirt = fac-&gt;getShirt(); delete fac; delete ball; delete shirt; return 0;&#125; 2ã€æ¡ˆä¾‹2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;class IItem &#123;public: virtual ~IItem() &#123;&#125; IItem(const std::string &amp;caption) : m_caption(caption) &#123;&#125; virtual std::string makeHTML() = 0;protected: std::string m_caption;&#125;;class ILink : public IItem &#123;public: virtual ~ILink() &#123;&#125; ILink(const std::string &amp;caption, const std::string &amp;url) : IItem(caption), m_url(url) &#123;&#125;protected: std::string m_url;&#125;;class ITray : public IItem &#123;public: virtual ~ITray() &#123;&#125; ITray(const std::string &amp;caption) : IItem(caption) &#123;&#125; void addItem(IItem *item) &#123; m_itemList.push_back(item); &#125;protected: std::vector&lt;IItem *&gt; m_itemList;&#125;;class ListTray : public ITray &#123;public: using ITray::ITray; std::string makeHTML() override &#123; std::string str; str.append(&quot;&lt;li&gt;\\n&quot;); str.append(m_caption + &quot;\\n&quot;); str.append(&quot;&lt;ul&gt;\\n&quot;); for (auto item : m_itemList) &#123; str.append(item-&gt;makeHTML()); &#125; str.append(&quot;&lt;/ul&gt;\\n&quot;); str.append(&quot;&lt;/li&gt;\\n&quot;); return str; &#125;&#125;;class ListLink : public ILink &#123;public: using ILink::ILink; std::string makeHTML() override &#123; return &quot;&lt;li&gt;&lt;a href=\\&quot;&quot; + m_url + &quot;\\&quot;&gt; &quot; + m_caption + &quot;&lt;/a&gt; &lt;/li&gt;\\n&quot;; &#125;&#125;;class IPage &#123;public: virtual ~IPage() &#123;&#125; IPage(const std::string &amp;title, const std::string &amp;author) : m_title(title), m_author(author) &#123;&#125; void addItem(IItem *item) &#123; m_itemList.push_back(item); &#125; void output() &#123; std::cout &lt;&lt; makeHTML() &lt;&lt; std::endl; &#125; virtual std::string makeHTML() = 0;protected: std::string m_title; std::string m_author; std::vector&lt;IItem *&gt; m_itemList;&#125;;class ListPage : public IPage &#123;public: using IPage::IPage; std::string makeHTML() override &#123; std::string str; str.append(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot; + m_title + &quot;&lt;/head&gt;&lt;/title&gt;\\n&quot;); str.append(&quot;&lt;body&gt;\\n&quot;); str.append(&quot;&lt;h1&gt;&quot; + m_title + &quot;&lt;/h1&gt;\\n&quot;); str.append(&quot;&lt;ul&gt;\\n&quot;); for (auto item : m_itemList) &#123; str.append(item-&gt;makeHTML()); &#125; str.append(&quot;&lt;/ul&gt;\\n&quot;); str.append(&quot;&lt;address&gt;&quot; + m_author + &quot;&lt;/address&gt;\\n&quot;); str.append(&quot;&lt;/body&gt;\\n&quot;); str.append(&quot;&lt;/html&gt;&quot;); return str; &#125;&#125;;class IFactory &#123;public: virtual ~IFactory() &#123;&#125; virtual ILink *createLink(const std::string &amp;caption, const std::string &amp;url) = 0; virtual ITray *createTray(const std::string &amp;caption) = 0; virtual IPage *createPage(const std::string &amp;title, const std::string &amp;author) = 0;&#125;;class IFactoryHelper &#123;public: static void registerFactory(const std::string &amp;name, std::function&lt;IFactory *()&gt; createCallback) &#123; s_createrMap.insert(std::make_pair(name, createCallback)); &#125; static IFactory *getFactory(const std::string &amp;name) &#123; auto itor = s_createrMap.find(name); return itor-&gt;second(); &#125;private: static std::unordered_map&lt;std::string, std::function&lt;IFactory *()&gt;&gt; s_createrMap;&#125;;std::unordered_map&lt;std::string, std::function&lt;IFactory *()&gt;&gt; IFactoryHelper::s_createrMap;class ListFactory : public IFactory &#123;public: ILink *createLink(const std::string &amp;caption, const std::string &amp;url) override &#123; return new ListLink(caption, url); &#125; ITray *createTray(const std::string &amp;caption) override &#123; return new ListTray(caption); &#125; IPage *createPage(const std::string &amp;title, const std::string &amp;author) override &#123; return new ListPage(title, author); &#125;&#125;;static int ListFactoryInit = []() -&gt; int &#123; std::cout &lt;&lt; &quot;1&quot; &lt;&lt; std::endl; IFactoryHelper::registerFactory(&quot;ListFactory&quot;, []() &#123; return new ListFactory; &#125;); return 0;&#125;();int main()&#123; std::shared_ptr&lt;IFactory&gt; factory(IFactoryHelper::getFactory(&quot;ListFactory&quot;)); assert(factory != nullptr); std::shared_ptr&lt;ILink&gt; people(factory-&gt;createLink(u8&quot;äººæ°‘æ—¥æŠ¥&quot;, u8&quot;http://www.people.com.cn/&quot;)); std::shared_ptr&lt;ILink&gt; gmw(factory-&gt;createLink(u8&quot;å…‰æ˜ç½‘&quot;, u8&quot;http://www.gmw.cn/&quot;)); std::shared_ptr&lt;ILink&gt; us_yahoo(factory-&gt;createLink(u8&quot;us_yahoo&quot;, u8&quot;http://www.yahoo.com/&quot;)); std::shared_ptr&lt;ILink&gt; jp_yahoo(factory-&gt;createLink(u8&quot;jp_yahoo&quot;, u8&quot;http://www.yahoo.com.jp/&quot;)); std::shared_ptr&lt;ILink&gt; google(factory-&gt;createLink(u8&quot;google&quot;, u8&quot;http://www.google.com&quot;)); std::shared_ptr&lt;ITray&gt; trayNews(factory-&gt;createTray(&quot;news&quot;)); trayNews-&gt;addItem(people.get()); trayNews-&gt;addItem(gmw.get()); std::shared_ptr&lt;ITray&gt; trayYahoo(factory-&gt;createTray(&quot;yahoo!&quot;)); trayYahoo-&gt;addItem(us_yahoo.get()); trayYahoo-&gt;addItem(jp_yahoo.get()); std::shared_ptr&lt;ITray&gt; traySearch(factory-&gt;createTray(&quot;traySearch&quot;)); trayYahoo-&gt;addItem(trayYahoo.get()); trayYahoo-&gt;addItem(google.get()); std::shared_ptr&lt;IPage&gt; page(factory-&gt;createPage(&quot;LinkPage&quot;, &quot;tao&quot;)); page-&gt;addItem(trayNews.get()); page-&gt;addItem(traySearch.get()); page-&gt;output(); return 0;&#125;","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"è®¾è®¡æ¨¡å¼:01--å·¥å‚æ–¹æ³•æ¨¡å¼","slug":"designPatter/è®¾è®¡æ¨¡å¼-01-å·¥å‚æ–¹æ³•æ¨¡å¼","date":"2022-10-15T14:11:40.000Z","updated":"2022-10-21T05:40:31.403Z","comments":true,"path":"2022/10/15/designPatter/è®¾è®¡æ¨¡å¼-01-å·¥å‚æ–¹æ³•æ¨¡å¼/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-01-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æ¦‚å¿µåŠUMLå›¾1ã€æ¦‚å¿µå®šä¹‰ä¸€ä¸ªç”¨äºåˆ›å»ºå¯¹è±¡çš„æ¥å£ï¼Œè®©å­ç±»å†³å®šå®ä¾‹åŒ–å“ªä¸€ä¸ªç±»ï¼ŒFactory Methodä½¿ä¸€ä¸ªç±»çš„å®ä¾‹åŒ–å»¶è¿Ÿåˆ°äº†å­ç±»ã€‚ 2ã€åº”ç”¨åœºæ™¯äºéœ€æ±‚çš„å˜åŒ–ï¼Œä¸€ä¸ªç±»çš„å­ç±»ç»å¸¸é¢ä¸´ç€å‰§çƒˆçš„å˜åŒ–ï¼Œä½†ä»–å´æ‹¥æœ‰æ¯”è¾ƒç¨³å®šçš„æ¥å£ã€‚ä½¿ç”¨ä¸€ç§å°è£…æœºåˆ¶æ¥â€œéš”ç¦»è¿™ç§æ˜“å˜å¯¹è±¡çš„å˜åŒ–â€ï¼Œå·¥å‚æ–¹æ³•å®šä¹‰ä¸€ä¸ªç”¨äºåˆ›å»ºå¯¹è±¡çš„æ¥å£ï¼Œè®©å­ç±»æ¥ç¡®å®šåˆ›å»ºå“ªä¸€ä¸ªå…·ä½“ç±»çš„å¯¹è±¡ï¼Œå°†å¯¹è±¡çš„å®ä¾‹åŒ–å»¶è¿Ÿã€‚ 3ã€UML äºŒã€æ¡ˆä¾‹1ã€æ¡ˆä¾‹112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class AbstractSportProduct &#123;public: AbstractSportProduct() &#123;&#125; virtual ~AbstractSportProduct()&#123;&#125; void printName()&#123;&#125;; void play()&#123;&#125;;&#125;;class Basketball : public AbstractSportProduct &#123;public: Basketball()&#123; printName(); play(); &#125; void printName()&#123; printf(&quot;Jungle get Basketball\\n&quot;); &#125; void play()&#123; printf(&quot;Jungle play Basketball\\n&quot;); &#125;&#125;;class AbstractFactory &#123;public: virtual AbstractSportProduct *getSportProduct() = 0; virtual ~AbstractFactory()&#123;&#125;&#125;;class BasketballFactory : public AbstractFactory &#123;public: BasketballFactory() &#123; printf(&quot;BasketballFactory\\n&quot;); &#125; AbstractSportProduct *getSportProduct() &#123; printf(&quot;basketball&quot;); return new Basketball(); &#125;&#125;;int main()&#123; AbstractFactory *fac = NULL; AbstractSportProduct *product = NULL; fac = new BasketballFactory(); product = fac-&gt;getSportProduct(); if (fac) &#123; delete fac; &#125; if (product) &#123; delete product; &#125; return 0;&#125; 2ã€æ¡ˆä¾‹212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;class IProduct &#123;public: virtual ~IProduct() &#123;&#125; virtual void use() = 0;&#125;;class IDCard : public IProduct &#123;public: IDCard(const std::string &amp;owner) : m_owner(owner) &#123;&#125; void use() override &#123; std::cout &lt;&lt; &quot;use IDCare with owner&quot; &lt;&lt; m_owner &lt;&lt; std::endl; &#125;private: std::string m_owner;&#125;;class IFactory &#123;public: virtual ~IFactory() &#123;&#125; virtual void registerProduct(IProduct *) = 0; virtual IProduct *createProduct(const std::string &amp;owner) = 0; virtual IProduct *create(const std::string &amp;owner) &#123; auto *pro = createProduct(owner); registerProduct(pro); return pro; &#125;&#125;;class IDCareFactory : public IFactory &#123;public: IProduct *createProduct(const std::string &amp;owner) &#123; return new IDCard(owner); &#125; void registerProduct(IProduct *pro) &#123; m_productList.push_back(pro); &#125;private: std::vector&lt;IProduct *&gt; m_productList;&#125;;int main()&#123; IFactory *fac = new IDCareFactory; IProduct *pro = fac-&gt;create(&quot;tao&quot;); IProduct *pro2 = fac-&gt;create(&quot;tao2&quot;); pro-&gt;use(); pro2-&gt;use(); delete pro; delete fac; delete pro2; return 0;&#125;","categories":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++:06--functionä¸bindåŠLamdaå®ç°å›è°ƒå‡½æ•°","slug":"C++/C-06-functionä¸bindåŠLamdaå®ç°å›è°ƒå‡½æ•°","date":"2022-10-15T01:59:13.000Z","updated":"2022-10-16T01:41:46.766Z","comments":true,"path":"2022/10/15/C++/C-06-functionä¸bindåŠLamdaå®ç°å›è°ƒå‡½æ•°/","link":"","permalink":"http://example.com/2022/10/15/C++/C-06-function%E4%B8%8Ebind%E5%8F%8ALamda%E5%AE%9E%E7%8E%B0%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","excerpt":"","text":"ä¸€ã€ä½¿ç”¨std::functionä½œä¸ºå‡½æ•°å…¥å‚1ã€åŸºäºä¼ å€¼çš„æ–¹å¼ä¼ é€’å‚æ•°12#include &lt;functional&gt;void registerCallBack(std::function&lt;void()&gt;); ä¸Šé¢çš„ä»£ç å®ç°äº†ä¸€ä¸ªæ³¨å†Œå›è°ƒå‡½æ•°çš„æœºåˆ¶ï¼Œå…¥å‚std::function&lt;void()&gt;æ˜¯ä¸€ä¸ªæ¨¡æ¿ç±»å¯¹è±¡ï¼Œ å®ƒå¯ä»¥ç”¨ä¸€ä¸ªå‡½æ•°ç­¾åä¸ºvoid()çš„å¯è°ƒç”¨å¯¹è±¡æ¥è¿›è¡Œåˆå§‹åŒ–ã€‚ 1234// æ–¹æ³•ï¼ˆAï¼‰registerCallBack([=]&#123; .... // å›è°ƒå‡½æ•°çš„å®ç°éƒ¨åˆ†&#125;) è¿™é‡Œä½¿ç”¨äº†lambdaè¡¨è¾¾å¼ä½œä¸ºå‡½æ•°çš„å…¥å‚ï¼Œlambdaè¡¨è¾¾å¼ä¼šç”Ÿæˆä¸€ä¸ªåŒ¿åçš„é—­åŒ…ï¼Œ åŸºäºè¿™ä¸ªé—­åŒ…æ„é€ äº†ä¸€ä¸ªstd::function&lt;void()&gt;çš„å¯¹è±¡ï¼Œ ç„¶åé€šè¿‡ä¼ å€¼è°ƒç”¨çš„æ–¹å¼æŠŠè¿™ä¸ªå¯¹è±¡ä¼ é€’registerCallBackå‡½æ•°ä¸­ä½¿ç”¨ã€‚ 2ã€åŸºäºå¼•ç”¨çš„æ–¹å¼ä¼ é€’å‚æ•°å½“ç„¶è¿˜å¯ä»¥å¦‚ä¸‹å®ç°è¿™ä¸ªæ³¨å†Œå‡½æ•°ï¼Œå…¥å‚é€šè¿‡constå¼•ç”¨çš„æ–¹å¼ä¼ é€’ï¼Œè¿™é‡Œçš„å¼•ç”¨å¿…é¡»æ˜¯constçš„ï¼Œ è¿™æ˜¯å› ä¸ºè°ƒç”¨registerCallBackå‡½æ•°çš„åœ°æ–¹ç”Ÿæˆäº†ä¸€ä¸ªä¸´æ—¶çš„std::function()å¯¹è±¡ï¼Œ æ˜¯ä¸€ä¸ªå³å€¼ï¼Œå¦åˆ™ç¼–è¯‘ä¼šæŠ¥é”™ã€‚ 123//æ–¹æ³•(B)#include &lt;functional&gt;void registerCallBack(std::function&lt;void()&gt; const&amp;); è¿™ä¼ å€¼å’Œå¼•ç”¨åŒºåˆ«å°±åœ¨äºï¼Œåœ¨registerCallBackå‡½æ•°å†…éƒ¨æ€ä¹ˆä½¿ç”¨è¿™ä¸ªå…¥å‚ï¼Œ 1) å¦‚æœåªæ˜¯ç®€å•çš„è°ƒç”¨ä¸€ä¸‹std::func()ç±»ï¼Œé‚£ä¹ˆä¸¤ç§éƒ½æ²¡æœ‰é—®é¢˜ï¼Œå¯èƒ½ä½¿ç”¨å¼•ç”¨çš„æ•ˆç‡æ›´é«˜ï¼› 2) å¦‚æœregisterå‡½æ•°å†…éƒ¨éœ€è¦ä¿å­˜è¿™ä¸ªstd::func()ï¼Œå¹¶ç”¨äºä»¥åä½¿ç”¨ï¼Œé‚£ä¹ˆæ–¹æ³•Aç›´æ¥ä¿å­˜æ²¡æœ‰é—®é¢˜ï¼Œ æ–¹æ³•Bå°±å¿…é¡»åšä¸€æ¬¡æ‹·è´ï¼Œå¦åˆ™æ–¹æ³•Bä¸­ï¼Œå½“ä¸´æ—¶çš„å¯¹è±¡é”€æ¯æ—¶ï¼Œæœ‰å¯èƒ½å‡ºç°å¼•ç”¨æ‚¬ç©ºçš„é—®é¢˜ã€‚ 3ã€ä¼ å€¼æ–¹å¼ä¸‹çš„std::functionå¯¹è±¡ä¿å­˜å¦‚æœè¦åœ¨registerCallBackå‡½æ•°å†…éƒ¨ä¿å­˜ä¼ å…¥çš„functionå¯¹è±¡ï¼Œå¯ä»¥ä½¿ç”¨std::moveï¼Œæ•ˆç‡æ›´é«˜ã€‚ 123456789class CallBackHolder &#123;public:void registerCallBack(std::function&lt;void()&gt; func) &#123; callback = std::move(func);&#125; private: std::function&lt;void()&gt; callback; &#125; äºŒã€ç±»çš„æˆå‘˜å‡½æ•°ä½œä¸ºå‡½æ•°å…¥å‚ç±»çš„æˆå‘˜å‡½æ•°éƒ½ä¼šé»˜è®¤æœ‰ä¸ªéšè—çš„thisæŒ‡é’ˆï¼Œæ‰€ä»¥ä¸åƒæ™®é€šçš„å‡½æ•°ç›´æ¥ä½œä¸ºå…¥å‚å°±å¯ä»¥äº†ã€‚ 1ã€ä½¿ç”¨bindå’Œfunctionæ¥å®ç°1234567891011121314151617class classA &#123;typedef std::function&lt;void(int i)&gt; callback_t;... void registCb(callback_t func) &#123; cbHandle = std::move(func); &#125;private: callback_t cbHandle;&#125;;class classB &#123;public: classB(classA&amp; cA) &#123; cA.registCb(bind(&amp;classB::handle, this, placeholders::_1)); &#125;&#125;; 2ã€ä½¿ç”¨lambdaè¡¨è¾¾å¼å®ç°123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;class classA &#123;typedef std::function&lt;void(int i)&gt; callback_t;public: classA() &#123;&#125; ~classA() &#123;&#125; void handle(int i) &#123; std::cout &lt;&lt; &quot;classA::handle&quot; &lt;&lt; std::endl; cbHandle(i); &#125; void registCb(callback_t func) &#123;cbHandle = std::move(func);&#125;private: callback_t cbHandle;&#125;;class classB &#123;public: classB(classA&amp; cA) &#123; cA.registCb([this](int i)&#123;classB::handle(i);&#125;); &#125; ~classB() &#123;&#125; void handle(int i)&#123; std::cout &lt;&lt; &quot;classB, handle message&quot; &lt;&lt; i &lt;&lt; std::endl; &#125;&#125;;int main()&#123; classA testa; classB testb(testa); testa.handle(10);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:05--Lamdaè¡¨è¾¾å¼ä½¿ç”¨åœºæ™¯","slug":"C++/C-05-Lamdaè¡¨è¾¾å¼ä½¿ç”¨åœºæ™¯","date":"2022-10-14T06:54:13.000Z","updated":"2022-10-21T02:06:11.698Z","comments":true,"path":"2022/10/14/C++/C-05-Lamdaè¡¨è¾¾å¼ä½¿ç”¨åœºæ™¯/","link":"","permalink":"http://example.com/2022/10/14/C++/C-05-Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"ä¸€ã€lamdaè¡¨è¾¾å¼å˜é‡æˆªå–æ–¹å¼1ã€å®šä¹‰ 1) å˜é‡æˆªå–æ–¹å¼ 2) Lambdaè¡¨è¾¾å¼çš„å‚æ•°åˆ—è¡¨ 3) Mutable æ ‡è¯† 4) å¼‚å¸¸æ ‡è¯† 5) è¿”å›å€¼ 6) â€œå‡½æ•°â€ä½“ï¼Œä¹Ÿå°±æ˜¯lambdaè¡¨è¾¾å¼éœ€è¦è¿›è¡Œçš„å®é™…æ“ä½œ 2ã€å˜é‡æˆªå–æ–¹å¼[] ä¸æˆªå–ä»»ä½•å˜é‡ [&amp;] æˆªå–å¤–éƒ¨ä½œç”¨åŸŸä¸­æ‰€æœ‰å˜é‡ï¼Œå¹¶ä½œä¸ºå¼•ç”¨åœ¨å‡½æ•°ä½“ä¸­ä½¿ç”¨ [&#x3D;] æˆªå–å¤–éƒ¨ä½œç”¨åŸŸä¸­æ‰€æœ‰å˜é‡ï¼Œå¹¶æ‹·è´ä¸€ä»½åœ¨å‡½æ•°ä½“ä¸­ä½¿ç”¨ [&#x3D;, &amp;foo]æˆªå–å¤–éƒ¨ä½œç”¨åŸŸä¸­æ‰€æœ‰å˜é‡ï¼Œå¹¶æ‹·è´ä¸€ä»½åœ¨å‡½æ•°ä½“ä¸­ä½¿ç”¨ï¼Œä½†æ˜¯å¯¹fooä½¿ç”¨å¼•ç”¨ [bar] æˆªå–barå˜é‡å¹¶ä¸”æ‹·è´ä¸€ä»½åœ¨å‡½æ•°ä½“é‡ä½¿ç”¨ï¼ŒåŒæ—¶ä¸æˆªå–å…¶ä»–å˜é‡ [this] æˆªå–å½“å‰ç±»ä¸­çš„thisæŒ‡é’ˆã€‚å¦‚æœå·²ç»ä½¿ç”¨äº†&amp;æˆ–è€…&#x3D;å°±é»˜è®¤æ·»åŠ æ­¤é€‰é¡¹ äºŒã€lamdaè¡¨è¾¾å¼ä½¿ç”¨åœºæ™¯1ã€åœºæ™¯1ç®€åŒ–å†™æ³•ã€‚ //1.1vectoræ•°ç»„æ±‚å’Œ 1234567891011int main()&#123; std::vector&lt;int&gt; some_list; int total = 0; for (int i = 0; i &lt; 5; ++i) some_list.push_back(i); for_each(begin(some_list), end(some_list), [&amp;total](int x) &#123;total += x;&#125;); return 0;&#125; //1.2vectoræ•°ç»„æ’åº 123456789101112int main(void)&#123; int data[6] = &#123; 3, 4, 12, 2, 1, 6 &#125;; vector&lt;int&gt; testdata; testdata.insert(testdata.begin(), data, data + 6); // æ’åºç®—æ³• sort(testdata.begin(), testdata.end(), [](int a, int b) &#123; return a &gt; b; &#125;); return 0;&#125; 2ã€åœºæ™¯2ä»¥å‰ç±»ä¸­å¼€å¯çº¿ç¨‹éƒ½éœ€è¦é€šè¿‡é™æ€æˆå‘˜å‡½æ•°ï¼Œç°åœ¨é€šè¿‡Lambdaè¡¨è¾¾å¼ï¼Œ åœ¨ä¸­æ‹¬å·[this]ä¸­å¯ä»¥ç›´æ¥è®¿é—®åˆ°ç±»ä¸­çš„æˆå‘˜å˜é‡ã€‚ 123456789101112131415161718192021222324class A&#123;public: A(); ~A();//ææ„private: std::unique_ptr&lt;std::thread&gt; monitorThread; int a;&#125;;A::A()&#123; monitorThread = make_unique&lt;thread&gt;([this] &#123; while (true) &#123; cout &lt;&lt; &quot;i can access a &quot; &lt;&lt; a++ &lt;&lt; endl; Sleep(100); &#125; &#125;);&#125;A::~A()&#123;&#125; 3ã€åœºæ™¯3å›è°ƒå‡½æ•°å®ç° 123456789101112131415161718192021222324252627class MathCallBack &#123; int ops1,ops2; int result;public: void Add(int a,int b, function&lt;void (int)&gt; func) &#123; ops1 = abs(a); ops2 = abs(b); result = ops1+ops2; func(result); &#125;&#125;;int main()&#123; MathCallBack math; int c1 = 0; math.Add(1, 3, [&amp;c1](int result) -&gt; void &#123; printf(&quot;result = %d\\n&quot;, result); c1 = result; &#125;); printf(&quot;c1 = %d\\n&quot;, c1); return 0;&#125; lambdaè¡¨è¾¾å¼å¯ä»¥ä»¥å¼•ç”¨æ–¹å¼æ•è·ä¸Šä¸‹æ–‡ä¸­çš„å˜é‡ï¼Œè¾¾åˆ°å›è°ƒçš„æ•ˆæœã€‚ 4ã€æ›´å¤šå‚è€ƒä¾‹å­12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364vector&lt; int&gt; vec;/* 1. simple lambda */ auto it = std::find_if(vec.begin(), vec.end(), [](int i) &#123; return i &gt; 50; &#125;); class A &#123; public: bool operator(int i) const &#123; return i &gt; 50; &#125; &#125;;auto it = std::find_if(vec.begin(), vec.end(), A()); /* 2. lambda return syntax */ function&lt;int(int)&gt; square = [](int i) -&gt; int &#123;return i * i;&#125; /* 3. lambda expr: capture of local variable */ &#123; int min_val = 10; int max_val = 1000; auto it = find_if(vec.begin(), vec.end(), [=](int i) &#123;return i &gt; min_val &amp;&amp; i &lt; max_val;&#125;); auto it = find_if(vec.begin(), vec.end(), [&amp;](int i) &#123;return i &gt; min_val &amp;&amp; i &lt; max_val;&#125;); auto it = find_if(vec.begin(), vec.end(), [=, &amp;max_value](int i) &#123;return i &gt; min_val &amp;&amp; i &lt; max_val;&#125;); &#125; /* 4. lambda expr: capture of class member */ class A &#123; public: void DoSomething(); private: std::vector&lt;int&gt; m_vec; int m_min_val; int m_max_va; &#125;; /* 4.1 capture member by this */ void A::DoSomething() &#123; auto it = find_if(m_vec.begin(), m_vec.end(), [this](int i)&#123; return i &gt; m_min_val &amp;&amp; i &lt; m_max_val;&#125;); &#125; /* 4.2 capture member by default pass-by-value */ void A::DoSomething() &#123; auto it = find_if(m_vec.begin(), m_vec.end(), [=](int i)&#123; return i &gt; m_min_val &amp;&amp; i &lt; m_max_val; &#125;); &#125; /* 4.3 capture member by default pass-by-reference */ void A::DoSomething() &#123; auto it = find_if(m_vec.begin(), m_vec.end(), [&amp;](int i)&#123; return i &gt; m_min_val &amp;&amp; i &lt; m_max_val;&#125;); &#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:04--std::functionå’Œstd::bindçš„ç”¨æ³•","slug":"C++/C-04-std-functionå’Œstd-bindçš„ç”¨æ³•","date":"2022-10-14T06:26:43.000Z","updated":"2022-10-16T01:41:35.186Z","comments":true,"path":"2022/10/14/C++/C-04-std-functionå’Œstd-bindçš„ç”¨æ³•/","link":"","permalink":"http://example.com/2022/10/14/C++/C-04-std-function%E5%92%8Cstd-bind%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"ä¸€ã€std::functionçš„ç”¨æ³•1ã€ä¿å­˜è‡ªç”±å‡½æ•°123456789void printA(int a)&#123; cout &lt;&lt; a &lt;&lt; endl;&#125;std::function&lt;void(int a)&gt; func;func = printA;func(2); 2ã€ä¿å­˜lamdaè¡¨è¾¾å¼12std::function&lt;void()&gt; func_1 = []()&#123;cout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl;&#125;;func_1(); 3ã€ä¿å­˜å‡½æ•°å¯¹è±¡12345678910class CStudent&#123;public: void operator() (string strName, int nAge) &#123; cout &lt;&lt; strName &lt;&lt; &quot; : &quot; &lt;&lt; nAge &lt;&lt; endl; &#125;&#125;;CStudent stu;function&lt;void (string, int)&gt; f = stu;f(&quot;Mike&quot;, 12); 4ã€ä¿å­˜æˆå‘˜å‡½æ•°1234567891011121314struct Foo &#123; Foo(int num) : num_(num) &#123;&#125; void print_add(int i) const &#123; cout &lt;&lt; num_+i &lt;&lt; &#x27;\\n&#x27;; &#125; int num_;&#125;;int main()&#123; std::function&lt;void(const Foo&amp;, int)&gt; f_add_display = &amp;Foo::print_add; Foo foo(2); f_add_display(foo, 1); return 0;&#125; åœ¨å®é™…ä½¿ç”¨ä¸­éƒ½ç”¨ auto å…³é”®å­—æ¥ä»£æ›¿std::functionâ€¦ è¿™ä¸€é•¿ä¸²äº† ä¸€ã€std::bindçš„ç”¨æ³•1ã€ç”¨æ³•æ¡ˆä¾‹1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859using namespace std;class A &#123;public: void fun_3(int k, int m) &#123; cout&lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; endl; &#125;&#125;;void fun(int x, int y, int z)&#123; cout&lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; z &lt;&lt; endl;&#125;void fun_2(int &amp;a, int &amp;b)&#123; a++; b++; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;&#125;int main(int argc, const char * argv[])&#123; /* è¡¨ç¤ºç»‘å®šå‡½æ•°funçš„ç¬¬ä¸€ï¼ŒäºŒï¼Œä¸‰ä¸ªå‚æ•°å€¼ä¸ºï¼š 1 2 3 */ auto f1 = std::bind(fun,1,2,3); f1(); //print:1 2 3 /* å‰ä¸¤ä¸ªå½¢å‚ä¸ºå ä½ç¬¦ï¼Œè°ƒç”¨æ—¶ç¡®å®šï¼Œç¬¬ä¸‰ä¸ªä¸º3 */ auto f2 = std::bind(fun, placeholders::_1, placeholders::_2, 3); f2(1, 2); //print:1 2 3 /* å‰ä¸¤ä¸ªå½¢å‚ä¸ºå ä½ç¬¦ï¼Œè°ƒç”¨æ—¶ç¡®å®šï¼Œç¬¬ä¸‰ä¸ªä¸º3 */ auto f3 = std::bind(fun, placeholders::_2, placeholders::_1, 3); /* æ³¨æ„ï¼š f2å’Œf3çš„åŒºåˆ« */ f3(1, 2); //print:2 1 3 int n = 2; int m = 3; auto f4 = std::bind(fun_2, n, placeholders::_1); f4(m); //print: 3 4 /* æ‰“å°4ï¼Œè¯´æ˜bindé€šè¿‡std::placeholdersä¼ é€’çš„å‚æ•°æ˜¯é€šè¿‡å¼•ç”¨ä¼ é€’çš„ */ cout &lt;&lt; m &lt;&lt; endl; /* æ‰“å°2ï¼Œè¯´æ˜ï¼šbindå¯¹äºé¢„å…ˆç»‘å®šçš„å‡½æ•°å‚æ•°æ˜¯é€šè¿‡å€¼ä¼ é€’çš„ */ cout &lt;&lt; n &lt;&lt; endl; A a; auto f5 = std::bind(&amp;A::fun_3, a, placeholders::_1, placeholders::_2); f5(10, 20); //print:10 20 std::function&lt;void(int,int)&gt; fc = bind(&amp;A::fun_3, a, placeholders::_1, placeholders::_2); fc(10,20); //print:10 20 return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:03--å¤šçº§æ··åˆç»§æ‰¿ã€è™šåŸºç±»","slug":"C++/C-03-å¤šçº§æ··åˆç»§æ‰¿ã€è™šåŸºç±»","date":"2022-10-13T10:26:35.000Z","updated":"2022-10-16T01:41:28.862Z","comments":true,"path":"2022/10/13/C++/C-03-å¤šçº§æ··åˆç»§æ‰¿ã€è™šåŸºç±»/","link":"","permalink":"http://example.com/2022/10/13/C++/C-03-%E5%A4%9A%E7%BA%A7%E6%B7%B7%E5%90%88%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%9F%BA%E7%B1%BB/","excerpt":"","text":"ä¸€ã€å¤šçº§æ··åˆç»§æ‰¿1ã€ä¾‹å­1234567891011121314151617181920212223242526272829303132//è±å½¢ç»§æ‰¿class A &#123;public: int data;&#125;;class B : public A &#123;public: int data;&#125;;class C : public A &#123;public: int data;&#125;;class D : public B, public C &#123;public: int data;&#125;;int main()&#123; D c; D.data=1; D.B::data=2;//è®¿é—®Bä¸­çš„ D.C.::data=3;//è®¿é—®Cä¸­çš„ D.B::A::data=4;//è®¿é—®Bç»§æ‰¿çš„A D.C::A::data=5;//è®¿é—®Cç»§æ‰¿çš„A D.A::data=4;//é”™è¯¯ï¼Œäº§ç”ŸäºŒä¹‰æ€§ï¼Œä¸çŸ¥é“æ˜¯Bã€Cä¸­å“ªä¸€ä¸ª&#125; 2ã€å†…å­˜å¤§å° 3ã€å†…å­˜å›¾è§£ ä¸€ã€è™šåŸºç±»1ã€æ¦‚å¿µ1) ä¹Ÿç§°è™šç»§æ‰¿ã€è±å½¢ç»§æ‰¿ã€‚ç”¨äºå¤šçº§æ··åˆç»§æ‰¿æ—¶ï¼Œä¿ç•™ä¸€ä¸ªè™šåŸºç±»ã€‚ 2) æ„é€ é¡ºåº å…ˆæ„é€ è™šåŸºç±»ï¼Œå¦‚æœæœ‰å¤šä¸ªè™šåŸºç±»ï¼ŒæŒ‰å£°æ˜ï¼ˆä»å·¦è‡³å³ï¼‰ä¾æ¬¡æ„é€ ; å†æ„é€ åŸºç±»ï¼Œå¦‚æœæœ‰å¤šä¸ªåŸºç±»ï¼ŒæŒ‰å£°æ˜ï¼ˆä»å·¦è‡³å³ï¼‰ä¾æ¬¡æ„é€ ; å¦‚æœæœ‰å­å¯¹è±¡ï¼Œå†æ„é€ å­å¯¹åƒï¼Œå¦‚æœæœ‰å¤šä¸ªå­å¯¹è±¡ï¼ŒæŒ‰å£°æ˜çš„é¡ºåºï¼ˆä»ä¸Šè‡³ä¸‹ï¼‰ä¾æ¬¡æ„é€ ; æœ€åæ„é€ è‡ªå·±ã€‚ 2ã€ä¾‹å­1234567891011121314151617181920212223242526272829303132class A &#123;public: A(int data)&#123;&#125;//1 int data;&#125;;class B : virtual public A &#123;public: B():A(1)&#123;&#125;//2 int data;&#125;;class C : virtual public A &#123;public: C() : A(2)&#123;&#125;//3 int data;&#125;;class D : public B, public C &#123;public: D() : A(3)&#123;&#125;//4 int data;&#125;;int main() &#123; D d; d.data=1; d.B::data=2; d.C::data=3; d.B::A.data=4; d.C::A::data=5;&#125; 1) æ„é€ é¡ºåºä¸ºï¼š1-2-3-4 2) æ„é€ é¡ºåºè§£é‡Šï¼šæ„é€ ç±»Då¯¹è±¡dçš„æ—¶å€™ï¼Œå‘ç°ç»§æ‰¿äºBï¼Œäºæ˜¯å»æ„é€ Bï¼Œ æ„é€ Bçš„æ—¶å€™ï¼Œå‘ç°ç»§æ‰¿äºè™šåŸºç±»Aï¼Œäºæ˜¯æ„é€ è™šåŸºç±»Aï¼Œæ¥ç€æ„é€ Bã€‚ å†æ¥ç€æ„é€ Cï¼Œå‘ç°Cç»§æ‰¿äºè™šåŸºç±»Aï¼Œä½†å‘ç°è™šåŸºç±»Aå·²ç»è¢«Bæ„é€ è¿‡äº†ï¼Œ æ‰€ä»¥ä¸å†æ„é€ Aï¼Œç›´æ¥æ„é€ Cã€‚æœ€åæ„é€ Dã€‚ 3) å¦‚æœè™šåŸºç±»æ„é€ å‡½æ•°ä¸ºå¸¦å‚æ„é€ ï¼Œåˆ™å…¶å­ç±»ï¼Œä»¥åŠå­ç±»æ‹“å±•å‡ºæ¥çš„å­ç±»ï¼Œ éƒ½è¦åœ¨æˆå‘˜åˆå§‹åŒ–åˆ—è¡¨å¯¹å…¶è¿›è¡Œæ„é€ å‡½æ•°çš„åˆå§‹åŒ–ã€‚ 4) dçš„dataèµ‹å€¼ä¸º1ï¼Œç»§æ‰¿äºBã€Cï¼Œåˆ†åˆ«èµ‹å€¼ä¸º2,3ï¼Œé¡ºåºä¸ºä»å·¦è‡³å³ã€‚ Açš„å€¼æœ¬æ¥ä¸º4ï¼Œåæ¥æ‰§è¡Œåˆ°æœ€åä¸€è¡Œçš„æ—¶å€™è¢«èµ‹å€¼ä¸º5 3ã€å†…å­˜å¤§å° 4ã€å†…å­˜å›¾è§£","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:02--æˆå‘˜å˜é‡åˆå§‹åŒ–æ–¹å¼","slug":"C++/C-02-æˆå‘˜å˜é‡åˆå§‹åŒ–æ–¹å¼","date":"2022-10-13T08:58:08.000Z","updated":"2022-10-30T13:55:09.488Z","comments":true,"path":"2022/10/13/C++/C-02-æˆå‘˜å˜é‡åˆå§‹åŒ–æ–¹å¼/","link":"","permalink":"http://example.com/2022/10/13/C++/C-02-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/","excerpt":"","text":"ä¸€ã€æˆå‘˜å˜é‡3ç§åˆå§‹åŒ–æ–¹å¼1) åœ¨æ„é€ å‡½æ•°ä½“å†…èµ‹å€¼åˆå§‹åŒ– 2) åœ¨è‡ªå®šä¹‰çš„å…¬æœ‰å‡½æ•°ä½“ä¸­èµ‹å€¼åˆå§‹åŒ–ï¼ˆä¸€èˆ¬ç”¨äºæˆå‘˜å˜é‡çš„åˆå§‹åŒ–ï¼‰ 3) åœ¨æ„é€ å‡½æ•°çš„æˆå‘˜åˆå§‹åŒ–åˆ—è¡¨åˆå§‹åŒ– äºŒã€æ„é€ å‡½æ•°ä½“å†…åˆå§‹åŒ–1ã€è¯´æ˜åœ¨æ„é€ å‡½æ•°ä½“å†…çš„åˆå§‹åŒ–æ–¹å¼ï¼Œæœ¬è´¨æ˜¯æ˜¯ä¸ºæˆå‘˜å˜é‡èµ‹å€¼ï¼Œè€Œä¸æ˜¯çœŸæ­£æ„ä¹‰ä¸Šçš„åˆå§‹åŒ–ã€‚ 2ã€æ¡ˆä¾‹1234567891011class Cperson &#123;public: Cperson(int age, float height) &#123; m_age = age; m_height = height; &#125;private: int m_age; float m_height;&#125; ä¸‰ã€è‡ªå®šä¹‰çš„å…¬æœ‰å‡½æ•°ä½“ä¸­èµ‹å€¼åˆå§‹åŒ–1ã€è¯´æ˜ä¸æ„é€ å‡½æ•°ä½“å†…åˆå§‹åŒ–æ–¹å¼ä¸€æ ·ï¼Œæ­¤ç§æ–¹å¼æœ¬è´¨ä¸Šä¹Ÿæ˜¯èµ‹å€¼ï¼Œè€Œä¸æ˜¯åˆå§‹åŒ–ã€‚ 2ã€æ¡ˆä¾‹1234567891011class Cperson &#123;public: void setPerson(int age, float height) &#123; m_age = age; m_height = height; &#125;private: int m_age; float m_height;&#125; å››ã€æˆå‘˜åˆå§‹åŒ–åˆ—è¡¨åˆå§‹åŒ–1ã€è¯´æ˜1) å†™åœ¨æ„é€ å‡½æ•°çš„åé¢ï¼Œéšç€æ„é€ å‡½æ•°çš„æ‰§è¡Œè€Œæ‰§è¡Œã€‚ 2) åˆå§‹åŒ–åˆ—è¡¨åˆå§‹åŒ–ä¼˜å…ˆäºæ„é€ å‡½æ•°å†…çš„ä»£ç æ‰§è¡Œé¡ºåºã€‚ 3) ä¸€èˆ¬åªå¯¹æ— åŠ¨æ€å†…å­˜çš„æˆå‘˜ã€constæˆå‘˜ã€å¼•ç”¨åˆå§‹åŒ–, å…¶ä¸­constæˆå‘˜ã€å¼•ç”¨æˆå‘˜å¿…é¡»åœ¨åˆå§‹åŒ–åˆ—è¡¨åˆå§‹åŒ–ã€‚ 4) æˆå‘˜åˆå§‹åŒ–åˆ—è¡¨åˆå§‹åŒ–æ•ˆç‡æ›´é«˜ã€‚ 5) æœ‰åŠ¨æ€å†…å­˜çš„æˆå‘˜å¿…é¡»åœ¨æ„é€ å‡½æ•°å†…éƒ¨è¿›è¡Œåˆå§‹åŒ–ã€‚ 2ã€æ¡ˆä¾‹1 (constæˆå‘˜ã€å¼•ç”¨æˆå‘˜å¿…é¡»åœ¨åˆå§‹åŒ–åˆ—è¡¨åˆå§‹åŒ–)123456789101112131415class Person &#123;public: Person(int i);private: const int id; int&amp; m_id;&#125;;Person::Person(int i)&#123; id = i; //é”™è¯¯ï¼Œconstæˆå‘˜å˜é‡å¿…é¡»åœ¨æˆå‘˜åˆå§‹åŒ–åˆ—è¡¨åˆå§‹åŒ– m_id = id; //é”™è¯¯ï¼Œå¼•ç”¨ä¹Ÿå¿…é¡»åœ¨æˆå‘˜åˆå§‹åŒ–åˆ—è¡¨åˆå§‹åŒ–&#125; 3ã€æ¡ˆä¾‹2 (æˆå‘˜åˆå§‹åŒ–åˆ—è¡¨åˆå§‹åŒ–æ•ˆç‡æ›´é«˜)1234567891011class Word&#123;public: Word()&#123; _name=0; //å…ˆåˆ›å»ºä¸€ä¸ªä¸´æ—¶stringå¯¹è±¡ï¼Œèµ‹å€¼ä¸º0ï¼Œç„¶åæ‹·è´ç»™_name _cnt=0; //æ„é€ å‡½æ•°ç»“æŸä¹‹åï¼Œä¸´æ—¶å¯¹è±¡ææ„é‡Šæ”¾ &#125;private: string _name; int _cnt;&#125;; ä½†æ˜¯å¦‚æœä½¿ç”¨ä¸‹é¢çš„æˆå‘˜åˆå§‹åŒ–åˆ—è¡¨åˆå§‹åŒ–ï¼Œé‚£ä¹ˆå°±çœå»äº†åˆ›å»ºä¸´æ—¶å¯¹è±¡å†æ‹·è´çš„è¿‡ç¨‹ 12345678 class Word&#123; public: Word() :_name(0),_cnt(0)&#123;&#125; //ç›´æ¥åˆå§‹åŒ–_nameï¼Œä¸åˆ›å»ºä¸´æ—¶å¯¹è±¡ private: string _name; int _cnt;&#125;; äº”ã€æ€»ç»“1) æˆå‘˜åˆå§‹åŒ–åˆ—è¡¨åˆå§‹åŒ–æˆå‘˜æ‰æ˜¯çœŸæ­£æ„ä¹‰ä¸Šçš„åˆå§‹åŒ–ï¼Œå…¶ä»–ä¸¤ç§æ–¹å¼éƒ½æ˜¯ä¸ºèµ‹å€¼ã€‚ 2) åˆå§‹åŒ–æ˜¯ç›´æ¥åˆå§‹åŒ–ã€‚è€Œèµ‹å€¼æ˜¯å…ˆåˆå§‹åŒ–ä¸€ä¸ªä¸´æ—¶å˜é‡ï¼Œå†èµ‹å€¼ã€‚å‰è€…æ•ˆç‡é«˜ã€‚","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:01--thisæŒ‡é’ˆ","slug":"C++/C-01-thisæŒ‡é’ˆ","date":"2022-10-13T08:09:26.000Z","updated":"2022-10-16T01:41:16.814Z","comments":true,"path":"2022/10/13/C++/C-01-thisæŒ‡é’ˆ/","link":"","permalink":"http://example.com/2022/10/13/C++/C-01-this%E6%8C%87%E9%92%88/","excerpt":"","text":"ä¸€ã€thisæŒ‡é’ˆåº”ç”¨1ã€å‰–æ1) å¯¹äºç±»æˆå‘˜å‡½æ•°è€Œè¨€ï¼Œå¹¶ä¸æ˜¯ä¸€ä¸ªå¯¹è±¡å¯¹åº”ä¸€ä¸ªå•ç‹¬çš„æˆå‘˜å‡½æ•°ä½“ï¼Œè€Œæ˜¯æ­¤ç±»çš„æ‰€æœ‰å¯¹è±¡å…±ç”¨è¿™ä¸ªæˆå‘˜å‡½æ•°ä½“ã€‚ å½“ç¨‹åºè¢«ç¼–è¯‘ä¹‹åï¼Œæ­¤æˆå‘˜å‡½æ•°åœ°å€å·²ç»ç¡®å®šã€‚ 1) è°ƒç”¨ç±»çš„æˆå‘˜å‡½æ•°æ—¶ï¼Œä¼šå°†å½“å‰å¯¹è±¡çš„thisæŒ‡é’ˆä¼ é€’ç»™æˆå‘˜å‡½æ•°ï¼Œç„¶ååœ¨å‡½æ•°ä½“å†…å¯¹ç±»çš„æ•°æ®æˆå‘˜è®¿é—®æ—¶ï¼Œ å°±ä¼šè¢«è½¬æ¢ä¸ºâ€œthis-&gt;æ•°æ®æˆå‘˜â€çš„å½¢å¼ã€‚ 1) å¦‚æœæˆå‘˜å‡½æ•°å†…éƒ¨æ²¡æœ‰è®¿é—®å¯¹è±¡çš„ä»»ä½•æ•°æ®æˆå‘˜ï¼Œé‚£ä¹ˆä¼ è¿›æ¥çš„thisæŒ‡é’ˆå®é™…æ²¡æœ‰ä»»ä½•ç”¨å¤„ï¼Œ è¿™æ ·çš„å‡½æ•°ä¸å…¨å±€å‡½æ•°å¹¶æ²¡æœ‰å¤ªå¤§åŒºåˆ«ã€‚ &amp;nbsp; 2ã€æ¡ˆä¾‹11234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class MyClass &#123;public: int data; MyClass(int data) &#123; this-&gt;data = data; &#125; void print() &#123; //cout&lt;&lt; data &lt;&lt; endl; cout &lt;&lt; &quot;hello!&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; MyClass *pMyClass; pMyClass = new MyClass(1); pMyClass-&gt;print(); pMyClass[0].print(); pMyClass[1].print(); pMyClass[10000000].print(); return 0;&#125; ç¨‹åºè¾“å‡ºå¦‚ä¸‹ï¼š ç»“æœåˆ†æï¼š 1) æ­¤å¤„æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªå¯¹è±¡ï¼Œä½†æ˜¯è®¿é—®åé¢è¶Šç•Œä¹‹åä»ç„¶å¯ä»¥è®¿é—®æˆåŠŸã€‚ 2) å¦‚æœä¸€ä¸ªæˆå‘˜å‡½æ•°æ²¡æœ‰æ“ä½œä»»ä½•ç±»çš„æ•°æ®æˆå‘˜ï¼Œå› æ­¤è¿™ä¸ªæˆå‘˜å‡½æ•°ä¸å…¨å±€å‡½æ•°ç±»å‹ï¼Œè°ƒç”¨ä¹‹åéƒ½ä¼šæ‰“å°â€œhello!â€ã€‚ &amp;nbsp; 3ã€æ¡ˆä¾‹21234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class MyClass &#123;public: int data; MyClass(int data) &#123; this-&gt;data = data; &#125; void print() &#123; cout&lt;&lt; data &lt;&lt; endl; cout &lt;&lt; &quot;hello!&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; MyClass *pMyClass; pMyClass = new MyClass(1); pMyClass-&gt;print(); pMyClass[0].print(); pMyClass[1].print(); pMyClass[10000000].print(); return 0;&#125; ç¨‹åºè¾“å‡ºå¦‚ä¸‹ï¼š ç»“æœåˆ†æï¼š 1) æ­¤å¤„æˆ‘ä»¬çš„æˆå‘˜å‡½æ•°è®¿é—®äº†ç±»çš„æ•°æ®æˆå‘˜ï¼Œé‚£ä¹ˆæ¯æ¬¡æ‰“å°æ•°æ®æ—¶éƒ½ä¼šé€šè¿‡thisæŒ‡é’ˆè°ƒç”¨ã€‚ 2) ä½†æ˜¯æ­¤å¤„æˆ‘ä»¬åªåˆ›å»ºäº†ä¸€ä¸ªå¯¹è±¡ï¼Œæ‰€ä»¥å½“è°ƒç”¨pMyClass[1]å’ŒpMyClass[10000000]è¶Šç•Œäº†ï¼Œæ‰¾ä¸åˆ°å¯¹è±¡ï¼Œä»è€ŒæŠ¥é”™ã€‚","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ubuntuæ­å»ºQt4Androidçš„å¼€å‘ç¯å¢ƒ","slug":"ubuntu/ubuntuæ­å»ºQt4Androidçš„å¼€å‘ç¯å¢ƒ","date":"2022-09-29T05:45:30.000Z","updated":"2022-10-16T03:33:57.869Z","comments":true,"path":"2022/09/29/ubuntu/ubuntuæ­å»ºQt4Androidçš„å¼€å‘ç¯å¢ƒ/","link":"","permalink":"http://example.com/2022/09/29/ubuntu/ubuntu%E6%90%AD%E5%BB%BAQt4Android%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"ä¸€ã€è½¯ä»¶ç‰ˆæœ¬é€‰æ‹©1234android-studio: android-studio-2020.3.1.26-linux.tar.gzandroid-sdk: android-sdk_r24.4.1-linux.tgzandroid-ndk: android-ndk-r19c-linux-x86_64.zipQt: 5.12.8 äºŒã€å®‰è£…è½¯ä»¶1ã€å®‰è£…jdk123456sudo apt install -y openjdk-8-jdkvi /etc/profileexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64export PATH=$PATH:$&#123;JAVA_HOME&#125;/binsource /etc/profile 2ã€å®‰è£…sdkè§£å‹å¹¶è¿è¡Œandroid-studio, å°†sdkã€toolç­‰ä¸‹è½½åˆ°ä¸€ä¸ªç©ºçš„æ–‡ä»¶å¤¹android-sdkä¸‹ è§£å‹android-sdk_r24.4.1-linux.tgzå¹¶èµ‹å€¼å…¶ç›®å½•ä¸‹çš„toolsåˆ°android-sdkä¸‹ 3ã€è§£å‹ndkè§£å‹ android-ndk-r19c-linux-x86_64.zip 4ã€è®¾ç½®äº¤å‰ç¼–è¯‘","categories":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"ubuntuå®‰è£…VNC-æ— éœ€æ˜¾ç¤ºå±","slug":"ubuntu/ubuntuå®‰è£…VNC-æ— éœ€æ˜¾ç¤ºå±","date":"2022-09-28T06:35:13.000Z","updated":"2022-10-16T03:33:52.097Z","comments":true,"path":"2022/09/28/ubuntu/ubuntuå®‰è£…VNC-æ— éœ€æ˜¾ç¤ºå±/","link":"","permalink":"http://example.com/2022/09/28/ubuntu/ubuntu%E5%AE%89%E8%A3%85VNC-%E6%97%A0%E9%9C%80%E6%98%BE%E7%A4%BA%E5%B1%8F/","excerpt":"","text":"ä¸€ã€å®‰è£…1ã€å®‰è£…VNC1234sudo apt-get install x11vnc â€“y/* generate password */sudo x11vnc -storepasswd /etc/x11vnc.pass 2ã€å¯åŠ¨VNC1sudo x11vnc -display :0 -auth /var/run/lightdm/root/:0 -forever -bg -o /var/log/x11vnc.log -rfbauth /etc/x11vnc.pass -rfbport 5901 ä¸€ã€é…ç½®æ— æ˜¾ç¤ºå™¨è®¿é—®1ã€ç”Ÿæˆé…ç½®æ–‡ä»¶1234sudo Xorg :1 â€“configure/* æ­¤æ—¶ä¼šåœ¨rootè·¯å¾„ä¸‹ç”Ÿæˆxorg.conf.newæ–‡ä»¶ */cp /root/xorg.conf.new /usr/share/X11/xorg.conf.d/xorg.conf 2ã€å®‰è£…è™šæ‹Ÿæ˜¾å¡é©±åŠ¨1sudo apt install xserver-xorg-video-dummy 3ã€æ·»åŠ è™šæ‹Ÿæ˜¾å¡é…ç½®1234567891011121314151617181920212223242526272829sudo vi /usr/share/X11/xorg.conf.d/xorg.conf/* åœ¨æ–‡ä»¶æœ€åæ·»åŠ ä»¥ä¸‹å†…å®¹ */Section &quot;Monitor&quot; Identifier &quot;Monitor1&quot; HorizSync 1.0 - 2000.0 VertRefresh 1.0 - 200.0 # Add 16:9 modes, others are automatically detected. Modeline &quot;1280x720&quot; 74.48 1280 1336 1472 1664 720 721 724 746 Modeline &quot;1920x1080&quot; 172.80 1920 2040 2248 2576 1080 1081 1084 1118EndSectionSection &quot;Device&quot; Identifier &quot;Card1&quot; Driver &quot;dummy&quot; VideoRam 256000EndSection Section &quot;Screen&quot; DefaultDepth 24 Identifier &quot;Screen1&quot; Device &quot;Card1&quot; Monitor &quot;Monitor1&quot; SubSection &quot;Display&quot; Depth 24 Modes &quot;1920x1080&quot; EndSubSectionEndSection 4ã€è™šæ‹Ÿä¸çœŸå®æ˜¾ç¤ºå™¨åŒæ—¶å·¥ä½œé…ç½®ä¿®æ”¹æ­¥éª¤3ä¸­çš„é…ç½®æ–‡ä»¶æœ€ä¸Šé¢çš„ServerLayout: 12345Section &quot;ServerLayout&quot; Identifier &quot;X.org Configured&quot; Screen 0 &quot;Screen0&quot; 0 0 Screen 1 &quot;Screen1&quot; 0 0EndSection","categories":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"æ ‘è“æ´¾3B+xenomai+igh","slug":"servoCtrl/æ ‘è“æ´¾3B-xenomai-igh","date":"2022-09-28T05:42:02.000Z","updated":"2022-10-16T03:34:20.236Z","comments":true,"path":"2022/09/28/servoCtrl/æ ‘è“æ´¾3B-xenomai-igh/","link":"","permalink":"http://example.com/2022/09/28/servoCtrl/%E6%A0%91%E8%8E%93%E6%B4%BE3B-xenomai-igh/","excerpt":"","text":"ä¸€ã€æºç åŒ…å‡†å¤‡1ã€å®‰è£…ä¾èµ–è½¯ä»¶1sudo apt install git bc bison flex libssl-dev make 2ã€æºç ç‰ˆæœ¬12345git clone https://github.com/raspberrypi/linux.gitgit checkout rpi-4.1.ygit clone http://git.xenomai.org/xenomai-3.git/git checkout v3.0.2 äºŒã€å®æ—¶å†…æ ¸ç§»æ¤1ã€æ‰“å®æ—¶è¡¥ä¸12345cd xenomai-3scripts/prepare-kernel.sh --linux=../linux/ --arch=arm --ipipe=./kernel/cobalt/arch/arm/patches/ipipe-core-4.1.18-arm-4.patchcd ../linuxcat ../patch-xenomai-3-on-bcm-2709.patch | patch -p1 2ã€é…ç½®å†…æ ¸123456789101112131415161718make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfigmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig/* config linux kernel with the following options */CPU Power Management ---&gt;CPU Frequency scaling ---&gt; [ ] CPU Frequency scalingCPU idle ---&gt; [ ] CPU idle PM supportKernel Features ---&gt; [ ] Contiguous Memory Allocator [ ] Allow for memory compactionKernel Hacking ---&gt; [ ] KGDB: kernel debuggerBoot options ---&gt; Kernel command line type ---&gt; [X] Extend bootloader kernel arguments 3ã€ç¼–è¯‘å†…æ ¸åŠæ¨¡å—1234make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs -j20mkdir modulesmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- INSTALL_MOD_PATH=modules modules_install 4ã€å®‰è£…åˆ°ç³»ç»Ÿ123456cp arch/arm/boot/zImage /media/$&#123;USER&#125;/bootcp arch/arm/boot/dts/bcm2710-rpi-3-b.dtb /media/$&#123;USER&#125;/bootrm -rf /media/$&#123;USER&#125;/boot/overlays/*cp arch/arm/boot/dts/overlays/*.dtb* /media/$&#123;USER&#125;/boot/overlays/sudo cp -r linux/dist/lib/modules/* /media/$&#123;USER&#125;/$&#123;ROOTFS&#125;/lib/modules 5ã€ä¿®æ”¹ç³»ç»Ÿå¯åŠ¨é¡¹12kernel=$&#123;zImage name&#125;device_tree=bcm2710-rpi-3-b.dtb ä¸‰ã€å®‰è£…xenomai1ã€é…ç½®123cd xenomai-3./scripts/bootstrap --with-core=cobalt â€“enable-debug=partial./configure CFLAGS=&quot;-march=armv7-a -mtune=cortex-a8 -mfloat-abi=hard -mfpu=neon -ffast-math&quot; --host=arm-linux-gnueabihf --target=arm-linux-gnueabihf --enable-smp 2ã€ç¼–è¯‘12mkdir targetmake DESTDIR=$&#123;PWD&#125;/target install 3ã€å®‰è£…åˆ°ç³»ç»Ÿ1sudo cp -a target/* /media/$&#123;USER&#125;/$&#123;ROOTFS&#125;/ ä¸‰ã€å®‰è£…IGH1ã€æºç åŒ…123git clone https://gitlab.com/etherlab.org/ethercat.gitcd ethercatgit checkout stable-1.5 2ã€é…ç½®123mkdir etherlab./bootstrap./configure --prefix=$&#123;PWD&#125;/etherlab --with-linux-dir=$&#123;PWD&#125;/../linux --enable-8139too=no --enable-generic=yes CC=arm-linux-gnueabihf-gcc --host=arm-linux-gnueabihf 3ã€ç¼–è¯‘12make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- all modules -j20make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- install -j20 4ã€å¯èƒ½å‡ºç°çš„é—®é¢˜åŠè§£å†³123issue: /usr/bin/ld: error: ethercat use VFP register arguments, ../master/soe_errors.o does notsolve: touch ~/ethercat/master/soe_errors.c 5ã€å®‰è£…åˆ°ç³»ç»Ÿ123456789101112131415161718mkdir -p $&#123;PWD&#125;/etherlab/modulescp devices/ec_generic.ko etherlab/modules/cp master/ec_master.ko etherlab/modules/sudo cp -r etherlab/ /opt sudo ln -fs /opt/etherlab/etc/init.d/ethercat /etc/init.d/sudo ln -fs /opt/etherlab/bin/ethercat /usr/local/bin/sudo mkdir /etc/sysconfigsudo ln -fs /opt/etherlab/etc/sysconfig/ethercat /etc/sysconfig/sudo susudo echo KERNEL==\\&quot;EtherCAT[0-9]*\\&quot;, MODE=\\&quot;0664\\&quot; &gt; /etc/udev/rules.d/99-EtherCAT.rulesexitsudo cp /opt/etherlab/modules/ec_master.ko /lib/modules/4.14.91-rt49-v7+sudo depmodvi ~/.bashrcPATH=$PATH:/opt/etherlab/binsource ~/.bashrc 6ã€é…ç½®ç½‘å¡123vi /etc/sysconfig/ethercatMASTER0_DEVICE=â€b8:27:eb:7d:26:a2â€ //å¡«å†™å®é™…çš„MACDEVICE_MODULES=â€genericâ€ 7ã€å¯åŠ¨igh1sudo /etc/init.d/ethercat start 6ã€æµ‹è¯•ç»è¿‡æµ‹è¯•å‘ç°igh1.5.2å¯ä»¥åœ¨pi3ä¸Šè¿è¡Œï¼Œä½†æ˜¯æ•ˆæœå¾ˆå·®ï¼Œä»£ç è¿è¡Œåä¸èƒ½è¯†åˆ«å¯¹åº”çš„pdoï¼ŒåŸå› å¾…æŸ¥æ‰¾","categories":[{"name":"ä¼ºæœæ§åˆ¶","slug":"ä¼ºæœæ§åˆ¶","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"ä¼ºæœæ§åˆ¶","slug":"ä¼ºæœæ§åˆ¶","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]},{"title":"x86å·¥æ§æœºå®‰è£…igh","slug":"servoCtrl/x86å·¥æ§æœºå®‰è£…igh","date":"2022-09-27T13:51:31.000Z","updated":"2022-12-02T06:50:08.493Z","comments":true,"path":"2022/09/27/servoCtrl/x86å·¥æ§æœºå®‰è£…igh/","link":"","permalink":"http://example.com/2022/09/27/servoCtrl/x86%E5%B7%A5%E6%8E%A7%E6%9C%BA%E5%AE%89%E8%A3%85igh/","excerpt":"","text":"ä¸€ã€ç½‘å¡é©±åŠ¨ç±»å‹1ã€é€šç”¨å‹ä¼˜ç‚¹: genericé€šç”¨å‹çš„ç½‘å¡é©±åŠ¨å¯¹ç‰©ç†ç½‘å¡æ²¡æœ‰å¤ªå¤šè¦æ±‚ï¼Œåªéœ€è¦Linuxç³»ç»Ÿæ”¯æŒå…¶é©±åŠ¨ï¼Œ å°±èƒ½åœ¨IGHçš„é…ç½®ä¸­å°†å…¶é€‰ä½œç½‘å¡é©±åŠ¨ã€‚ ç¼ºç‚¹: å®æ—¶æ€§è¾ƒå·®ï¼Œå°¤å…¶æ˜¯è¿›è¡ŒdcåŒæ­¥æ§åˆ¶æ—¶è¡¨ç°æ›´ä¸ºæ˜æ˜¾ã€‚ 2ã€æœ¬åœ°å‹ä¼˜ç‚¹: nativeæœ¬åœ°å‹ç½‘å¡é©±åŠ¨æ˜¯å®˜æ–¹ä¸“é—¨é€‚é…çš„å‡ æ¬¾Intelç½‘å¡ï¼Œå®æ—¶æ€§æ–¹é¢æœ‰è‰¯å¥½çš„ä¿è¯ ç¼ºç‚¹: åªæ”¯æŒå‡ æ¬¾ç½‘å¡ äºŒã€å®‰è£…é€šç”¨å‹ç½‘å¡é©±åŠ¨1ã€ä¸‹è½½æºç åŒ…ä½¿ç”¨è‡ªå·±gitlabä»“åº“é‡Œè¾¹çš„ä»£ç  2ã€é…ç½®123456cd path/to/ethercatMaster./bootstrapmkdir etherlab./configure --prefix=/home/huger/rtubuntu18/ethercat/etherlab --with-linux-dir=/home/huger/rtubuntu18/linux-4.9.38 --enable-generic=yes --enable-8139too=yes --enable-e1000=yes --enable-e1000e=yes --enable-r8169=yes --enable-rtdm=yes --enable-cycles=yes --enable-hrtimer=yes --with-xenomai-dir=/usr/xenomai configureä¸­çš„è·¯å¾„éœ€è¦æ ¹æ®æœ¬åœ°å®é™…è·¯å¾„ä¿®æ”¹ 3ã€ç¼–è¯‘åŠå®‰è£…1234make -j16make modules -j16make installsudo make modules_install 4ã€åˆ›å»ºè½¯è¿æ¥12345678910111213mkdir -p ~/ethercat/etherlab/modulescp devices/ec_generic.ko etherlab/modules/cp master/ec_master.ko etherlab/modules/sudo cp -r etherlab/ /opt sudo ln -fs /opt/etherlab/etc/init.d/ethercat /etc/init.d/sudo ln -fs /opt/etherlab/bin/ethercat /usr/local/bin/sudo mkdir /etc/sysconfigsudo ln -fs /opt/etherlab/etc/sysconfig/ethercat /etc/sysconfig/sudo suecho KERNEL==\\&quot;EtherCAT[0-9]*\\&quot;, MODE=\\&quot;0664\\&quot; &gt; /etc/udev/rules.d/99-EtherCAT.rulesexitsudo cp /opt/etherlab/modules/ec_master.ko /lib/modules/4.9.51-xenomai3.1+sudo depmod æ­¤æ­¥éª¤ä¸­çš„è·¯å¾„éœ€è¦æ ¹æ®æœ¬åœ°å®é™…è·¯å¾„ä¿®æ”¹ 5ã€é…ç½®ç½‘å¡ifconfig æ‰¾å‡ºç½‘å¡çš„MACåœ°å€ 123sudo vi /etc/sysconfig/ethercatMASTER0_DEVICE=â€b8:27:eb:7d:26:a2â€ //å¡«å†™å®é™…MACDEVICE_MODULES=â€genericâ€ 6ã€å¢åŠ ç³»ç»Ÿè·¯å¾„åœ¨~/.bashrc æœ«å°¾å¢åŠ ä¸‹é¢å†…å®¹å¹¶source 12PATH=$PATH:/opt/etherlab/binsource ~/.bashrc 7ã€æ·»åŠ åº“æ–‡ä»¶ä¾›ç¨‹åºé“¾æ¥å¦‚æœæ²¡æœ‰å°†xenomaiçš„åº“æ·»åŠ åˆ°ç³»ç»Ÿè·¯å¾„ä¸­ï¼Œç¨‹åºåœ¨é“¾æ¥çš„æ—¶å€™å°±ä¼šå‡ºç° error: while loading shared libraries... è§£å†³ï¼š 123sudo vi /etc/ld.so.conf/usr/xenomai/lib //æ–‡ä»¶ä¸­å¢åŠ è¿™ä¸€è¡Œsudo ldconfig -v //ä½¿å…¶ç”Ÿæ•ˆ ä¸‰ã€å®‰è£…nativeå‹ç½‘å¡é©±åŠ¨1ã€å†…æ ¸åŠighæºç ç‰ˆæœ¬çš„ä¸‹è½½åœ°å€å®‰è£…nativeå‹ç½‘å¡é©±åŠ¨éœ€è¦å†…æ ¸æ”¯æŒæ­¤ç½‘å¡é©±åŠ¨ï¼Œ æœ€å¥½çš„å†…æ ¸æ— ç–‘æ˜¯ighå®˜æ–¹ç»è¿‡ä¼˜åŒ–åçš„ï¼Œä¸‹è½½åœ°å€å¦‚ä¸‹ å†…æ ¸ï¼šhttps://source.denx.de/Xenomai/linux-dovetail branché€‰æ‹© v5.10.y-dovetail ighæºç ï¼š https://gitlab.com/etherlab.org/ethercat/-/tree/e1000e-5.10 branché€‰æ‹© e1000e-5.10 xenomaié€‰æ‹©3.2.1ç‰ˆæœ¬ 2ã€Linuxå†…æ ¸é…ç½®ç”±äºä½¿ç”¨å®˜æ–¹æä¾›çš„å†…æ ¸ï¼Œæ‰€ä»¥æ‰“è¡¥ä¸ä¸å¦ä¸€ç¯‡æ­å»ºå®æ—¶ç³»ç»Ÿåšå®¢ä¸­çš„æ–¹æ³•ç•¥æœ‰ä¸åŒ 12cd path/to/kernel../xenomai-v3.2.1/scripts/prepare-kernel.sh --arch=x86_64 Linux5.10çš„å†…æ ¸é…ç½®å¯ä»¥å‚è€ƒä¸‹é¢çš„é™„å½•ï¼Œç¼–è¯‘åŠå®‰è£…è¿‡ç¨‹ä¸4.xå†…æ ¸ç§»æ¤ 3ã€nativeå‹ç½‘å¡é…ç½®12345cd path/to/ighsourceTree./scrip/bootstrapmkdir etherlab./configure --prefix=/home/huger/rtlinux/ethercat-e1000e-5.10/etherlab -enable-8139too=no -enable-e1000e=yes 4ã€ç¼–è¯‘åŠå®‰è£…123make all modules -j16sudo make modules_install install -j16sudo depmod 5ã€åˆ›å»ºè½¯é“¾æ¥ä¸é€šç”¨å‹ç›¸åŒ 6ã€é…ç½®ç½‘å¡sudo vi /etc/sysconfig/ethercat MASTER0_DEVICE=â€b8:27:eb:7d:26:a2â€ //å¡«å†™å®é™…MAC DEVICE_MODULES=â€e1000eâ€ ä¸‰ã€Linux5.10å†…æ ¸é…ç½®é™„å½•1234567891011121314151617181920212223242526272829303132333435363738394041424344Recommended options:* General setup --&gt; Local version - append to kernel release: -xenomai-3.0.5 --&gt; Timers subsystem --&gt; High Resolution Timer Support (Enable)* Xenomai/cobalt --&gt; Sizes and static limits --&gt; Number of registry slots (512 --&gt; 4096) --&gt; Size of system heap (Kb) (512 --&gt; 4096) --&gt; Size of private heap (Kb) (64 --&gt; 256) --&gt; Size of shared heap (Kb) (64 --&gt; 256) --&gt; Maximum number of POSIX timers per process (128 --&gt; 512) --&gt; Drivers --&gt; RTnet --&gt; RTnet, TCP/IP socket interface (Enable) --&gt; Drivers --&gt; New intel(R) PRO/1000 PCIe (Enable) --&gt; Realtek 8169 (Enable) --&gt; Loopback (Enable) --&gt; Add-Ons --&gt; Real-Time Capturing Support (Enable)* Power management and ACPI options --&gt; CPU Frequency scaling --&gt; CPU Frequency scaling (Disable) --&gt; ACPI (Advanced Configuration and Power Interface) Support --&gt; Processor (Disable) --&gt; CPU Idle --&gt; CPU idle PM support (Disable)* Pocessor type and features --&gt; Enable maximum number of SMP processors and NUMA nodes (Disable) // Ref : http://xenomai.org/pipermail/xenomai/2017-September/037718.html --&gt; Processor family --&gt; Core 2/newer Xeon (if &quot;cat /proc/cpuinfo | grep family&quot; returns 6, set as Generic otherwise) // Xenomai will issue a warning about CONFIG_MIGRATION, disable those in this order --&gt; Transparent Hugepage Support (Disable) --&gt; Allow for memory compaction (Disable) --&gt; Contiguous Memory Allocation (Disable) --&gt; Allow for memory compaction --&gt; Page Migration (Disable)* Device Drivers --&gt; Staging drivers --&gt; Unisys SPAR driver support --&gt; Unisys visorbus driver (Disable) â€‹","categories":[{"name":"ä¼ºæœæ§åˆ¶","slug":"ä¼ºæœæ§åˆ¶","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"ä¼ºæœæ§åˆ¶","slug":"ä¼ºæœæ§åˆ¶","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]},{"title":"x86å·¥æ§æœºæ­å»ºubuntu18+xenomaiå®æ—¶ç³»ç»Ÿ","slug":"servoCtrl/x86å·¥æ§æœºæ­å»ºubuntu18-xenomaiå®æ—¶ç³»ç»Ÿ","date":"2022-09-27T08:37:14.000Z","updated":"2022-10-16T03:34:15.764Z","comments":true,"path":"2022/09/27/servoCtrl/x86å·¥æ§æœºæ­å»ºubuntu18-xenomaiå®æ—¶ç³»ç»Ÿ/","link":"","permalink":"http://example.com/2022/09/27/servoCtrl/x86%E5%B7%A5%E6%8E%A7%E6%9C%BA%E6%90%AD%E5%BB%BAubuntu18-xenomai%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"ä¸€ã€å®‰è£…ç³»ç»ŸåŠè½¯ä»¶ä¾èµ–1ã€ç³»ç»Ÿé€‰æ‹©é€‰æ‹©å®‰è£… ubuntu18.04.6 LTS 2ã€è½¯ä»¶ä¾èµ–1sudo apt install libc6-dev libncurses5-dev libssl-dev build-essential bison flex lib32stdc++6 lib32z1 autoconf automake libtool pkg-config libelf-dev 3ã€è½¯ä»¶ç‰ˆæœ¬åŠä¸‹è½½kernel: 4.9.38: https://mirrors.edge.kernel.org/pub/linux/kernel/ xenomai3.1åŠè¡¥ä¸: https://xenomai.org/downloads/ äºŒã€é…ç½®å†…æ ¸1ã€æ‰“è¡¥ä¸123cd linux-4.9.38../xenomai-3.1/scripts/prepare-kernel.sh --arch=x86_64 --ipipe=ipipe-core-4.9.38-x86-3.patch 2ã€å®‰è£…å†…æ ¸ç®¡ç†åŒ…1sudo apt install kernel-package åœ¨å¼¹å‡ºçš„ç•Œé¢ä¸­é€‰æ‹© â€œkeep the local versionâ€¦â€¦.â€ 3ã€é…ç½®kernel1make menuconfig å®‰è£…é™„å½•ä¸­çš„é€‰é¡¹é…ç½®å†…æ ¸ï¼Œå»é™¤xenomaiç›¸å…³çš„è­¦å‘Š 4ã€å»é™¤ç¼–è¯‘é”™è¯¯1vi .config æ‰¾åˆ°SYSTEM_TRUSTED_KEYSå°†å…¶èµ‹å€¼ä¸ºç©ºï¼Œä½¿ç”¨#æ³¨é‡Šæ‰CONFIG_DEBUG_INFO_BTF 12SYSTEM_TRUSTED_KEYS=&quot;&quot;#CONFIG_DEBUG_INFO_BTF 5ã€ç¼–è¯‘å†…æ ¸1CONCURRENCY_LEVEL=$(nproc) make-kpkg --rootcmd fakeroot --initrd kernel_image kernel_headers 6ã€å‚è€ƒæ–‡æ¡£https://blog.csdn.net/qq_28882933/article/details/123626659?spm=1001.2014.3001.5502 ä¸‰ã€å®‰è£…æ–°å†…æ ¸å¹¶ä¿®æ”¹grub1ã€å®‰è£…å†…æ ¸ç¼–è¯‘å®Œæˆåä¼šåœ¨ä¸Šä¸€å±‚ç›®å½•ç”Ÿæˆå¯¹åº”çš„debå®‰è£…åŒ… 12cd ..sudo dpkg -i *.deb 2ã€å¢åŠ érootç”¨æˆ·123sudo addgroup xenomai --gid 1234sudo addgroup root xenomaisudo usermod -a -G xenomai $USER 3ã€æŸ¥çœ‹å½“å‰ç³»ç»Ÿä¸‹çš„æ‰€æœ‰å¯ç”¨å†…æ ¸1cat /boot/grub/grub.cfg | grep menuentry è®°ä½åˆšæ‰å®‰è£…çš„å®æ—¶å†…æ ¸ä¸‹æ ‡å· 4ã€ä¿®æ”¹grubå¯åŠ¨é¡¹1sudo vi /etc/default/grub å€’æ•°ç¬¬äºŒä¸ªé€‰é¡¹ï¼Œè¦åœ¨åé¢åŠ å‘½ä»¤è¡Œâ€œxenomai.allowed_group=1234â€å³ä¸Šæ­¥éª¤æ–°å¢çš„ç»„ï¼Œå…·ä½“ä¿®æ”¹å¦‚ä¸‹: 5ã€æ›´æ–°grub12sudo update-grubsudo reboot å››ã€å®‰è£…xenomai1ã€ç¼–è¯‘æºæ–‡ä»¶1234567cd xenomai-3.1./configure --with-pic --with-core=cobalt --enable-smp --disable-tls --enable-dlopen-libs --disable-clock-monotonic-rawmake -j`nproc`sudo make install 2ã€é…ç½®ç³»ç»Ÿè·¯å¾„12345678910111213echo &#x27;### Xenomaiexport XENOMAI_ROOT_DIR=/usr/xenomaiexport XENOMAI_PATH=/usr/xenomaiexport PATH=$PATH:$XENOMAI_PATH/bin:$XENOMAI_PATH/sbinexport PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$XENOMAI_PATH/lib/pkgconfigexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$XENOMAI_PATH/libexport OROCOS_TARGET=xenomai&#x27; &gt;&gt; ~/.xenomai_rcecho &#x27;source ~/.xenomai_rc&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc 3ã€å®æ—¶æ€§æµ‹è¯•123sudo chmod -R 777 /dev/rtdm/memdev-privatesudo chmod -R 777 /dev/rtdm/memdev-sharedxeno latency 4ã€ä¿®æ”¹ lat bestä¸ºè´Ÿçš„æ–¹æ³•123sudo suecho 0 &gt; /proc/xenomai/latencyxeno latency è¿è¡Œä¸€å°æ®µæ—¶é—´å¾…å…¶ç¨³å®šåæŸ¥çœ‹æ­¤æ—¶lat best çš„æ•°å€¼, å°†æ­¤æ•°å€¼ä¹˜1000 åé‡æ–°echo 1echo value*1000 &gt; /proc/xenomai/latency äº”ã€æ·»åŠ åº“æ–‡ä»¶ä¾›ç¨‹åºé“¾æ¥å¦‚æœæ²¡æœ‰å°†xenomaiçš„åº“æ·»åŠ åˆ°ç³»ç»Ÿè·¯å¾„ä¸­ï¼Œç¨‹åºåœ¨é“¾æ¥çš„æ—¶å€™å°±ä¼šå‡ºç° error: while loading shared libraries... è§£å†³ï¼š 123sudo vi /etc/ld.so.conf/usr/xenomai/lib //æ–‡ä»¶ä¸­å¢åŠ è¿™ä¸€è¡Œsudo ldconfig -v //ä½¿å…¶ç”Ÿæ•ˆ å…­ã€å†…æ ¸é…ç½®é™„å½•1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 #è¿›å…¥menuconfigç•Œé¢ï¼Œä¼šçœ‹å½±å“xenomaiå®æ—¶æ€§çš„è­¦å‘Šä¿¡æ¯ï¼š#*** WARNING! Page migration (CONFIG_MIGRATION) may increase ***#*** latency. ***#*** WARNING! At least one of APM, CPU frequency scaling, ACPI â€˜processorâ€˜ ***#*** or CPU idle features is enabled. Any of these options may ***#*** cause troubles with Xenomai. You should disable them. ***#å…·ä½“é…ç½®å¦‚ä¸‹æ‰€ç¤ºï¼š * General setup --&gt; Local version - append to kernel release: -xenomai-3.1 --&gt; Timers subsystem --&gt; High Resolution Timer Support (Enable) * Xenomai/cobalt --&gt; Sizes and static limits --&gt; Number of registry slots (512 --&gt; 4096) --&gt; Size of system heap (Kb) (512 --&gt; 4096) --&gt; Size of private heap (Kb) (64 --&gt; 256) --&gt; Size of shared heap (Kb) (64 --&gt; 256) --&gt; Maximum number of POSIX timers per process (128 --&gt; 512) --&gt; Drivers --&gt; RTnet --&gt; RTnet, TCP/IP socket interface (Enable) --&gt; Drivers --&gt; New intel(R) PRO/1000 PCIe (Enable) --&gt; Realtek 8169 (Enable) --&gt; Loopback (Enable) --&gt; Add-Ons --&gt; Real-Time Capturing Support (Enable) * Power management and ACPI options --&gt; CPU Frequency scaling --&gt; CPU Frequency scaling (Disable) --&gt; ACPI (Advanced Configuration and Power Interface) Support --&gt; Processor (Disable) --&gt; CPU Idle --&gt; CPU idle PM support (Disable) * Pocessor type and features --&gt; Enable maximum number of SMP processors and NUMA nodes (Disable) // Ref : http://xenomai.org/pipermail/xenomai/2017-September/037718.html --&gt; Processor family --&gt; Core 2/newer Xeon (if &quot;cat /proc/cpuinfo | grep family&quot; returns 6, set as Generic otherwise) // Xenomai will issue a warning about CONFIG_MIGRATION, disable those in this orde --&gt; Transparent Hugepage Support (Disable) --&gt; Allow for memory compaction (Disable) --&gt; Contiguous Memory Allocation (Disable) --&gt; Allow for memory compaction --&gt; Page Migration (Disable) * Device Drivers --&gt; Staging drivers --&gt; Unisys SPAR driver support --&gt; Unisys visorbus driver (Disable)","categories":[{"name":"ä¼ºæœæ§åˆ¶","slug":"ä¼ºæœæ§åˆ¶","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"ä¼ºæœæ§åˆ¶","slug":"ä¼ºæœæ§åˆ¶","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]},{"title":"ubuntuå®‰è£…hexoè¸©å‘","slug":"ubuntu/ubuntuå®‰è£…hexoè¸©å‘","date":"2022-09-27T07:04:27.000Z","updated":"2022-10-16T03:33:43.945Z","comments":true,"path":"2022/09/27/ubuntu/ubuntuå®‰è£…hexoè¸©å‘/","link":"","permalink":"http://example.com/2022/09/27/ubuntu/ubuntu%E5%AE%89%E8%A3%85hexo%E8%B8%A9%E5%9D%91/","excerpt":"","text":"è½¯ä»¶é—®é¢˜å¯¼è‡´æ— æ³•å®‰è£…HEXOç°è±¡åŠåŸå› å¦‚æœé»˜è®¤ä½¿ç”¨ 1sudo apt install nodejs npm ç³»ç»Ÿä¼šé»˜è®¤å®‰è£…ä½ç‰ˆæœ¬çš„è½¯ä»¶ï¼Œç„¶è€Œåœ¨æ‰§è¡Œ 1npm install -g hexo ä¼šæç¤ºç‰ˆæœ¬å¤ªä½ è§£å†³123sudo apt install curlcurl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -sudo apt-get install -y nodejs è¿™å°±å®‰è£…äº†é«˜ç‰ˆæœ¬çš„è½¯ä»¶ï¼Œå¯ä»¥ç›´æ¥å®‰è£…hexo. éƒ¨ç½²åˆ°githubä¸Šåç½‘é¡µä¹±ç è§£å†³æ‰“å¼€ç½‘å€ http://ipaddress.com/ å³ä¸Šè§’è¿›è¡ŒæŸ¥æ‰¾ assets-cdn.github.comï¼Œå¾—åˆ°ç›¸åº”çš„IP ç„¶ååœ¨ /etc/hostsä¸­å¢åŠ  185.199.109.153 assets-cdn.github.com ä»¥å®ipä¸ºå‡†ï¼Œå¦‚æœä¸€ä¸ªipæ— æ•ˆï¼Œé‚£ä¹ˆå°±å¤šè¯•å…¶ä»–ip","categories":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]}],"categories":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"},{"name":"ä¼ºæœæ§åˆ¶","slug":"ä¼ºæœæ§åˆ¶","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"},{"name":"STM32","slug":"STM32","permalink":"http://example.com/categories/STM32/"},{"name":"Linuxé©±åŠ¨","slug":"Linuxé©±åŠ¨","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"},{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"ubuntuç³»ç»Ÿ","slug":"ubuntuç³»ç»Ÿ","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"},{"name":"ä¼ºæœæ§åˆ¶","slug":"ä¼ºæœæ§åˆ¶","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"},{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"},{"name":"Linuxé©±åŠ¨[å®è·µ]","slug":"Linuxé©±åŠ¨-å®è·µ","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"},{"name":"Linuxé©±åŠ¨[ç†è®º]","slug":"Linuxé©±åŠ¨-ç†è®º","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"},{"name":"æ¨¡å¼è®¾è®¡","slug":"æ¨¡å¼è®¾è®¡","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]}