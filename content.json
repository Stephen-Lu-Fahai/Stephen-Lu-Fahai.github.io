{"meta":{"title":"StephenLu`s Blog","subtitle":"Embedded Software Engineering","description":"","author":"Stephen Lu","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-09-27T07:44:47.000Z","updated":"2022-09-27T07:45:37.738Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-27T07:44:42.000Z","updated":"2022-09-27T07:45:26.354Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux驱动[实践]:15--使用内核现有驱动","slug":"linuxDrive/Linux驱动-实践-15-使用内核现有驱动","date":"2022-11-01T07:18:24.000Z","updated":"2022-11-01T07:21:32.548Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-15-使用内核现有驱动/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-15-%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E7%8E%B0%E6%9C%89%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:14--PDD与设备树","slug":"linuxDrive/Linux驱动-实践-14-PDD与设备树","date":"2022-11-01T07:18:05.000Z","updated":"2022-11-04T00:57:39.513Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-14-PDD与设备树/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-14-PDD%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:13--USB 驱动开发","slug":"linuxDrive/Linux驱动-实践-13-USB-驱动开发","date":"2022-11-01T07:17:31.000Z","updated":"2022-11-01T07:21:22.456Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-13-USB-驱动开发/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-13-USB-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:12--USB HID驱动开发","slug":"linuxDrive/Linux驱动-实践-12-USB-HID驱动开发","date":"2022-11-01T07:17:04.000Z","updated":"2022-11-01T07:21:19.544Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-12-USB-HID驱动开发/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-12-USB-HID%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:11--framebuff驱动学习","slug":"linuxDrive/Linux驱动-实践-11-framebuff驱动学习","date":"2022-11-01T07:16:42.000Z","updated":"2022-11-01T07:21:17.064Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-11-framebuff驱动学习/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-11-framebuff%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:10--SPI驱动","slug":"linuxDrive/Linux驱动-实践-10-SPI驱动","date":"2022-11-01T07:16:20.000Z","updated":"2022-11-01T07:21:14.424Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-10-SPI驱动/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-10-SPI%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:09--输入子系统","slug":"linuxDrive/Linux驱动-实践-09-输入子系统","date":"2022-11-01T07:16:04.000Z","updated":"2022-11-01T07:21:11.372Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-09-输入子系统/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-09-%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:08--I2C设备驱动","slug":"linuxDrive/Linux驱动-实践-08-I2C设备驱动","date":"2022-11-01T07:15:44.000Z","updated":"2022-11-01T07:21:08.396Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-08-I2C设备驱动/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-08-I2C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:07--树莓派设备IO访问","slug":"linuxDrive/Linux驱动-实践-07-树莓派设备IO访问","date":"2022-11-01T07:15:26.000Z","updated":"2022-11-03T01:07:33.542Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-07-树莓派设备IO访问/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-07-%E6%A0%91%E8%8E%93%E6%B4%BE%E8%AE%BE%E5%A4%87IO%E8%AE%BF%E9%97%AE/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:06--树莓派GPIO驱动SR04超声模块","slug":"linuxDrive/Linux驱动-实践-06-树莓派GPIO驱动SR04超声模块","date":"2022-11-01T07:15:07.000Z","updated":"2022-11-01T07:20:59.032Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-06-树莓派GPIO驱动SR04超声模块/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-06-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E9%A9%B1%E5%8A%A8SR04%E8%B6%85%E5%A3%B0%E6%A8%A1%E5%9D%97/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:05--树莓派GPIO驱动红外模块","slug":"linuxDrive/Linux驱动-实践-05-树莓派GPIO驱动红外模块","date":"2022-11-01T07:14:48.000Z","updated":"2022-11-03T09:01:25.182Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-05-树莓派GPIO驱动红外模块/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-05-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E9%A9%B1%E5%8A%A8%E7%BA%A2%E5%A4%96%E6%A8%A1%E5%9D%97/","excerpt":"","text":"一、NEC协议1、编码说明 2、编码小结1) 协议帧头总是以9ms的高电平和4.5ms的低电平为一个脉冲周期; 2) 协议内容的脉冲周期，‘-___’表示1，‘-_’表示0，且电平信号以560us为单位； 3) 9ms高电平和2.25ms的低电平表示重复码，即长按按键时触发; 4) 帧间间隔为110ms. 二、驱动实现1、流程1) 申请并注册GPIO18的中断，务必是双边沿触发; 2) 申请一个定时器用于超时断帧处理; 3) 每次中断触发，都记录上升或者下降沿的状态及时长; 4) 每当经过一个完整脉冲后，通过占空比判断数据类型; 5) 每当记录了32个数据(一帧)后，处理协议指令; 6) 我是直接把地址和指令推给用户层处理. 2、驱动代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/miscdevice.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/timer.h&gt;#include &lt;linux/wait.h&gt;static struct &#123; int gpio; int irq; wait_queue_head_t rwait; struct timer_list timer; u32 pulse; // 脉冲上升沿持续时长 u32 space; // 脉冲下降沿持续时长 size_t count; // 脉冲个数 u32 data; // 脉冲解码后的值&#125; ir;#define is_head(p, s) (p &gt; 8900 &amp;&amp; p &lt; 9100 &amp;&amp; s &gt; 4400 &amp;&amp; s &lt; 4600)#define is_repeat(p, s) (p &gt; 8900 &amp;&amp; p &lt; 9100 &amp;&amp; s &gt; 2150 &amp;&amp; s &lt; 2350)#define is_bfalse(p, s) (p &gt; 500 &amp;&amp; p &lt; 650 &amp;&amp; s &gt; 500 &amp;&amp; s &lt; 650)#define is_btrue(p, s) (p &gt; 500 &amp;&amp; p &lt; 650 &amp;&amp; s &gt; 1500 &amp;&amp; s &lt; 1750)// 红外接收函数(即GPIO18的双边沿中断处理函数)// 记录GPIO每次中断是“上升还是下降”，以及持续的时长static irqreturn_t ir_rx(int irq, void* dev) &#123; static ktime_t last = 0; u32 duration = (u32)ktime_to_us(ktime_get() - last); // ⚠️注意：1838红外头高低电平逻辑取反 if (!gpio_get_value(ir.gpio)) &#123; ir.space = duration; &#125; else &#123; // 切换下降沿时，脉冲只有高电平部分，所以不做处理 ir.pulse = duration; goto irq_out; &#125; if (is_head(ir.pulse, ir.space)) &#123; ir.count = ir.data = 0; &#125; else if (is_repeat(ir.pulse, ir.space)) &#123; ir.count = 32; &#125; else if (is_btrue(ir.pulse, ir.space)) &#123; ir.data |= 1 &lt;&lt; ir.count++; &#125; else if (is_bfalse(ir.pulse, ir.space)) &#123; ir.data |= 0 &lt;&lt; ir.count++; &#125; else &#123; goto irq_out; &#125; if (ir.count &gt;= 32) &#123; wake_up(&amp;ir.rwait); &#125;irq_out: mod_timer(&amp;ir.timer, jiffies + (HZ / 10)); last = ktime_get(); return IRQ_HANDLED;&#125;// 定时清除红外协议帧的相关信息，便于接收下一帧static void clear_flag(struct timer_list *timer) &#123; ir.pulse = 0; ir.space = 0; ir.count = 0; ir.data = 0;&#125;static ssize_t ir_read(struct file *filp, char __user *buf, size_t len, loff_t *off) &#123; int rc = 0; if ((filp-&gt;f_flags &amp; O_NONBLOCK) &amp;&amp; ir.count &lt; 32) &#123; return -EAGAIN; &#125; else &#123; DECLARE_WAITQUEUE(wq, current); add_wait_queue(&amp;ir.rwait, &amp;wq); wait_event(ir.rwait, ir.count == 32); remove_wait_queue(&amp;ir.rwait, &amp;wq); &#125; rc = copy_to_user(buf, &amp;ir.data, sizeof(u32)); if (rc &lt; 0) &#123; return rc; &#125; ir.count = 0; *off += sizeof(u32); return sizeof(u32);&#125;static const struct file_operations fops = &#123; .owner = THIS_MODULE, .read = ir_read,&#125;;static struct miscdevice irdev = &#123; .minor = MISC_DYNAMIC_MINOR, .name = &quot;IR1838-NEC&quot;, .fops = &amp;fops, .nodename = &quot;ir0&quot;, .mode = 0744,&#125;;static int __init ir_init(void) &#123; int rc = 0; // 初始化脉冲处理函数 init_waitqueue_head(&amp;ir.rwait); // 初始化定时器，用于断帧 timer_setup(&amp;ir.timer, clear_flag, 0); add_timer(&amp;ir.timer); // 申请GPIO及其双边沿中断 ir.gpio = 18; if ((rc = gpio_request_one(ir.gpio, GPIOF_IN, &quot;IR&quot;)) &lt; 0) &#123; printk(KERN_ERR &quot;ERROR%d: can not request gpio%d\\n&quot;, rc, ir.gpio); return rc; &#125; ir.irq = gpio_to_irq(ir.gpio); if ((rc = request_irq(ir.irq, ir_rx, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, &quot;IR&quot;, NULL)) &lt; 0) &#123; printk(KERN_ERR &quot;ERROR%d: can not request irq\\n&quot;, ir.irq); return rc; &#125; if ((rc = misc_register(&amp;irdev)) &lt; 0) &#123; return rc; &#125; return 0;&#125;module_init(ir_init);static void __exit ir_exit(void) &#123; misc_deregister(&amp;irdev); free_irq(ir.irq, NULL); gpio_free(ir.gpio); del_timer(&amp;ir.timer);&#125;module_exit(ir_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); 以上代码有个很大的风险，为了简化程序，IRQ中断并没有采取“底半部”来处理复杂的红外解码业务，如果业务逻辑进一步加大，可能会导致内核崩溃。 3、测试代码12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/fcntl.h&gt;// car-mp3遥控器指令码static const char* keyname[] = &#123;[0x45] = &quot;Channel-&quot;, [0x46] = &quot;Channel&quot;, [0x47] = &quot;Channel+&quot;,[0x44] = &quot;Speed-&quot;, [0x40] = &quot;Speed+&quot;, [0x43] = &quot;Play/Pause&quot;,[0x15] = &quot;Vol+&quot;, [0x07] = &quot;Vol-&quot;, [0x09] = &quot;EQ&quot;,[0x16] = &quot;No.0&quot;, [0x19] = &quot;100+&quot;, [0x0d] = &quot;200+&quot;,[0x0c] = &quot;No.1&quot;, [0x18] = &quot;No.2&quot;, [0x5e] = &quot;No.3&quot;,[0x08] = &quot;No.4&quot;, [0x1c] = &quot;No.5&quot;, [0x5a] = &quot;No.6&quot;,[0x42] = &quot;No.7&quot;, [0x52] = &quot;No.8&quot;, [0x4a] = &quot;No.9&quot;,&#125;;int main(int argc, char* argv[]) &#123; int ir = open(&quot;/dev/ir0&quot;, O_RDONLY); while (1) &#123; int frame = 0; if (read(ir, &amp;frame, sizeof(int)) &lt; 0) &#123; perror(&quot;read ir&quot;); break; &#125; int cmd = (frame &gt;&gt; 16) &amp; 0xFF; printf(&quot;%s\\n&quot;, keyname[cmd]); &#125; close(ir); return 0;&#125;","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:04--树莓派GPIO杂项驱动misc","slug":"linuxDrive/Linux驱动-实践-04-树莓派GPIO杂项驱动misc","date":"2022-11-01T07:14:15.000Z","updated":"2022-11-04T00:58:01.402Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-04-树莓派GPIO杂项驱动misc/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-04-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E6%9D%82%E9%A1%B9%E9%A9%B1%E5%8A%A8misc/","excerpt":"","text":"一、修改设备树1、查看io引脚信息 2、将io信息加入设备树123456789 pinCtrl: gpioCtrl&#123; compatible = &quot;raspberrypi,model-zero-w&quot;, &quot;brcm,bcm2835&quot;; label = &quot;2022&quot;; pinctrl-name =&quot;ledGpioCtrl&quot;; wodfa=&quot;null!&quot;; gpios = &lt;&amp;gpio 20 GPIO_ACTIVE_LOW &amp;gpio 21 GPIO_ACTIVE_LOW&gt;;&#125;; 3、编译并更新设备树1make dtbs 二、编写驱动与应用程序1、编写驱动程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;linux/kernel.h&gt;#include&lt;linux/module.h&gt;#include&lt;linux/miscdevice.h&gt;#include&lt;linux/fs.h&gt;#include&lt;linux/export.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_address.h&gt;#include &lt;linux/of_gpio.h&gt;#include &lt;linux/gpio.h&gt;#define LEDOFF 0 #define LEDON 1 struct gpioled_dev &#123; struct device_node *nd; int led_gpio; int led_gpio1;&#125;;struct gpioled_dev gpioled;static int misc_open(struct inode *node, struct file *fp)&#123; fp-&gt;private_data = &amp;gpioled; printk(KERN_DEBUG &quot;this dev is open\\n&quot;); return 0;&#125;static int misc_close(struct inode *node, struct file *fp)&#123; printk(KERN_DEBUG &quot;this dev is close\\n&quot;); return 0;&#125;ssize_t misc_read(struct file *fp, char __user *buf, size_t size, loff_t *loff)&#123; printk(KERN_DEBUG &quot;this dev is read\\n&quot;); return 0;&#125;ssize_t misc_write(struct file *fp, const char __user *buf, size_t size, loff_t *loff)&#123; int retvalue=0; unsigned char databuf[1]; unsigned char ledstat; struct gpioled_dev *dev = fp-&gt;private_data; printk(KERN_DEBUG &quot;this dev is write\\n&quot;); retvalue = copy_from_user(databuf, buf, size); if(retvalue &lt; 0) &#123; printk(KERN_DEBUG &quot;kernel write failed!\\r\\n&quot;); return -EFAULT; &#125; ledstat = databuf[0]; if(ledstat == LEDON) &#123; gpio_set_value(dev-&gt;led_gpio, 0); gpio_set_value(dev-&gt;led_gpio1, 1); printk(KERN_DEBUG &quot;driver: LED ON\\n&quot;); &#125; else if(ledstat == LEDOFF) &#123; gpio_set_value(dev-&gt;led_gpio, 1); gpio_set_value(dev-&gt;led_gpio1, 0); printk(KERN_DEBUG &quot;driver: LED OFF\\n&quot;); &#125; return 0;&#125;struct file_operations fops = &#123; .owner=THIS_MODULE, .open=misc_open, .read=misc_read, .write=misc_write, .release=misc_close,&#125;;struct miscdevice mymisc=&#123; .minor=MISC_DYNAMIC_MINOR, .name=&quot;mymisc&quot;, .fops=&amp;fops,&#125;;static int __init misc_init(void)&#123; int ret = 0; gpioled.nd = of_find_node_by_path(&quot;/gpioCtrl&quot;); if(gpioled.nd == NULL) &#123; printk(KERN_DEBUG &quot;gpioCtrl node not find!\\n&quot;); return -EINVAL; &#125; else &#123; printk(KERN_DEBUG &quot;gpioCtrl node find!\\n&quot;); &#125; gpioled.led_gpio = of_get_named_gpio(gpioled.nd, &quot;gpios&quot;, 0); gpioled.led_gpio1 = of_get_named_gpio(gpioled.nd, &quot;gpios&quot;, 1); if(gpioled.led_gpio &lt; 0) &#123; printk(KERN_DEBUG &quot;can&#x27;t get gpios&quot;); return -EINVAL; &#125; printk(KERN_DEBUG &quot;gpios num = %d\\n&quot;, gpioled.led_gpio); printk(KERN_DEBUG &quot;gpios num = %d\\n&quot;, gpioled.led_gpio1); ret = gpio_direction_output(gpioled.led_gpio, 1); gpio_direction_output(gpioled.led_gpio1, 1); if(ret &lt; 0) &#123; printk(KERN_DEBUG &quot;can&#x27;t set gpio!\\n&quot;); &#125; if(misc_register(&amp;mymisc)) &#123; printk(KERN_DEBUG &quot;this module is insmod fail\\n&quot;); return -1; &#125; printk(KERN_DEBUG &quot;this module is success\\n&quot;); return 0;&#125;static void __exit misc_exit(void)&#123; misc_deregister(&amp;mymisc); printk(&quot;this module is exit\\r\\n&quot;);&#125;module_init(misc_init);module_exit(misc_exit);MODULE_LICENSE(&quot;GPL&quot;); 2、编写应用程序123456789101112131415161718192021222324252627282930313233343536#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[])&#123; int fd , retvalue, j=0; char *filename = &quot;/dev/mymisc&quot;; fd = open(filename, O_RDWR); if(fd &lt; 0) &#123; printf(&quot;file %s open failed!\\n&quot;, filename); return -1; &#125; unsigned char on[1] = &#123;1&#125;, off[1] = &#123;0&#125;; int len = sizeof(unsigned char); while (1) &#123; write(fd, on, len); printf(&quot;led on!\\n&quot;); sleep(5); write(fd, off, len); printf(&quot;led off!\\n&quot;); sleep(5); &#125; close(fd); return 0;&#125; 3、编写Makefile123456789101112KDIR := /media/dataDisk/lufahai/raspberry/linux-5.10obj-m := misc.oappfile :=app.cbuild: kernel_moduleskernel_modules: make -C $(KDIR) M=$(PWD) modules ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- arm-linux-gnueabihf-gcc app.c -o appclean: rm -rf *.ko *.o *.mod.o *.mod.c *.symvers modul* .tmp_* .misc* *.mod 4、加载驱动并验证三、问题及解决1、app程序出现段错误issue： 在进行交叉编译后，直接把可执行文件放到树莓派上运行会出现段错误，应该和编译器版本有关。 solve： 将源文件放到树莓派上编译再执行。","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:03--树莓派GPIO驱动PWD呼吸灯","slug":"linuxDrive/Linux驱动-实践-03-树莓派GPIO驱动PWD呼吸灯","date":"2022-11-01T07:14:02.000Z","updated":"2022-11-03T01:41:22.907Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-03-树莓派GPIO驱动PWD呼吸灯/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-03-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E9%A9%B1%E5%8A%A8PWD%E5%91%BC%E5%90%B8%E7%81%AF/","excerpt":"","text":"一、树莓派上的PWM1、硬件资源树莓派扩展接口共有4个GPIO引出PWM，具体如下 2、启用pwm树莓派内核默认未启用pwm,也就是无法通过Linux内核获取到pwm资源，需要先启用： 123sudo vim /boot/config.txt 在最后一行加入： dtoverlay=pwmsudo reboot 重启后查看pwm确认已启用： 方法1： 1lsmod | grep pwm 方法2： 1ls /sys/class/pwm/ 3、pwm使用步骤1) 请求pwm0的资源 2) 设置脉冲周期 3) 设置占空比 4) 打开pwm0 4、指令控制pwm123456789cd /sys/class/pwm/pwmchip0/echo 0 &gt; export #load pwmecho 10000000 &gt; pwm0/period #set period as 10msecho 8000000 &gt; pwm0/duty_cycle #set duty as 8msecho 1 &gt; pwm0/enable #enable pwmecho 0 &gt; pwm0/enable #disable pwmecho 0 &gt; unexport #unload pwm 二、Linux驱动控制pwm1、pwm相关的API12345678910111213141516171819202122232425262728293031323334353637383940// PWM channel objectstruct pwm_device &#123; const char *label; // name of the PWM device unsigned long flags; // flags associated with the PWM device unsigned int hwpwm; // per-chip relative index of the PWM device unsigned int pwm; // global index of the PWM device struct pwm_chip *chip; // PWM chip providing this PWM device void *chip_data; // chip-private data associated with the PWM device struct pwm_args args; // PWM arguments struct pwm_state state; // curent PWM channel state&#125;;/*** 通过pwm通道号获取pwm通道对象* @pwm_id 通道号* @label pwm通道别名*/struct pwm_device *pwm_request(int pwm_id, const char *label);/*** 释放pwm通道对象*/void pwm_free(struct pwm_device *pwm);/*** 设置pwm通道的相关参数* @duty_ns 以纳秒为单位的占空比* @period_ns 以纳秒为单位的脉冲周期*/int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)/*** 打开pwm通道，开始输出脉冲*/int pwm_enable(struct pwm_device *pwm)/*** 关闭pwm通道，停止输出脉冲*/void pwm_disable(struct pwm_device *pwm) 2、驱动程序案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/miscdevice.h&gt;#include &lt;linux/pwm.h&gt;#define PWMLED_PERIOD 1000000 // 脉冲周期固定为1ms#define PWMLED_MAX_BRIGHTNESS 1000typedef enum &#123; PWMLED_CMD_SET_BRIGHTNESS = 0x1, PWMLED_CMD_GET_BRIGHTNESS,&#125; pwmled_cmd_t;static struct &#123; struct pwm_device* pwm; unsigned int brightness;&#125; pwmled;long pwmled_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) &#123;switch (cmd) &#123;case PWMLED_CMD_SET_BRIGHTNESS: // 所谓调节亮度，就是配置占空比，然后使能pwm0 pwmled.brightness = arg &lt; PWMLED_MAX_BRIGHTNESS ? arg : PWMLED_MAX_BRIGHTNESS; pwm_config(pwmled.pwm, pwmled.brightness * 1000, PWMLED_PERIOD); if (pwmled.brightness &gt; 0) &#123; pwm_enable(pwmled.pwm); &#125; else &#123; pwm_disable(pwmled.pwm); &#125;case PWMLED_CMD_GET_BRIGHTNESS: return pwmled.brightness;default: return -EINVAL;&#125;return pwmled.brightness;&#125;static struct file_operations fops = &#123; .owner = THIS_MODULE, .unlocked_ioctl = pwmled_ioctl,&#125;;static struct miscdevice dev = &#123; .minor = 0, .name = &quot;pwmled&quot;, .fops = &amp;fops, .nodename = &quot;pwmled&quot;, .mode = 0666,&#125;;int __init pwmled_init(void) &#123;// 请求PWM0通道struct pwm_device* pwm = pwm_request(0, &quot;pwm0&quot;);if (IS_ERR_OR_NULL(pwm)) &#123; printk(KERN_ERR &quot;failed to request pwm\\n&quot;); return PTR_ERR(pwm);&#125;pwmled.pwm = pwm;pwmled.brightness = 0;misc_register(&amp;dev); return 0;&#125;module_init(pwmled_init);void __exit pwmled_exit(void) &#123; misc_deregister(&amp;dev); // 停止并释放PWM0通道 pwm_disable(pwmled.pwm); pwm_free(pwmled.pwm);&#125;module_exit(pwmled_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); 3、测试程序12345678910111213141516171819202122232425int main(int argc, char* argv[]) &#123; int fd = open(&quot;/dev/pwmled&quot;, O_RDWR); int brightness = 0; char key = 0; while ((key = getchar()) != &#x27;q&#x27;) &#123; switch (key) &#123; case &#x27;=&#x27;: brightness += brightness &lt; PWMLED_MAX_BRIGHTNESS ? 10 : 0; break; case &#x27;-&#x27;: brightness -= brightness &gt; 0 ? 10 : 0; break; &#125; if (ioctl(fd, PWMLED_CMD_SET_BRIGHTNESS, brightness) &lt; 0) &#123; perror(&quot;ioctl&quot;); break; &#125; &#125; close(fd); return 0;&#125;","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:02--树莓派GPIO驱动中断","slug":"linuxDrive/Linux驱动-实践-02-树莓派GPIO驱动中断","date":"2022-11-01T07:13:09.000Z","updated":"2022-11-02T13:31:08.570Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-02-树莓派GPIO驱动中断/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-02-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E9%A9%B1%E5%8A%A8%E4%B8%AD%E6%96%AD/","excerpt":"","text":"一、实现IO引脚上升沿中断步骤1) 设置GPIO复用功能为输入模式 gpio_request() 2) 获取GPIO对应的中断号 gpio_to_irq() 3) 申请中断号、中断类型、绑定处理函数 request_irq() 4) 释放中断(卸载驱动时) free_irq() 二、GPIO操作相关的接口12345678910111213141516171819#include &lt;linux/gpio.h&gt;struct gpio &#123; unsigned gpio; // GPIO编号 unsigned long flags; // GPIO复用功能配置 const char *label; // GPIO标签名&#125;;// 单个GPIO资源申请/释放int gpio_request_one(unsigned gpio, unsigned long flags, const char *label);void gpio_free(unsigned gpio);// 多个GPIO资源申请/释放int gpio_request_array(const struct gpio *array, size_t num);void gpio_free_array(const struct gpio *array, size_t num);// GPIO状态读写int gpio_get_value(unsigned gpio);void gpio_set_value(unsigned gpio, int value); 三、按键防抖1、Linux驱动防抖和单片机防抖对比单片机实现按键防抖无非就是sleep 50ms，再确认是否真的按下。 但是Linux是一个多任务系统，永远不要试图在中断函数中睡眠，防抖只能放在Linux中断的底半部。 此外Linux驱动中慎用睡眠函数，除非你很清楚它不是忙等待。 Linux下防抖的逻辑应该是触发中断后，让出CPU资源50ms，然后再确认。 2、Linux底半部机制1) 软中断，是有内核软件模拟的一种中断机制，注意不要和ARM指令触发的中断混淆，后者本质上是硬中断 2) tasklet 基于软中断实现的中断调度机制，本质上还是中断，不允许在处理函数中sleep 3) 工作队列，类似于tasklet，区别在于工作队列底层基于线程，可以在处理函数中sleep 4) 线程IRQ，不用解释了，就是个线程。 3、工作队列API1234567891011121314151617181920#include &lt;linux/workqueue.h&gt;// 工作队列原型struct work_struct &#123; atomic_long_t data; struct list_head entry; work_func_t func;#ifdef CONFIG_LOCKDEP struct lockdep_map lockdep_map;#endif&#125;;// 工作队列回调函数原型typedef void (*work_func_t)(struct work_struct *work);// 初始化一个工作队列，绑定回调INIT_WORK(work, func);// 启动队列，之后会由内核完成调度schedule_work(&amp;my_wq); 4、定时器API1234567891011121314151617181920212223242526272829303132#include &lt;linux/timer.h&gt;// 全局变量// 记录上电后定时器中断次数，也就是开机时长，但不是微秒或纳秒的概念extern unsigned long volatile jiffies;// 表示CPU一秒钟有多少个定时器中断#define HZ 1000// 简单来说，如果要定义一个100ms的延时，相当于以下公式：// jiffies + (HZ/10)// 相当于以现在的jiffies做偏移，而1s的十分之一就是100ms// 定时器原型struct timer_list &#123; struct hlist_node entry; unsigned long expires; void (*function)(struct timer_list *); u32 flags;#ifdef CONFIG_LOCKDEP struct lockdep_map lockdep_map;#endif&#125;;// 向内核注册一个定时器#define timer_setup(timer, callback, flags)void add_timer(struct timer_list *timer);// 向内核删除一个定时器int del_timer(struct timer_list *timer);// 修改定时器的下次的jiffiesint mod_timer(struct timer_list *timer, unsigned long expires) 三、完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/miscdevice.h&gt; // 混杂设备相关结构#include &lt;linux/gpio.h&gt; // 各种gpio的数据结构及函数#include &lt;linux/interrupt.h&gt; // 内核中断相关接口#include &lt;linux/workqueue.h&gt;#include &lt;linux/timer.h&gt;// 定义按键的GPIO引脚static const struct gpio key = &#123; .gpio = 17, // 引脚号为BCM - 17 .flags = GPIOF_IN, // 功能复用为输入 .label = &quot;Key0&quot; // 标示为Key0&#125;;// 定义三色LED的GPIO引脚static const struct gpio leds[] = &#123; &#123; 2, GPIOF_OUT_INIT_HIGH, &quot;LED_RED&quot; &#125;, &#123; 3, GPIOF_OUT_INIT_HIGH, &quot;LED_GREEN&quot; &#125;, &#123; 4, GPIOF_OUT_INIT_HIGH, &quot;LED_BLUE&quot; &#125;,&#125;;static unsigned int keyirq = 0; // GPIO按键中断号static struct work_struct keywork; // 按键工作队列static struct timer_list timer; // 定时器作为中断延时// 按键中断“顶半部”处理函数，启用工作队列static irqreturn_t on_key_press(int irq, void* dev)&#123; schedule_work(&amp;keywork); return IRQ_HANDLED;&#125;// 按键中断“底半部”工作队列，启动一个50ms的延时定时器void start_timer(struct work_struct *work)&#123; mod_timer(&amp;timer, jiffies + (HZ/20));&#125;// 按键防抖定时器，及处理函数void on_delay_50ms(struct timer_list *timer)&#123; static int i = 0; if (gpio_get_value(key.gpio)) &#123; gpio_set_value(leds[i].gpio, 0); i = ++i == 3 ? 0 : i; gpio_set_value(leds[i].gpio, 1); &#125;&#125;static int __init gpiokey_init(void)&#123; int rc = 0; // 向内核申请GPIO if ((rc = gpio_request_one(key.gpio, key.flags, key.label)) &lt; 0 || (rc = gpio_request_array(leds, 3)) &lt; 0) &#123; printk(KERN_ERR &quot;ERROR%d: cannot request gpio\\n&quot;, rc); return rc; &#125; // 获取中断号 keyirq = gpio_to_irq(key.gpio); if (keyirq &lt; 0) &#123; printk(KERN_ERR &quot;can not get irq num.\\n&quot;); return -EFAULT; &#125; // 申请上升沿触发 if (request_irq(keyirq, on_key_press, IRQF_TRIGGER_RISING, &quot;onKeyPress&quot;, NULL) &lt; 0) &#123; printk(KERN_ERR &quot;can not request irq\\n&quot;); return -EFAULT; &#125; // 初始化按键中断底半部(工作队列) INIT_WORK(&amp;keywork, start_timer); // 初始化定时器 timer_setup(&amp;timer, on_delay_50ms, 0); add_timer(&amp;timer); return 0;&#125;module_init(gpiokey_init);static void __exit gpiokey_exit(void)&#123; free_irq(keyirq, NULL); gpio_free_array(leds, 3); gpio_free(key.gpio); del_timer(&amp;timer);&#125;module_exit(gpiokey_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;);","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[实践]:01--树莓派GPIO驱动LED","slug":"linuxDrive/Linux驱动-实践-01-树莓派GPIO驱动LED","date":"2022-11-01T07:12:47.000Z","updated":"2022-11-02T01:15:56.026Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-实践-01-树莓派GPIO驱动LED/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5-01-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E9%A9%B1%E5%8A%A8LED/","excerpt":"","text":"一、Linux中的地址Linux内核中，又三种地址:总线地址、物理地址和虚拟地址。 1) 总线地址： 一种计算机总线，CPU或者有DMA能力的单元中的内存组件或者物理地址在总线上有相对应的地址。 比如CPU的寄存器也会在总线上有单独的地址，但是总线地址不等于真实的寄存器。 又比如类似于IIC设备在IIC总线上的地址。总线的宽度决定了CPU能够访问内存的范围，32位的最大只能识别4G的内存； 1) 物理地址： 硬件中的实际地址或绝对地址:比如磁盘地址，比如51的寄存器，就是物理地址； 2) 虚拟地址： 操作系统运行在保护模式下所使用的地址，也叫逻辑地址，它是基于算法的，处于软件层面。 树莓派IO口的地址介绍是物理地址，挂载到Linux内核虚拟地址，编程使用的是虚拟地址。 二、树莓派GPIO寄存器地址1、GPFSELx IO口模式配置寄存器Address ：寄存器的基地址，也是寄存器的物理地址；Field Name:寄存器名；Descriptin: 寄存器说明； GPFSEL0 是 pin0 ~ pin9的配置寄存器，GPFSEL1是pin10 ~ pin19的配置寄存器，以此类推，GPFSEL5就是pin50 ~ pin53的配置寄存器。每个pin在寄存器上的位置及模式说明： 2、GPSET0,GPSET1 IO设置寄存器 GPSET0: pin0~pin31的设置寄存器，1位高电平，0为低电平，复位后为0： GPSET1: pin32~pin53的设置寄存器，1位高电平，0为低电平，复位后为0： 3、GPCLR0,GPCLR1 IO口清除寄存器 GPCLR0: pin0~pin31的清除寄存器，1位高电平，0为低电平，复位后为0； GPCLR1: pin31~pin54的清除寄存器，1位高电平，0为低电平，复位后为0； 有这三种寄存器，就操作树莓派的IO口输入高低电平了，但是不要忘了，操作树莓派的IO是操作虚拟地址，而不是上面的 0x7E20…，因此在编程之前一定要查看物理地址的映射 使用： 1cat /proc/iomem 树莓派3B对 0x7e200000的映射在虚拟地址 0x3f200000上。所以编程时，以上几种寄存器的基地址应该是：0x3f20000; 二、GPIO驱动LED案例1、驱动代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;asm/io.h&gt;#define BCM2837_GPIO_BASE 0x3F200000#define BCM2837_GPIO_FSEL0_OFFSET 0x0#define BCM2837_GPIO_SET0_OFFSET 0x1C#define BCM2837_GPIO_CLR0_OFFSET 0x28#define LED_RED_PIN 2#define LED_GREEN_PIN 3#define LED_BLUE_PIN 4static void* gpio = 0;static bool ledstate[3] = &#123;0&#125;;static struct &#123;const char* name; const bool pins[3];&#125; colors[] = &#123; &#123; &quot;white&quot;, &#123;1,1,1&#125; &#125;, &#123; &quot;black&quot;, &#123;0,0,0&#125; &#125;, &#123; &quot;red&quot;, &#123;1,0,0&#125; &#125;, &#123; &quot;green&quot;, &#123;0,1,0&#125; &#125;, &#123; &quot;blue&quot;, &#123;0,0,1&#125; &#125;, &#123; &quot;yellow&quot;, &#123;1,1,0&#125; &#125;, &#123; &quot;cyan&quot;, &#123;0,1,1&#125; &#125;, &#123; &quot;purple&quot;, &#123;1,0,1&#125; &#125;,&#125;;void gpioctl(int pin, bool stat)&#123; void* reg = gpio + (stat ? BCM2837_GPIO_SET0_OFFSET : BCM2837_GPIO_CLR0_OFFSET); ledstate[pin-2] = stat; iowrite32(1 &lt;&lt; pin, reg);&#125;ssize_t rgbled_read(struct file* filp, char __user* buf, size_t len, loff_t* off)&#123; int rc = 0; int i = 0; /* if file has been read, return */ if (*off &gt; 0) &#123; return 0; &#125; for (i = 0; i &lt; sizeof(colors) / sizeof(colors[0]); i++) &#123; const char* name = colors[i].name; const bool* pins = colors[i].pins; if (ledstate[0] == pins[0] &amp;&amp; ledstate[1] == pins[1] &amp;&amp; ledstate[2] == pins[2]) &#123; char color[32] = &#123;0&#125;; sprintf(color, &quot;%s\\n&quot;, name); *off = strlen(color); rc = copy_to_user(buf, color, *off); return rc &lt; 0 ? rc : *off; &#125; &#125; return -EFAULT;&#125;ssize_t rgbled_write(struct file* filp, const char __user* buf, size_t len, loff_t* off)&#123; char color[32] = &#123;0&#125;; int rc = 0; int i = 0; rc = copy_from_user(color, buf, len); if (rc &lt; 0) &#123; return rc; &#125; /* reset offset after read */ *off = 0; for (i = 0; i &lt; sizeof(colors) / sizeof(colors[0]); i++) &#123; const char* name = colors[i].name; const bool* pins = colors[i].pins; if (!strncasecmp(color, name, strlen(name))) &#123; gpioctl(LED_RED_PIN, pins[0]); gpioctl(LED_GREEN_PIN, pins[1]); gpioctl(LED_BLUE_PIN, pins[2]); return len; &#125; &#125; return -EINVAL;&#125;// 用户层通过ioctl函数单独控制灯的状态long rgbled_ioctl(struct file* filp, unsigned int cmd, unsigned long arg)&#123; if (cmd &gt;= 2 &amp;&amp; cmd &lt;= 4) &#123; gpioctl(cmd, arg); &#125; else &#123; return -ENODEV; &#125; return 0;&#125;static const struct file_operations fops = &#123; .owner = THIS_MODULE, .read = rgbled_read, .write = rgbled_write, .unlocked_ioctl = rgbled_ioctl,&#125;;static dev_t devno = 0;static struct cdev cdev;static int __init rgbled_init(void)&#123; // 映射GPIO物理内存到虚拟地址，并将其置为“输出模式” // 代码写得比较丑，解释以下： // 就是先把三个GPIO的“功能选择位”全部置000 // 然后再将其置为001 int val = ~((7 &lt;&lt; (LED_RED_PIN*3)) | (7 &lt;&lt; (LED_GREEN_PIN*3)) | (7 &lt;&lt; LED_BLUE_PIN*3)); gpio = ioremap(BCM2837_GPIO_BASE, 0xB0); val &amp;= ioread32(gpio + BCM2837_GPIO_FSEL0_OFFSET); val |= (1 &lt;&lt; (LED_RED_PIN*3)) | (1 &lt;&lt; (LED_GREEN_PIN*3)) | (1 &lt;&lt; (LED_BLUE_PIN*3)); iowrite32(val, gpio); if (alloc_chrdev_region(&amp;devno, 0, 1, &quot;rgbled&quot;)) &#123; printk(KERN_ERR&quot;failed to register kernel module!\\n&quot;); return -1; &#125; cdev_init(&amp;cdev, &amp;fops); cdev_add(&amp;cdev, devno, 1); printk(KERN_INFO&quot;rgbled device major &amp; minor is [%d:%d]\\n&quot;, MAJOR(devno), MINOR(devno)); return 0;&#125;module_init(rgbled_init);static void __exit rgbled_exit(void)&#123; // 取消gpio物理内存映射 iounmap(gpio); // 释放字符设备 cdev_del(&amp;cdev); unregister_chrdev_region(devno, 1); printk(KERN_INFO&quot;rgbled free\\n&quot;);&#125;module_exit(rgbled_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); 2、测试代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;int main(int argc, char* argv[])&#123; if (argc &lt; 3) &#123; fprintf(stderr, &quot;\\n./rgbled_test &lt;r|g|b&gt; &lt;0|1&gt;\\n\\n&quot;); exit(0); &#125; int fd = open(&quot;/dev/rgbled&quot;, O_RDWR); if (fd &lt; 0) &#123; perror(&quot;open device&quot;); return -1; &#125; switch (argv[1][0]) &#123; case &#x27;r&#x27;: case &#x27;R&#x27;: ioctl(fd, 2, atoi(argv[2])); break; case &#x27;g&#x27;: case &#x27;G&#x27;: ioctl(fd, 3, atoi(argv[2])); break; case &#x27;b&#x27;: case &#x27;B&#x27;: ioctl(fd, 4, atoi(argv[2])); break; &#125; close(fd); return 0;&#125;","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"}]},{"title":"Linux驱动[理论]:15--Linux设备驱动调试","slug":"linuxDrive/Linux驱动-理论-15-Linux设备驱动调试","date":"2022-11-01T05:16:20.000Z","updated":"2022-11-01T07:41:19.234Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-15-Linux设备驱动调试/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-15-Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:14--ARM Linux设备树","slug":"linuxDrive/Linux驱动-理论-14-ARM-Linux设备树","date":"2022-11-01T05:15:59.000Z","updated":"2022-11-01T07:10:58.668Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-14-ARM-Linux设备树/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-14-ARM-Linux%E8%AE%BE%E5%A4%87%E6%A0%91/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:13--I2C SPI USB架构类比","slug":"linuxDrive/Linux驱动-理论-13-I2C-SPI-USB架构类比","date":"2022-11-01T05:15:31.000Z","updated":"2022-11-01T07:10:54.792Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-13-I2C-SPI-USB架构类比/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-13-I2C-SPI-USB%E6%9E%B6%E6%9E%84%E7%B1%BB%E6%AF%94/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:12--USB主机及设备与Gadget驱动","slug":"linuxDrive/Linux驱动-理论-12-USB主机及设备与Gadget驱动","date":"2022-11-01T05:14:51.000Z","updated":"2022-11-01T07:10:51.660Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-12-USB主机及设备与Gadget驱动/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-12-USB%E4%B8%BB%E6%9C%BA%E5%8F%8A%E8%AE%BE%E5%A4%87%E4%B8%8EGadget%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:11--I2C核心及总线与设备驱动","slug":"linuxDrive/Linux驱动-理论-11-I2C核心及总线与设备驱动","date":"2022-11-01T05:14:15.000Z","updated":"2022-11-01T07:10:48.396Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-11-I2C核心及总线与设备驱动/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-11-I2C%E6%A0%B8%E5%BF%83%E5%8F%8A%E6%80%BB%E7%BA%BF%E4%B8%8E%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:10--网络设备","slug":"linuxDrive/Linux驱动-理论-10-网络设备","date":"2022-11-01T05:13:24.000Z","updated":"2022-11-01T07:10:45.564Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-10-网络设备/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-10-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:09--块设备驱动","slug":"linuxDrive/Linux驱动-理论-09-块设备驱动","date":"2022-11-01T05:13:10.000Z","updated":"2022-11-01T07:10:42.460Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-09-块设备驱动/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-09-%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:08--设备驱动软件架构","slug":"linuxDrive/Linux驱动-理论-08-设备驱动软件架构","date":"2022-11-01T05:12:54.000Z","updated":"2022-11-01T07:10:38.952Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-08-设备驱动软件架构/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-08-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:07--内存与IO访问","slug":"linuxDrive/Linux驱动-理论-07-内存与IO访问","date":"2022-11-01T05:12:27.000Z","updated":"2022-11-01T07:10:35.764Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-07-内存与IO访问/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-07-%E5%86%85%E5%AD%98%E4%B8%8EIO%E8%AE%BF%E9%97%AE/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:06--时钟","slug":"linuxDrive/Linux驱动-理论-06-时钟","date":"2022-11-01T05:12:18.000Z","updated":"2022-11-01T07:37:20.934Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-06-时钟/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-06-%E6%97%B6%E9%92%9F/","excerpt":"","text":"一、内核定时器编程1、初始化定时器4.14之前的内核版本使用以下方式初始化： 12init_timer(&amp;second_devp-&gt;s_timer);second_devp-&gt;s_timer.function = &amp;second_timer_handler; 4.14之后的内核版本使用以下方式初始化： 1timer_setup(&amp;second_devp-&gt;s_timer, second_timer_handler, 0); 2、增加定时器1void add_timer(struct timer_list *list); 用于注册内核定时器，将定时器加入到内核动态定时器链表中。 3、删除定时器1void del_timer(struct timer_list *list); 用于删除定时器，其中del_timer_sync()是上述函数的同步版，在删除一个定时器时需要等待其被处理完， 因此该函数的调用不能发生在中断上下文中。 4、修改定时器的expire1int mod_timer(struct timer_list *list, unsigned long expires); 用于修改定时器的到期时间，在新的被传入的expire到来后才会执行定时器函数。 5、内核定时器模板12345678910111213141516171819202122232425262728293031323334struct xxx_dev &#123; struct cdev cdev; ... struct timer_list s_timer;&#125;;static int xxx_fun1(...)&#123; struct xxx_dev *dev = file-&gt;private_data; /* 初始化定时器 */ timer_setup(&amp;second_devp-&gt;s_timer, second_timer_handler, 0); second_devp-&gt;s_timer.expires = jiffies + HZ; /* 注册定时器 */ add_timer(&amp;second_devp-&gt;s_timer); ....&#125;static int xxx_fun2(...)&#123; .... /* 删除定时器 */ del_timer(&amp;second_devp-&gt;s_timer); ....&#125;static void xxx_timer_handler(struct timer_list *timer)&#123; /* 调度定时器再次执行 */ mod_timer(&amp;second_devp-&gt;s_timer, jiffies + HZ); atomic_inc(&amp;second_devp-&gt;counter);&#125; 二、实例：秒字符设备1、驱动层代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/mm.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/timer.h&gt;#include &lt;linux/uaccess.h&gt;#define SECOND_MAJOR 234static int second_major = SECOND_MAJOR;module_param(second_major, int, S_IRUGO);struct second_dev &#123; struct cdev cdev; atomic_t counter; struct timer_list s_timer;&#125;;static struct second_dev *second_devp;static void second_timer_handler(struct timer_list *timer)&#123; printk(KERN_INFO &quot;current jiffies is %ld\\n&quot;, jiffies); mod_timer(&amp;second_devp-&gt;s_timer, jiffies + HZ); atomic_inc(&amp;second_devp-&gt;counter);&#125;static int second_open(struct inode *inode, struct file *filp)&#123; timer_setup(&amp;second_devp-&gt;s_timer, second_timer_handler, 0); second_devp-&gt;s_timer.expires = jiffies + HZ; add_timer(&amp;second_devp-&gt;s_timer); atomic_set(&amp;second_devp-&gt;counter, 0); return 0;&#125;static int second_release(struct inode *inode, struct file *filp)&#123; del_timer(&amp;second_devp-&gt;s_timer); return 0;&#125;static ssize_t second_read(struct file *filp, char __user * buf, size_t count, loff_t * ppos)&#123; int counter; counter = atomic_read(&amp;second_devp-&gt;counter); if (put_user(counter, (int *)buf)) return -EFAULT; else return sizeof(unsigned int);&#125;static const struct file_operations second_fops = &#123; .owner = THIS_MODULE, .open = second_open, .release = second_release, .read = second_read,&#125;;static void second_setup_cdev(struct second_dev *dev, int index)&#123; int err, devno = MKDEV(second_major, index); cdev_init(&amp;dev-&gt;cdev, &amp;second_fops); dev-&gt;cdev.owner = THIS_MODULE; err = cdev_add(&amp;dev-&gt;cdev, devno, 1); if (err) printk(KERN_ERR &quot;Failed to add second device\\n&quot;);&#125;static int __init second_init(void)&#123; int ret; dev_t devno = MKDEV(second_major, 0); if (second_major) ret = register_chrdev_region(devno, 1, &quot;second&quot;); else &#123; ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;second&quot;); second_major = MAJOR(devno); &#125; if (ret &lt; 0) return ret; second_devp = kzalloc(sizeof(*second_devp), GFP_KERNEL); if (!second_devp) &#123; ret = -ENOMEM; goto fail_malloc; &#125; second_setup_cdev(second_devp, 0); return 0;fail_malloc: unregister_chrdev_region(devno, 1); return ret;&#125;module_init(second_init);static void __exit second_exit(void)&#123; cdev_del(&amp;second_devp-&gt;cdev); kfree(second_devp); unregister_chrdev_region(MKDEV(second_major, 0), 1);&#125;module_exit(second_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); 2、应用层测试代码12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;sys/stat.h&gt;int main()&#123; int fd; unsigned int counter = 0; unsigned int old_counter = 0; fd = open(&quot;/dev/second&quot;, O_RDONLY); if (fd &lt; 0) &#123; printf(&quot;Device open failure\\n&quot;); return -1; &#125; while (1) &#123; read(fd, &amp;counter, sizeof(unsigned int)); if(counter!= old_counter) &#123; printf(&quot;seconds after open /dev/second :%d\\n&quot;, counter); old_counter = counter; &#125; msleep(200); &#125; return 0;&#125;","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:05--中断处理","slug":"linuxDrive/Linux驱动-理论-05-中断处理","date":"2022-11-01T05:11:40.000Z","updated":"2022-11-01T07:10:28.276Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-05-中断处理/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-05-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:04--异步通知与异步IO","slug":"linuxDrive/Linux驱动-理论-04-异步通知与异步IO","date":"2022-11-01T05:11:11.000Z","updated":"2022-11-01T07:10:25.416Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-04-异步通知与异步IO/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-04-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5%E4%B8%8E%E5%BC%82%E6%AD%A5IO/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:03--阻塞与非阻塞IO","slug":"linuxDrive/Linux驱动-理论-03-阻塞与非阻塞IO","date":"2022-11-01T05:10:52.000Z","updated":"2022-11-01T07:40:56.399Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-03-阻塞与非阻塞IO/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-03-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EIO/","excerpt":"","text":"","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:02--驱动并发控制","slug":"linuxDrive/Linux驱动-理论-02-驱动并发控制","date":"2022-11-01T05:10:30.000Z","updated":"2022-11-01T08:01:11.585Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-02-驱动并发控制/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-02-%E9%A9%B1%E5%8A%A8%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/","excerpt":"","text":"一、驱动的并发控制1、原因1) 多进程、多线程程序执行时会出现并发与竞态的情况。 2) 程序在编译和执行阶段可能会出现“编译乱序”和“执行乱序”的问题 2、解决方法1) 中断屏蔽 2) 原子操作 3) 自旋锁 4) 信号量 5) 互斥体 6) 完成量 3、加入并发控制的字符设备驱动程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/uaccess.h&gt;#define GLOBALMEM_SIZE 0x1000#define MEM_CLEAR 0x1#define GLOBALMEM_MAJOR 230static int globalmem_major = GLOBALMEM_MAJOR;module_param(globalmem_major, int, S_IRUGO);struct globalmem_dev &#123; struct cdev cdev; unsigned char mem[GLOBALMEM_SIZE]; struct mutex mutex;&#125;;struct globalmem_dev *globalmem_devp;static int globalmem_open(struct inode *inode, struct file *filp)&#123; filp-&gt;private_data = globalmem_devp; return 0;&#125;int globalmem_release(struct inode *inode, struct file *filp)&#123; return 0;&#125;static long globalmem_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; struct globalmem_dev *dev = filp-&gt;private_data; switch (cmd) &#123; case MEM_CLEAR: mutex_lock(&amp;dev-&gt;mutex); memset(dev-&gt;mem, 0, GLOBALMEM_SIZE); mutex_unlock(&amp;dev-&gt;mutex); printk(KERN_INFO &quot;globalmem is set to zero\\n&quot;); break; default: return -EINVAL; &#125; return 0;&#125;static ssize_t globalmem_read(struct file *filp, char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; mutex_lock(&amp;dev-&gt;mutex); if (copy_to_user(buf, dev-&gt;mem + p, count)) &#123; ret = -EFAULT; &#125; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;read %u bytes(s) from %lu\\n&quot;, count, p); &#125; mutex_unlock(&amp;dev-&gt;mutex); return ret;&#125;static ssize_t globalmem_write(struct file *filp, const char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; mutex_lock(&amp;dev-&gt;mutex); if (copy_from_user(dev-&gt;mem + p, buf, count)) ret = -EFAULT; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;written %u bytes(s) from %lu\\n&quot;, count, p); &#125; mutex_unlock(&amp;dev-&gt;mutex); return ret;&#125;static loff_t globalmem_llseek(struct file *filp, loff_t offset, int orig)&#123; loff_t ret = 0; switch (orig) &#123; case 0: if (offset &lt; 0) &#123; ret = -EINVAL; break; &#125; if ((unsigned int)offset &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos = (unsigned int)offset; ret = filp-&gt;f_pos; break; case 1: if ((filp-&gt;f_pos + offset) &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; if ((filp-&gt;f_pos + offset) &lt; 0) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos += offset; ret = filp-&gt;f_pos; break; default: ret = - EINVAL; break; &#125; return ret;&#125;static const struct file_operations globalmem_fops = &#123; .owner = THIS_MODULE, .llseek = globalmem_llseek, .read = globalmem_read, .write = globalmem_write, .unlocked_ioctl = globalmem_ioctl, .open = globalmem_open, .release = globalmem_release,&#125;;static void globalmem_setup_cdev(struct globalmem_dev *dev, int index)&#123; int err, devno = MKDEV(globalmem_major, index); cdev_init(&amp;dev-&gt;cdev, &amp;globalmem_fops); dev-&gt;cdev.owner = THIS_MODULE; err = cdev_add(&amp;dev-&gt;cdev, devno, 1); if (err) printk(KERN_NOTICE &quot;Error %d adding globalmem%d&quot;, err, index);&#125;static int __init globalmem_init(void)&#123; int ret; dev_t devno = MKDEV(globalmem_major, 0); if (globalmem_major) ret = register_chrdev_region(devno, 1, &quot;globalmem&quot;); else &#123; ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;globalmem&quot;); globalmem_major = MAJOR(devno); &#125; if (ret &lt; 0) return ret; globalmem_devp = kzalloc(sizeof(struct globalmem_dev), GFP_KERNEL); if (!globalmem_devp) &#123; ret = -ENOMEM; goto fail_malloc; &#125; globalmem_setup_cdev(globalmem_devp, 0); mutex_init(&amp;globalmem_devp-&gt;mutex); return 0;fail_malloc: unregister_chrdev_region(devno, 1); return ret;&#125;module_init(globalmem_init);static void __exit globalmem_exit(void)&#123; cdev_del(&amp;globalmem_devp-&gt;cdev); kfree(globalmem_devp); unregister_chrdev_region(MKDEV(globalmem_major, 0), 1);&#125;module_exit(globalmem_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;);","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"Linux驱动[理论]:01--字符设备驱动","slug":"linuxDrive/Linux驱动-理论-01-字符设备驱动","date":"2022-11-01T05:10:04.000Z","updated":"2022-11-01T07:40:37.964Z","comments":true,"path":"2022/11/01/linuxDrive/Linux驱动-理论-01-字符设备驱动/","link":"","permalink":"http://example.com/2022/11/01/linuxDrive/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA-01-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"一、字符设备驱动的组成1、模块加载与卸载函数加载函数： 实现设备号的申请和cdev的注册。 卸载函数： 实现设备号的释放cdev的注销。 12345678910111213141516171819202122232425262728293031struct xxx_dev_t &#123; struct cdev cdev;&#125; xxx_dev;/* 加载函数 */static int __init xxx_init(void) &#123; ... cdev_init(&amp;xxx_dev.cdev, &amp;xxx_fops); xxx_dev.cdev.owner = THIS_MODULE; /* 获取字符设备号 */ if (xxx_major) &#123; register_chrdev_region(xxx_dev_no, 1, DEV_NAME); &#125; else &#123; alloc_chrdev_region(&amp;xxx_dev_no, 0, 1, DEV_NAME); &#125; ret = cdev_add(&amp;xxx_dev.cdev, &amp;xxx_dev_no, 1); ...&#125;/* 卸载函数 */static void __exit xxx_exit(void) &#123; unregister_chrdev_region(xxx_dev_no, 1); cdev_del(&amp;xxx_dev.cdev); ...&#125; 2、file_operations结构体中的成员函数1234567891011121314151617181920212223242526272829303132333435/* device read */ssize_t xxx_read(struct file *fp, char __user *buf, size_t size, loff_t *loff)&#123; ... copy_to_user(buf, ..., ...); ...&#125;/* device write */ssize_t xxx_write(struct file *fp, char __user *buf, size_t size, loff_t *loff)&#123; ... copy_from_user(buf, ..., ...); ...&#125;/* ioctrl */long xxx_ioctrl(struct file *fp, unsigned int cmd, unsigned long arg)&#123; ... switch(cmd) &#123; case xxx_CMD1: .... break; case xxx_CMD2: .... break; default: return -ENOTTY; break; &#125; return 0;&#125; 3、字符设备驱动的结构图 二、字符设备驱动实例1、编写字符设备驱动程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/uaccess.h&gt;#define GLOBALMEM_SIZE 0x1000#define MEM_CLEAR 0x1#define GLOBALMEM_MAJOR 230static int globalmem_major = GLOBALMEM_MAJOR;module_param(globalmem_major, int, S_IRUGO);struct globalmem_dev &#123; struct cdev cdev; unsigned char mem[GLOBALMEM_SIZE];&#125;;struct globalmem_dev *globalmem_devp;static int globalmem_open(struct inode *inode, struct file *filp)&#123; filp-&gt;private_data = globalmem_devp; return 0;&#125;static int globalmem_release(struct inode *inode, struct file *filp)&#123; return 0;&#125;static long globalmem_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; struct globalmem_dev *dev = filp-&gt;private_data; switch (cmd) &#123; case MEM_CLEAR: memset(dev-&gt;mem, 0, GLOBALMEM_SIZE); printk(KERN_INFO &quot;globalmem is set to zero\\n&quot;); break; default: return -EINVAL; &#125; return 0;&#125;static ssize_t globalmem_read(struct file *filp, char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; if (copy_to_user(buf, dev-&gt;mem + p, count)) &#123; ret = -EFAULT; &#125; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;read %u bytes(s) from %lu\\n&quot;, count, p); &#125; return ret;&#125;static ssize_t globalmem_write(struct file *filp, const char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; if (copy_from_user(dev-&gt;mem + p, buf, count)) ret = -EFAULT; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;written %u bytes(s) from %lu\\n&quot;, count, p); &#125; return ret;&#125;static loff_t globalmem_llseek(struct file *filp, loff_t offset, int orig)&#123; loff_t ret = 0; switch (orig) &#123; case 0: if (offset &lt; 0) &#123; ret = -EINVAL; break; &#125; if ((unsigned int)offset &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos = (unsigned int)offset; ret = filp-&gt;f_pos; break; case 1: if ((filp-&gt;f_pos + offset) &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; if ((filp-&gt;f_pos + offset) &lt; 0) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos += offset; ret = filp-&gt;f_pos; break; default: ret = -EINVAL; break; &#125; return ret;&#125;static const struct file_operations globalmem_fops = &#123; .owner = THIS_MODULE, .llseek = globalmem_llseek, .read = globalmem_read, .write = globalmem_write, .unlocked_ioctl = globalmem_ioctl, .open = globalmem_open, .release = globalmem_release,&#125;;static void globalmem_setup_cdev(struct globalmem_dev *dev, int index)&#123; int err, devno = MKDEV(globalmem_major, index); cdev_init(&amp;dev-&gt;cdev, &amp;globalmem_fops); dev-&gt;cdev.owner = THIS_MODULE; err = cdev_add(&amp;dev-&gt;cdev, devno, 1); if (err) printk(KERN_NOTICE &quot;Error %d adding globalmem%d&quot;, err, index);&#125;static int __init globalmem_init(void)&#123; int ret; dev_t devno = MKDEV(globalmem_major, 0); if (globalmem_major) ret = register_chrdev_region(devno, 1, &quot;globalmem&quot;); else &#123; ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;globalmem&quot;); globalmem_major = MAJOR(devno); &#125; if (ret &lt; 0) return ret; globalmem_devp = kzalloc(sizeof(struct globalmem_dev), GFP_KERNEL); if (!globalmem_devp) &#123; ret = -ENOMEM; goto fail_malloc; &#125; globalmem_setup_cdev(globalmem_devp, 0); return 0;fail_malloc: unregister_chrdev_region(devno, 1); return ret;&#125;module_init(globalmem_init);static void __exit globalmem_exit(void)&#123; cdev_del(&amp;globalmem_devp-&gt;cdev); kfree(globalmem_devp); unregister_chrdev_region(MKDEV(globalmem_major, 0), 1);&#125;module_exit(globalmem_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); 2、在用户空间中认证1) 加载程序 1sudo insmod globalmem.ko 2) 创建节点 1sudo mknod /dev/globalmem c 230 0 3) 写入字符 1echo &quot;hello Linux drive world&quot; &gt; /dev/globalmem 4) 查看字符 1cat /dev/globalmem 3、附录1、多个驱动字符设备驱动程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/uaccess.h&gt;#define GLOBALMEM_SIZE 0x1000#define MEM_CLEAR 0x1#define GLOBALMEM_MAJOR 230#define DEVICE_NUM 10static int globalmem_major = GLOBALMEM_MAJOR;module_param(globalmem_major, int, S_IRUGO);struct globalmem_dev &#123; struct cdev cdev; unsigned char mem[GLOBALMEM_SIZE];&#125;;struct globalmem_dev *globalmem_devp;static int globalmem_open(struct inode *inode, struct file *filp)&#123; struct globalmem_dev *dev = container_of(inode-&gt;i_cdev, struct globalmem_dev, cdev); filp-&gt;private_data = dev; return 0;&#125;static int globalmem_release(struct inode *inode, struct file *filp)&#123; return 0;&#125;static long globalmem_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; struct globalmem_dev *dev = filp-&gt;private_data; switch (cmd) &#123; case MEM_CLEAR: memset(dev-&gt;mem, 0, GLOBALMEM_SIZE); printk(KERN_INFO &quot;globalmem is set to zero\\n&quot;); break; default: return -EINVAL; &#125; return 0;&#125;static ssize_t globalmem_read(struct file *filp, char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; if (copy_to_user(buf, dev-&gt;mem + p, count)) &#123; ret = -EFAULT; &#125; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;read %u bytes(s) from %lu\\n&quot;, count, p); &#125; return ret;&#125;static ssize_t globalmem_write(struct file *filp, const char __user * buf, size_t size, loff_t * ppos)&#123; unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct globalmem_dev *dev = filp-&gt;private_data; if (p &gt;= GLOBALMEM_SIZE) return 0; if (count &gt; GLOBALMEM_SIZE - p) count = GLOBALMEM_SIZE - p; if (copy_from_user(dev-&gt;mem + p, buf, count)) ret = -EFAULT; else &#123; *ppos += count; ret = count; printk(KERN_INFO &quot;written %u bytes(s) from %lu\\n&quot;, count, p); &#125; return ret;&#125;static loff_t globalmem_llseek(struct file *filp, loff_t offset, int orig)&#123; loff_t ret = 0; switch (orig) &#123; case 0: if (offset &lt; 0) &#123; ret = -EINVAL; break; &#125; if ((unsigned int)offset &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos = (unsigned int)offset; ret = filp-&gt;f_pos; break; case 1: if ((filp-&gt;f_pos + offset) &gt; GLOBALMEM_SIZE) &#123; ret = -EINVAL; break; &#125; if ((filp-&gt;f_pos + offset) &lt; 0) &#123; ret = -EINVAL; break; &#125; filp-&gt;f_pos += offset; ret = filp-&gt;f_pos; break; default: ret = -EINVAL; break; &#125; return ret;&#125;static const struct file_operations globalmem_fops = &#123; .owner = THIS_MODULE, .llseek = globalmem_llseek, .read = globalmem_read, .write = globalmem_write, .unlocked_ioctl = globalmem_ioctl, .open = globalmem_open, .release = globalmem_release,&#125;;static void globalmem_setup_cdev(struct globalmem_dev *dev, int index)&#123; int err, devno = MKDEV(globalmem_major, index); cdev_init(&amp;dev-&gt;cdev, &amp;globalmem_fops); dev-&gt;cdev.owner = THIS_MODULE; err = cdev_add(&amp;dev-&gt;cdev, devno, 1); if (err) printk(KERN_NOTICE &quot;Error %d adding globalmem%d&quot;, err, index);&#125;static int __init globalmem_init(void)&#123; int ret; int i; dev_t devno = MKDEV(globalmem_major, 0); if (globalmem_major) ret = register_chrdev_region(devno, DEVICE_NUM, &quot;globalmem&quot;); else &#123; ret = alloc_chrdev_region(&amp;devno, 0, DEVICE_NUM, &quot;globalmem&quot;); globalmem_major = MAJOR(devno); &#125; if (ret &lt; 0) return ret; globalmem_devp = kzalloc(sizeof(struct globalmem_dev) * DEVICE_NUM, GFP_KERNEL); if (!globalmem_devp) &#123; ret = -ENOMEM; goto fail_malloc; &#125; for (i = 0; i &lt; DEVICE_NUM; i++) globalmem_setup_cdev(globalmem_devp + i, i); return 0;fail_malloc: unregister_chrdev_region(devno, DEVICE_NUM); return ret;&#125;module_init(globalmem_init);static void __exit globalmem_exit(void)&#123; int i; for (i = 0; i &lt; DEVICE_NUM; i++) cdev_del(&amp;(globalmem_devp + i)-&gt;cdev); kfree(globalmem_devp); unregister_chrdev_region(MKDEV(globalmem_major, 0), DEVICE_NUM);&#125;module_exit(globalmem_exit);MODULE_AUTHOR(&quot;Stephen Lu &lt;stephenLu@kernel.org&gt;&quot;);MODULE_LICENSE(&quot;GPL v2&quot;);","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"}],"tags":[{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"}]},{"title":"ubuntu18安装ch340驱动","slug":"ubuntu/ubuntu18安装ch340驱动","date":"2022-10-26T12:49:31.000Z","updated":"2022-10-27T02:10:39.920Z","comments":true,"path":"2022/10/26/ubuntu/ubuntu18安装ch340驱动/","link":"","permalink":"http://example.com/2022/10/26/ubuntu/ubuntu18%E5%AE%89%E8%A3%85ch340%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"一、安装过程1、下载驱动程序先到这个网站下驱动源文件包 https://www.wch.cn/download/CH341SER_LINUX_ZIP.html 2、替换源文件根据内核的不同版本，替换掉里边的源文件 https://elixir.bootlin.com/linux/v5.4.42/source/drivers/usb/serial/ch341.c 3、编译及安装根据readme内容的提示，make &amp;&amp; sudo make load 4、开机自动加载将驱动文件复制到 /lib/modules/5.4.0-42-generic/kernel/drivers/usb/serial/ 然后运行 sudo depmod -a 二、多个USB串口绑定1、查看当前USB串口信息123456789101112star@star:/etc/udev/rules.d$ lsusbBus 001 Device 002: ID 8087:8001 Intel Corp. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 003 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 002 Device 008: ID 0cf3:3004 Atheros Communications, Inc. AR3012 Bluetooth 4.0Bus 002 Device 005: ID 13d3:5727 IMC Networks Bus 002 Device 003: ID 0bda:0129 Realtek Semiconductor Corp. RTS5129 Card Reader ControllerBus 002 Device 010: ID 1a86:7523 QinHeng Electronics HL-340 USB-Serial adapterBus 002 Device 006: ID 24ae:2013 Bus 002 Device 011: ID 10c4:ea60 Cygnal Integrated Products, Inc. CP210x UART Bridge / myAVR mySmartUSB lightBus 002 Device 002: ID 1a40:0801 Terminus Technology Inc. Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub 2、创建udev配置文件1sudo gedit /etc/udev/rules.d/usb.rules 添加以下内容，格式如下： “串口文件名” “串口ID 前四位” “串口ID 后四位” “串口读写权限” “你起的串口名字” 123KERNEL==&quot;ttyUSB*&quot;, ATTRS&#123;idVendor&#125;==&quot;1a86&quot;, ATTRS&#123;idProduct&#125;==&quot;7523&quot;, MODE:=&quot;0777&quot;, SYMLINK+=&quot;RS232&quot;KERNEL==&quot;ttyUSB*&quot;, ATTRS&#123;idVendor&#125;==&quot;10c4&quot;, ATTRS&#123;idProduct&#125;==&quot;ea60&quot;, MODE:=&quot;0777&quot;, SYMLINK+=&quot;RS485&quot; 3、保存与更新123sudo service udev reloadsudo service udev restart","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"ubuntu18安装ROS1和ROS2","slug":"ubuntu/ubuntu18安装ROS1和ROS2","date":"2022-10-19T11:09:38.000Z","updated":"2022-10-27T15:13:14.361Z","comments":true,"path":"2022/10/19/ubuntu/ubuntu18安装ROS1和ROS2/","link":"","permalink":"http://example.com/2022/10/19/ubuntu/ubuntu18%E5%AE%89%E8%A3%85ROS1%E5%92%8CROS2/","excerpt":"","text":"一、安装ROS11、添加源1sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; 2、设置公钥1sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 3、安装1) 安装 12sudo apt updatesudo apt install ros-melodic-desktop-full 4、安装必要组件1sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential 5、初始化1sudo rosdep init 如果遇到问题，那就在 /etc/hosts后面添加 123456789101112131415161718192021222324252627282930313233343536373839199.232.28.133 raw.githubusercontent.com192.30.253.118 gist.github.com185.199.110.153 github.io151.101.113.194 github.global.ssl.fastly.net52.216.227.168 github-cloud.s3.amazonaws.com52.74.223.119 github.com199.232.28.133 avatars1.githubusercontent.com199.232.28.133 avatars2.githubusercontent.com199.232.28.133 avatars0.githubusercontent.com199.232.28.133 avatars3.githubusercontent.com199.232.28.133 user-images.githubusercontent.com199.232.28.133 avatars.githubusercontent.com199.232.28.133 github.map.fastly.net199.232.28.133 avatars7.githubusercontent.com54.239.31.69 aws.amazon.com54.239.30.25 console.aws.amazon.com54.239.96.90 ap-northeast-1.console.aws.amazon.com54.240.226.81 ap-southeast-1.console.aws.amazon.com54.240.193.125 ap-southeast-2.console.aws.amazon.com54.239.54.102 eu-central-1.console.aws.amazon.com177.72.244.194 sa-east-1.console.aws.amazon.com176.32.114.59 eu-west-1.console.aws.amazon.com54.239.31.128 us-west-1.console.aws.amazon.com54.240.254.230 us-west-2.console.aws.amazon.com54.239.38.102 s3-console-us-standard.console.aws.amazon.com54.231.49.3 s3.amazonaws.com52.219.0.4 s3-ap-northeast-1.amazonaws.com54.231.242.170 s3-ap-southeast-1.amazonaws.com54.231.251.21 s3-ap-southeast-2.amazonaws.com54.231.193.37 s3-eu-central-1.amazonaws.com52.218.16.140 s3-eu-west-1.amazonaws.com52.92.72.2 s3-sa-east-1.amazonaws.com54.231.236.6 s3-us-west-1.amazonaws.com54.231.168.160 s3-us-west-2.amazonaws.com52.216.80.48 github-cloud.s3.amazonaws.com54.231.40.3 github-com.s3.amazonaws.com52.216.20.171 github-production-release-asset-2e65be.s3.amazonaws.com52.216.228.168 github-production-user-asset-6210df.s3.amazonaws.com 接着修改/etc/resolv.conf 在其后增加 12nameserver 8.8.8.8nameserver 8.8.4.4 再次执行 sudo rosdep init 5、update根据提示执行 1rosdep update 可能会显示报错 read operation timed out，原因是raw.githubusercontent.com网站被墙掉了，解决如下： 1sudo cp -r ../ros_github/ /etc/ros/ 1) 修改路径Python配置路径 1sudo gedit /usr/lib/python2.7/dist-packages/rosdistro/__init__.py 注释第68行路径代码，然后改为 file:///etc/ros/ros_github/index-v4.yaml，如下图： 1) 修改20-default路径 改为下面的路径： 12345678sudo gedit /etc/ros/rosdep/sources.list.d/20-default.listyaml file:///etc/ros/ros_github/osx-homebrew.yaml osx#genericyaml file:///etc/ros/ros_github/base.yamlyaml file:///etc/ros/ros_github/python.yamlyaml file:///etc/ros/ros_github/ruby.yamlgbpdistro file:///etc/ros/ros_github/fuerte.yaml fuerte 再次执行 rosdep update 三、安装ROS21、设置编码123sudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8export LANG=en_US.UTF-8 2、更新软件源1234sudo apt update &amp;&amp; sudo apt install curl gnupg2 lsb-releasecurl http://repo.ros2.org/repos.key | sudo apt-key add -sudo sh -c &#x27;echo &quot;deb [arch=amd64,arm64] http://packages.ros.org/ros2/ubuntu `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros2-latest.list&#x27; 3、安装1sudo apt install ros-dashing-desktop 4、安装其他工具1234567sudo apt install python3-argcompletesource /opt/ros/dashing/setup.bashsudo apt updatesudo apt install ros-dashing-ros1-bridge 3、配置ROS1和ROS2共存界面1234567891011121314#source /opt/ros/melodic/setup.bash#source /opt/ros/dashing/setup.bash# ROS 1.0 melodic or ROS 2.0 Dashingecho Hello alvin! ROS 1.0 or ROS 2.0? 1=Melodic 2=Dashing read ROSif (($ROS==1));thensource /opt/ros/melodic/setup.bashecho &quot;Melodic&quot;elif (($ROS==2));thensource /opt/ros/dashing/setup.bashecho &quot;Dashing&quot;elseecho &quot;Non-ROS&quot;fi","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"设计模式:23--访问者模式","slug":"designPatter/设计模式-23-访问者模式","date":"2022-10-15T14:21:29.000Z","updated":"2022-10-21T05:56:56.309Z","comments":true,"path":"2022/10/15/designPatter/设计模式-23-访问者模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-23-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。 2、应用场景3、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:22--模板方法模式","slug":"designPatter/设计模式-22-模板方法模式","date":"2022-10-15T14:21:07.000Z","updated":"2022-10-21T05:53:20.860Z","comments":true,"path":"2022/10/15/designPatter/设计模式-22-模板方法模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-22-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法的某些特定步骤 2、应用场景一个操作的步骤稳定，而具体细节的改变延迟的子类 3、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:21--策略模式","slug":"designPatter/设计模式-21-策略模式","date":"2022-10-15T14:20:44.000Z","updated":"2022-10-21T05:57:03.557Z","comments":true,"path":"2022/10/15/designPatter/设计模式-21-策略模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-21-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。 2、应用场景3、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:20--状态模式","slug":"designPatter/设计模式-20-状态模式","date":"2022-10-15T14:20:27.000Z","updated":"2022-10-21T05:52:35.500Z","comments":true,"path":"2022/10/15/designPatter/设计模式-20-状态模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-20-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。 2、应用场景一个对象的内部状态改变时，他的行为剧烈的变化。 3、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:19--观察者模式","slug":"designPatter/设计模式-19-观察者模式","date":"2022-10-15T14:20:06.000Z","updated":"2022-10-21T05:57:20.101Z","comments":true,"path":"2022/10/15/designPatter/设计模式-19-观察者模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-19-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。 2、应用场景3、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:18--备忘录模式","slug":"designPatter/设计模式-18-备忘录模式","date":"2022-10-15T14:19:47.000Z","updated":"2022-10-21T05:57:22.825Z","comments":true,"path":"2022/10/15/designPatter/设计模式-18-备忘录模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-18-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 2、应用场景3、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:17--中介模式","slug":"designPatter/设计模式-17-中介模式","date":"2022-10-15T14:19:32.000Z","updated":"2022-10-21T05:57:26.293Z","comments":true,"path":"2022/10/15/designPatter/设计模式-17-中介模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-17-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念用一个中介对象封装一些列的对象交互。 2、应用场景3、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:16--迭代模式","slug":"designPatter/设计模式-16-迭代模式","date":"2022-10-15T14:19:03.000Z","updated":"2022-10-21T05:50:41.411Z","comments":true,"path":"2022/10/15/designPatter/设计模式-16-迭代模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-16-%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示 2、应用场景迭代。 3、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:15--解释器模式","slug":"designPatter/设计模式-15-解释器模式","date":"2022-10-15T14:18:43.000Z","updated":"2022-10-21T05:57:30.665Z","comments":true,"path":"2022/10/15/designPatter/设计模式-15-解释器模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-15-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 2、应用场景3、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class Variable;class Context&#123;public: void registerVariable(Variable *var, int value) &#123; m_map.insert(&#123; var, value &#125;); &#125; int lookUpValue(Variable *var) &#123; auto itor = m_map.find(var); if (itor != m_map.end()) &#123; return itor-&gt;second; &#125; return 0; &#125;private: std::unordered_map&lt;Variable *, int&gt; m_map;&#125;;class Expression&#123;public: virtual ~Expression() &#123;&#125; virtual int interpret(Context *ctx) = 0;&#125;;class Variable : public Expression&#123;public: virtual int interpret(Context *ctx) &#123; return ctx-&gt;lookUpValue(this); &#125;&#125;;class Constant : public Expression&#123;public: Constant(int value) : m_value(value) &#123;&#125; virtual int interpret(Context *ctx) override &#123; return m_value; &#125;private: int m_value;&#125;;class Add : public Expression&#123;public: Add(Expression *left, Expression *right) : m_left(left), m_right(right) &#123;&#125; virtual int interpret(Context *ctx) override &#123; return m_left-&gt;interpret(ctx) + m_right-&gt;interpret(ctx); &#125;private: Expression *m_left, *m_right;&#125;;class Sub : public Expression&#123;public: Sub(Expression *left, Expression *right) : m_left(left), m_right(right) &#123;&#125; virtual int interpret(Context *ctx) override &#123; return m_left-&gt;interpret(ctx) - m_right-&gt;interpret(ctx); &#125;private: Expression *m_left, *m_right;&#125;;class Mul : public Expression&#123;public: Mul(Expression *left, Expression *right) : m_left(left), m_right(right) &#123;&#125; virtual int interpret(Context *ctx) override &#123; return m_left-&gt;interpret(ctx) * m_right-&gt;interpret(ctx); &#125;private: Expression *m_left, *m_right;&#125;;class Div : public Expression&#123;public: Div(Expression *left, Expression *right) : m_left(left), m_right(right) &#123;&#125; virtual int interpret(Context *ctx) override &#123; assert(m_right-&gt;interpret(ctx) != 0); return m_left-&gt;interpret(ctx) / m_right-&gt;interpret(ctx); &#125;private: Expression *m_left, *m_right;&#125;;int main()&#123; Context ctx; Variable a; Variable b; Constant c(1024); ctx.registerVariable(&amp;a, 22); ctx.registerVariable(&amp;b, 11); Expression *e1 = new Mul(&amp;a, &amp;b); //242 Expression *e2 = new Div(&amp;a, &amp;b); //1 Expression *e3 = new Add(e2, &amp;c); //1025 Expression *e = new Sub(e1, e3); std::cout &lt;&lt; e-&gt;interpret(&amp;ctx) &lt;&lt; std::endl; delete e1, e2, e3, e; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:14--命令模式","slug":"designPatter/设计模式-14-命令模式","date":"2022-10-15T14:18:23.000Z","updated":"2022-10-21T05:49:39.071Z","comments":true,"path":"2022/10/15/designPatter/设计模式-14-命令模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-14-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。 2、应用场景将命令者与执行者完全解耦。 3、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class ICommand&#123;public: virtual ~ICommand() &#123;&#125; virtual void execute() = 0;&#125;;class Drawable&#123;public: virtual ~Drawable() &#123;&#125; virtual void draw(int x, int y) = 0;&#125;;class MacroCommand : public ICommand&#123;public: ~MacroCommand() &#123; clear(); &#125; virtual void execute() override &#123; for (auto cmd : m_commandList) &#123; cmd-&gt;execute(); &#125; &#125; void addCommand(ICommand *cmd) &#123; m_commandList.push_back(cmd); &#125; void clear() &#123; for (auto cmd : m_commandList) &#123; delete cmd; &#125; m_commandList.clear(); &#125; void undo() &#123; if (!m_commandList.empty()) &#123; auto cmd = m_commandList.back(); delete cmd; m_commandList.pop_back(); &#125; &#125;private: std::vector&lt;ICommand *&gt; m_commandList;&#125;;class DrawCommand : public ICommand&#123;public: DrawCommand(int x, int y, Drawable *drawable) : m_x(x), m_y(y), m_drawable(drawable) &#123;&#125; virtual void execute() override &#123; m_drawable-&gt;draw(m_x, m_y); &#125;private: int m_x; int m_y; Drawable *m_drawable;&#125;;class DrawCanvas : public Drawable&#123;public: DrawCanvas(MacroCommand *macroCommand) : m_macroCommand(macroCommand) &#123;&#125; virtual void draw(int x, int y) override &#123; std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; std::endl; &#125; void paint() &#123; m_macroCommand-&gt;execute(); &#125;private: MacroCommand *m_macroCommand;&#125;;int main()&#123; MacroCommand macroCommand; DrawCanvas canvas(&amp;macroCommand); macroCommand.addCommand(new DrawCommand(1, 2, &amp;canvas)); canvas.draw(20, 10); canvas.paint(); return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:13--责任链模式","slug":"designPatter/设计模式-13-责任链模式","date":"2022-10-15T14:18:06.000Z","updated":"2022-10-21T05:57:35.517Z","comments":true,"path":"2022/10/15/designPatter/设计模式-13-责任链模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-13-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系 2、应用场景3、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class Trouble &#123;public: Trouble(int number) : m_number(number) &#123;&#125; int getNumber() const &#123; return m_number; &#125; std::string toString() const &#123; return &quot;[ Trouble &quot; + std::to_string(m_number) + &quot; ]&quot;; &#125;private: int m_number;&#125;;class Support &#123;public: virtual ~Support() &#123;&#125; Support(const std::string &amp;name) : m_name(name) &#123;&#125; Support *setNext(Support *next) &#123; m_next = next; return next; &#125; void support(Trouble *trouble) &#123; if (resolve(trouble)) done(trouble); else if (m_next) m_next-&gt;support(trouble); else fail(trouble); &#125; std::string toString() const &#123; return &quot;[&quot; + m_name + &quot;]&quot;; &#125; virtual bool resolve(Trouble *trouble) = 0;protected: void done(Trouble *trouble) &#123; std::cout &lt;&lt; trouble-&gt;toString() &lt;&lt; &quot; is solved by &quot; &lt;&lt; toString() &lt;&lt; std::endl; &#125; void fail(Trouble *trouble) &#123; std::cout &lt;&lt; trouble-&gt;toString() &lt;&lt; &quot; cannot be resolved.&quot; &lt;&lt; std::endl; &#125;private: std::string m_name; Support *m_next = nullptr;&#125;;class NoSupport : public Support &#123;public: using Support::Support; virtual bool resolve(Trouble *trouble) override &#123; return false; &#125;&#125;;class OddSupport : public Support &#123;public: using Support::Support; virtual bool resolve(Trouble *trouble) override &#123; return (trouble-&gt;getNumber() % 2 == 0); &#125;&#125;;class LimitSupport : public Support &#123;public: LimitSupport(const std::string &amp;name, int limit) : Support(name), m_limit(limit)&#123;&#125; virtual bool resolve(Trouble *trouble) override &#123; return (trouble-&gt;getNumber() &lt;= m_limit); &#125;private: int m_limit;&#125;;class SpecialSupport : public Support &#123;public: SpecialSupport(const std::string &amp;name, int num) : Support(name), m_num (num) &#123;&#125; virtual bool resolve(Trouble *trouble) override &#123; return (trouble-&gt;getNumber() == m_num); &#125; private: int m_num;&#125;;int main()&#123; Support *s1 = new NoSupport(&quot;Alance&quot;); Support *s2 = new LimitSupport(&quot;Bob&quot;, 30); Support *s3 = new OddSupport(&quot;Charlie&quot;); Support *s4 = new SpecialSupport(&quot;David&quot;, 55); s1-&gt;setNext(s2)-&gt;setNext(s3)-&gt;setNext(s4); for (int i = 0; i &lt; 100; ++i) &#123; Trouble t(i); s1-&gt;support(&amp;t); &#125; delete s1; delete s2; delete s3; delete s4; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:12--代理模式","slug":"designPatter/设计模式-12-代理模式","date":"2022-10-15T14:17:42.000Z","updated":"2022-10-21T05:57:39.993Z","comments":true,"path":"2022/10/15/designPatter/设计模式-12-代理模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-12-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念为其他对象提供一种代理以控制对这个对象的访问 2、应用场景3、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class Printable &#123;public: virtual ~Printable() &#123;&#125; virtual void setPrinterName(const std::string &amp;name) = 0; virtual const std::string &amp;getPrinterName() const = 0; virtual void print() = 0;&#125;;class Printer : public Printable &#123;public: Printer(const std::string &amp;name) : m_name(name) &#123; heavyJob(); &#125; virtual void setPrinterName(const std::string &amp;name) override &#123; m_name = name; &#125; virtual const std::string &amp;getPrinterName() const &#123; return m_name; &#125; void print() override &#123; std::cout &lt;&lt; __FUNCTION__ &lt;&lt; getPrinterName() &lt;&lt; std::endl; &#125;private: void heavyJob() &#123; std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot; start &quot; &lt;&lt; std::endl; for (int i = 0; i &lt; 5; ++i) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(300)); &#125; std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot; end &quot; &lt;&lt; std::endl; &#125;private: std::string m_name;&#125;;class PrinterProxy : public Printable &#123;public: PrinterProxy(const std::string &amp;name) : m_name(name) &#123;&#125; ~PrinterProxy() &#123; delete m_printer; &#125; virtual void setPrinterName(const std::string &amp;name) override &#123; if (m_printer != nullptr) &#123; m_printer-&gt;setPrinterName(name); &#125; m_name = name; &#125; virtual const std::string &amp;getPrinterName() const override &#123; return m_name; &#125; void print() override &#123; if (nullptr == m_printer)&#123; m_printer = new Printer(m_name); &#125; m_printer-&gt;print(); &#125;private: Printer *m_printer = nullptr; std::string m_name;&#125;;int main()&#123; Printable *p = new PrinterProxy(&quot;123&quot;); std::cout &lt;&lt; p-&gt;getPrinterName() &lt;&lt; std::endl; p-&gt;setPrinterName(&quot;456&quot;); std::cout &lt;&lt; p-&gt;getPrinterName() &lt;&lt; std::endl; p-&gt;print(); p-&gt;setPrinterName(&quot;789&quot;); p-&gt;print(); delete p; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:11--享元模式","slug":"designPatter/设计模式-11-享元模式","date":"2022-10-15T14:17:27.000Z","updated":"2022-10-21T05:57:42.773Z","comments":true,"path":"2022/10/15/designPatter/设计模式-11-享元模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-11-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。 2、应用场景3、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;static const char *strList[] = &#123; &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;......##........\\n&quot; &quot;..######........\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;..##########....\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..........##....\\n&quot; &quot;......####......\\n&quot; &quot;....##..........\\n&quot; &quot;..##............\\n&quot; &quot;..##########....\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..........##....\\n&quot; &quot;......####......\\n&quot; &quot;..........##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;........##......\\n&quot; &quot;......####......\\n&quot; &quot;....##..##......\\n&quot; &quot;..##....##......\\n&quot; &quot;..########......\\n&quot; &quot;........##......\\n&quot; &quot;......######....\\n&quot; &quot;................\\n&quot;, &quot;..##########....\\n&quot; &quot;..##............\\n&quot; &quot;..##............\\n&quot; &quot;..########......\\n&quot; &quot;..........##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##............\\n&quot; &quot;..########......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;..##########....\\n&quot; &quot;..##......##....\\n&quot; &quot;..........##....\\n&quot; &quot;........##......\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....########....\\n&quot; &quot;..........##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;................\\n&quot; &quot;................\\n&quot; &quot;................\\n&quot; &quot;................\\n&quot; &quot;..##########....\\n&quot; &quot;................\\n&quot; &quot;................\\n&quot; &quot;................\\n&quot; &#125;;class BigChar&#123;public: BigChar(int order) : m_char(strList[order % 11]) &#123;&#125; void show() &#123; std::cout &lt;&lt; m_char &lt;&lt; std::endl; &#125;private: const char *m_char;&#125;;class BigCharFactory&#123;public: ~BigCharFactory() &#123; for (auto i : m_map) &#123; delete i.second; &#125; m_map.clear(); &#125; BigChar *getBigChar(int order) &#123; BigChar *b = nullptr; int tOrder = order % 11; auto it = m_map.find(tOrder); if (it == m_map.end()) &#123; b = new BigChar(tOrder); m_map.insert(&#123; tOrder, b &#125;); return b; &#125; else &#123; return it-&gt;second; &#125; &#125;private: std::unordered_map&lt;int, BigChar *&gt; m_map;&#125;;int main()&#123; BigCharFactory f; for (int i = 0; i &lt; 20; ++i) &#123; for (int j = 0; j &lt; 2; ++j) &#123; BigChar *b = f.getBigChar(i); std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; std::endl; b-&gt;show(); &#125; &#125; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:10--外观模式","slug":"designPatter/设计模式-10-外观模式","date":"2022-10-15T14:16:48.000Z","updated":"2022-10-21T05:57:45.621Z","comments":true,"path":"2022/10/15/designPatter/设计模式-10-外观模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-10-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念为子系统中的一组接口提供一致的界面，fa?ade提供了一高层接口，这个接口使得子系统更容易使用。 2、应用场景3、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;using namespace std;class DataBase &#123;public: ~DataBase() = default; static DataBase &amp;GetInstance() &#123; static DataBase db; return db; &#125; std::string getNameByEmail(const std::string &amp;email) const &#123; auto it = m_map.find(email); if (it != m_map.end()) return it-&gt;second; else return &#123;&#125;; &#125;protected: DataBase(const DataBase &amp;) = delete; DataBase(DataBase &amp;&amp;) = delete; DataBase &amp;operator=(const DataBase &amp;) = delete; DataBase &amp;operator=(DataBase &amp;&amp;) = delete;private: DataBase() &#123;&#125;private: std::unordered_map&lt;std::string, std::string&gt; m_map&#123; &#123; &quot;zhangsan@zhangsan.com&quot;, &quot;zhangsan&quot; &#125;, &#123; &quot;lisi@lisi.com&quot;, &quot;lisi&quot; &#125;, &#123; &quot;wangwu@wangwu.com&quot;, &quot;wangwu&quot; &#125; &#125;;&#125;;class HtmlWriter&#123;public: void title(const std::string &amp;title) &#123; m_ss &lt;&lt; &quot;&lt;html&gt;&quot; &lt;&lt; &quot;&lt;head&gt;&quot; &lt;&lt; &quot;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&quot; &lt;&lt; &quot;&lt;/head&gt;&quot; &lt;&lt; &quot;&lt;body&gt;\\n&quot; &lt;&lt; &quot;&lt;h1&gt;&quot; + title + &quot;&lt;/h1&gt;\\n&quot;; &#125; void paragraph(const std::string &amp;msg) &#123; m_ss &lt;&lt; &quot;&lt;p&gt;&quot; + msg + &quot;&lt;/p&gt;\\n&quot;; &#125; void link(const std::string &amp;herf, const std::string &amp;caption) &#123; paragraph(&quot;&lt;a herf=\\&quot;&quot; + herf + &quot;\\&quot;&gt;&quot; + caption + &quot;&lt;/a&gt;&quot;); &#125; void mailto(const std::string &amp;mailAddr, const std::string &amp;userName)&#123; link(&quot;mailto:&quot; + mailAddr, userName); &#125; void close() &#123; m_ss &lt;&lt; &quot;&lt;/body&gt;&quot; &lt;&lt; &quot;&lt;/html&gt;\\n&quot;; &#125; std::string toString() const &#123; return m_ss.str(); &#125;private: std::stringstream m_ss;&#125;;class PageMaker&#123;public: ~PageMaker() = default; PageMaker(const PageMaker &amp;) = delete; PageMaker(PageMaker &amp;&amp;) = delete; PageMaker &amp;operator=(const PageMaker &amp;) = delete; PageMaker &amp;operator=(PageMaker &amp;&amp;) = delete; static PageMaker &amp;GetInstance() &#123; static PageMaker pm; return pm; &#125; void makeWelcomePage(const std::string &amp;mailAddr) &#123; auto name = DataBase::GetInstance().getNameByEmail(mailAddr); HtmlWriter writer; writer.title(&quot;Welcome to &quot; + name + &quot;&#x27;s page!&quot;); writer.paragraph(name + u8&quot;欢迎来到&quot; + name + u8&quot;的主页.&quot;); writer.paragraph(u8&quot;等着你的邮件哦！&quot;); writer.mailto(mailAddr, name); writer.close(); std::cout &lt;&lt; writer.toString() &lt;&lt; std::endl; &#125;protected: PageMaker() &#123;&#125;private:&#125;;int main()&#123; assert(DataBase::GetInstance().getNameByEmail(&quot;&quot;).empty()); PageMaker::GetInstance().makeWelcomePage(&quot;zhangsan@zhangsan.com&quot;); return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:09--装饰模式","slug":"designPatter/设计模式-09-装饰模式","date":"2022-10-15T14:16:29.000Z","updated":"2022-10-21T05:57:49.037Z","comments":true,"path":"2022/10/15/designPatter/设计模式-09-装饰模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-09-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。 2、应用场景3、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;class IDisplay &#123;public: virtual ~IDisplay() &#123;&#125; virtual int getRows() const = 0; virtual int getColumns() const = 0; virtual std::string getRow(int index) const = 0; void show() &#123; int r = getRows(); for (int i = 0; i &lt; r; ++i) &#123; std::cout &lt;&lt; getRow(i) &lt;&lt; std::endl; &#125; &#125;&#125;;class StringDisplay : public IDisplay &#123;public: StringDisplay(const std::string &amp;str) : m_str(str) &#123;&#125; virtual int getRows() const override &#123; return 1; &#125; virtual int getColumns() const override &#123; return static_cast&lt;int&gt;(m_str.length()); &#125; virtual std::string getRow(int index) const override &#123; if (index == 0) return m_str; else return &#123;&#125;; &#125;private: std::string m_str;&#125;;class Border : public IDisplay &#123;public: Border(IDisplay *display) : m_display(display) &#123;&#125; virtual ~Border() &#123; delete m_display; &#125;protected: IDisplay *m_display;&#125;;class FullBorder : public Border &#123;public: FullBorder(IDisplay *display) : Border(display) &#123;&#125; virtual int getRows() const override &#123; return 1 + m_display-&gt;getRows() + 1; &#125; virtual int getColumns() const override &#123; return 1 + m_display-&gt;getColumns() + 1; &#125; virtual std::string getRow(int index) const override &#123; if (index == 0) return &quot;+&quot; + makeLine(&#x27;-&#x27;, m_display-&gt;getColumns()) + &quot;+&quot;; else if (index == m_display-&gt;getRows() + 1) return &quot;+&quot; + makeLine(&#x27;-&#x27;, m_display-&gt;getColumns()) + &quot;+&quot;; else return &quot;|&quot; + m_display-&gt;getRow(index - 1) + &quot;|&quot;; &#125;private: std::string makeLine(char ch, int count) const &#123; std::string str; str.resize(count, ch); return str; &#125;&#125;;class SideBorder : public Border &#123;public: SideBorder(IDisplay *display, const char &amp;borderChar) : Border(display), m_borderChar(borderChar) &#123;&#125; virtual int getRows() const override &#123; return m_display-&gt;getRows(); &#125; virtual int getColumns() const override &#123; return 1 + m_display-&gt;getColumns() + 1; &#125; virtual std::string getRow(int index) const override &#123; return m_borderChar + m_display-&gt;getRow(index) + m_borderChar; &#125;private: char m_borderChar;&#125;;int main()&#123; IDisplay *d1 = new StringDisplay(&quot;Hello&quot;); assert(d1-&gt;getRow(-1).empty()); IDisplay *d2 = new SideBorder(d1, &#x27;#&#x27;); IDisplay *d3 = new FullBorder(d2); d1-&gt;show(); d2-&gt;show(); d3-&gt;show(); IDisplay *d4 = new SideBorder(new FullBorder(new FullBorder(new SideBorder(new FullBorder(new StringDisplay(&quot;Hello,World&quot;)), &#x27;*&#x27;))), &#x27;/&#x27;); d4-&gt;show(); delete d1; delete d4; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:08--组合模式","slug":"designPatter/设计模式-08-组合模式","date":"2022-10-15T14:16:07.000Z","updated":"2022-10-21T05:57:51.833Z","comments":true,"path":"2022/10/15/designPatter/设计模式-08-组合模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-08-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性 2、应用场景3、UML 二、案例1、案例1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class Component &#123;public: Component()&#123;&#125; Component(string iName) &#123; this-&gt;name = iName; &#125; virtual ~Component()&#123;&#125; virtual void add(Component*) = 0; virtual void remove(Component*) = 0; virtual Component* getChild(int) = 0; virtual void operation() = 0; string getName() &#123; return name; &#125;private: string name;&#125;;class Office : public Component &#123;public: Office(string iName) &#123; this-&gt;name = iName; &#125; Office() &#123;&#125; void add(Component* c) &#123; printf(&quot;not support!\\n&quot;); &#125; void remove(Component* c) &#123; printf(&quot;not support!\\n&quot;); &#125; Component* getChild(int i) &#123; printf(&quot;not support!\\n&quot;); return NULL; &#125;private: string name;&#125;;class AdminOffice :public Office &#123;public: AdminOffice(string iName) &#123; this-&gt;name = iName; &#125; void operation() &#123; printf(&quot;-----Administration Office:%s\\n&quot;, name.c_str()); &#125;private: string name;&#125;;class DeanOffice :public Office &#123;public: DeanOffice(string iName) &#123; this-&gt;name = iName; &#125; void operation() &#123; printf(&quot;-----Dean Office:%s\\n&quot;, name.c_str()); &#125;private: string name;&#125;;class SubComponent :public Component &#123;public: SubComponent(string iName) &#123; this-&gt;name = iName; &#125; void add(Component *c) &#123; componentList.push_back(c); &#125; void remove(Component *c) &#123; for (int i = 0; i &lt; componentList.size(); i++) &#123; if (componentList[i]-&gt;getName() == c-&gt;getName()) &#123; componentList.erase(componentList.begin() + i); break; &#125; &#125; &#125; Component* getChild(int i) &#123; return (Component*)componentList[i]; &#125; void operation() &#123; printf(&quot;%s\\n&quot;, this-&gt;name.c_str()); for (int i = 0; i &lt; componentList.size(); i++) &#123; ((Component*)componentList[i])-&gt;operation(); &#125; &#125;private: string name; vector&lt;Component*&gt;componentList;&#125;;int main()&#123; Component *head, *sichuanBranch, *cdBranch, *myBranch, *office1, *office2, *office3, *office4, *office5, *office6, *office7, *office8; head = new SubComponent(&quot;总部&quot;); sichuanBranch = new SubComponent(&quot;四川分部&quot;); office1 = new AdminOffice(&quot;行政办公室&quot;); office2 = new DeanOffice(&quot;教务办公室&quot;); cdBranch = new SubComponent(&quot;成都分部&quot;); myBranch = new SubComponent(&quot;绵阳分部&quot;); office3 = new AdminOffice(&quot;行政办公室&quot;); office4 = new DeanOffice(&quot;教务办公室&quot;); office5 = new AdminOffice(&quot;行政办公室&quot;); office6 = new DeanOffice(&quot;教务办公室&quot;); office7 = new AdminOffice(&quot;行政办公室&quot;); office8 = new DeanOffice(&quot;教务办公室&quot;); cdBranch-&gt;add(office5); cdBranch-&gt;add(office6); myBranch-&gt;add(office7); myBranch-&gt;add(office8); sichuanBranch-&gt;add(office3); sichuanBranch-&gt;add(office4); sichuanBranch-&gt;add(cdBranch); sichuanBranch-&gt;add(myBranch); head-&gt;add(office1); head-&gt;add(office2); head-&gt;add(sichuanBranch); head-&gt;operation(); delete head; delete sichuanBranch; delete cdBranch; delete myBranch; delete office1; delete office2; delete office3; delete office4; delete office5; delete office6; delete office7; delete office8; return 0;&#125; 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;class Entry &#123;public: virtual ~Entry() &#123;&#125; virtual std::string getName() const = 0; virtual int getSize() const = 0; virtual void addEntryy(Entry *entry) &#123;&#125; virtual void printList(const std::string &amp;str) = 0; void printList() &#123; printList(&quot;&quot;); &#125; std::string toString() const &#123; return getName() + &quot; (&quot; + std::to_string(getSize()) + &quot;)&quot;; &#125;&#125;;class File : public Entry &#123;public: File(const std::string &amp;name, int size) : m_name(name), m_size(size) &#123;&#125; virtual std::string getName() const override &#123; return m_name; &#125; virtual int getSize() const override &#123; return m_size; &#125; virtual void printList(const std::string &amp;str) override &#123; std::cout &lt;&lt; str &lt;&lt; &quot;/&quot; &lt;&lt; toString() &lt;&lt; std::endl; &#125;private: std::string m_name; int m_size;&#125;;class Directory : public Entry &#123;public: Directory(const std::string &amp;name) : m_name(name) &#123;&#125; ~Directory() &#123; for (auto it : m_dirs) &#123; delete it; &#125; m_dirs.clear(); &#125; virtual std::string getName() const override &#123; return m_name; &#125; virtual int getSize() const &#123; int size = 0; for (auto it : m_dirs) &#123; size += it-&gt;getSize(); &#125; return size; &#125; virtual void addEntryy(Entry *entry) override &#123; m_dirs.push_back(entry); &#125; virtual void printList(const std::string &amp;str) override &#123; std::cout &lt;&lt; str &lt;&lt; &quot;/&quot; &lt;&lt; toString() &lt;&lt; std::endl; for (auto it : m_dirs) &#123; it-&gt;printList(str + &quot;/&quot; + m_name); &#125; &#125;private: std::string m_name; std::vector&lt;Entry *&gt; m_dirs;&#125;;int main()&#123; Directory *root = new Directory(&quot;root&quot;); Directory *bin = new Directory(&quot;bin&quot;); Directory *tmp = new Directory(&quot;tmp&quot;); Directory *usr = new Directory(&quot;usr&quot;); root-&gt;addEntryy(bin); root-&gt;addEntryy(tmp); root-&gt;addEntryy(usr); bin-&gt;addEntryy(new File(&quot;vi&quot;, 3000)); bin-&gt;addEntryy(new File(&quot;latex&quot;, 2000)); static_cast&lt;Entry *&gt;(root)-&gt;printList(); Directory *yuki = new Directory(&quot;yuki&quot;); Directory *hanako = new Directory(&quot;hanako&quot;); Directory *tomura = new Directory(&quot;tomura&quot;); usr-&gt;addEntryy(yuki); usr-&gt;addEntryy(hanako); usr-&gt;addEntryy(tomura); yuki-&gt;addEntryy(new File(&quot;diary.html&quot;, 100)); hanako-&gt;addEntryy(new File(&quot;memo.tex&quot;, 1024)); tomura-&gt;addEntryy(new File(&quot;junk.mail&quot;, 40)); static_cast&lt;Entry *&gt;(root)-&gt;printList(); // for test coverage &#123; File *f = new File(&quot;123.txt&quot;, 1); f-&gt;addEntryy(root); f-&gt;printList(&quot;&quot;); delete f; &#125; &#123; yuki-&gt;printList(&quot;&quot;); &#125; &#123; File *f = new File(&quot;123.txt&quot;, 1); Entry *e = new Directory(&quot;test&quot;); e-&gt;addEntryy(f); e-&gt;printList(&quot;&quot;); e-&gt;toString(); delete e; &#125; delete root; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:07--桥接模式","slug":"designPatter/设计模式-07-桥接模式","date":"2022-10-15T14:15:47.000Z","updated":"2022-10-21T05:57:54.617Z","comments":true,"path":"2022/10/15/designPatter/设计模式-07-桥接模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-07-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念将抽象部分与它的实现部分相分离，使他们可以独立的变化 2、应用场景3、UML 二、案例1、案例11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;class Game &#123;public: Game()&#123;&#125; virtual ~Game()&#123;&#125; virtual void play() = 0;private:&#125;;class GameA : public Game &#123;public: GameA()&#123;&#125; void play()&#123; printf(&quot;Jungle play gameA\\n&quot;); &#125;&#125;;class GameB : public Game &#123;public: GameB()&#123;&#125; void play()&#123; printf(&quot;Jungle play gameB\\n&quot;); &#125;&#125;;class Phone &#123;public: Phone()&#123;&#125; virtual ~Phone()&#123;&#125; virtual void setupGame(Game *igame) = 0; virtual void play() = 0;private: Game *game;&#125;;class PhoneA:public Phone &#123;public: PhoneA()&#123;&#125; void setupGame(Game *igame)&#123; this-&gt;game = igame; &#125; void play()&#123; this-&gt;game-&gt;play(); &#125;private: Game *game;&#125;;class PhoneB :public Phone &#123;public: PhoneB()&#123;&#125; void setupGame(Game *igame)&#123; this-&gt;game = igame; &#125; void play()&#123; this-&gt;game-&gt;play(); &#125;private: Game *game;&#125;;int main()&#123; Game *game; Phone *phone; phone = new PhoneA(); game = new GameA(); phone-&gt;setupGame(game); phone-&gt;play(); printf(&quot;++++++++++++++++++++++++++++++++++\\n&quot;); delete game; game = new GameB(); phone-&gt;setupGame(game); phone-&gt;play(); delete phone; delete game; return 0;&#125; 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;class IDisplayImpl &#123;public: virtual ~IDisplayImpl() &#123;&#125; virtual void rawOpen() = 0; virtual void rawPrint() = 0; virtual void rawClose() = 0;&#125;;class Display &#123;public: virtual ~Display() &#123;&#125; Display(IDisplayImpl *impl) : m_pImpl(impl) &#123;&#125; virtual void open() &#123; m_pImpl-&gt;rawOpen(); &#125; virtual void print() &#123; m_pImpl-&gt;rawPrint(); &#125; virtual void close() &#123; m_pImpl-&gt;rawClose(); &#125; void display() &#123; open(); print(); close(); &#125;private: IDisplayImpl *m_pImpl;&#125;;class CountDisplay : public Display &#123;public: using Display::Display; void mulitDisplay(unsigned int count) &#123; open(); for (unsigned int i = 0; i &lt; count; ++i) print(); close(); &#125;&#125;;class StringDisplayImpl : public IDisplayImpl&#123;public: StringDisplayImpl(const std::string &amp;str) : m_str(str) &#123;&#125; virtual void rawOpen() override &#123; printLine(); &#125; virtual void rawPrint() override &#123; cout &lt;&lt; &quot;|&quot; &lt;&lt; m_str &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; &#125; virtual void rawClose() override &#123; printLine(); &#125;private: void printLine() &#123; cout &lt;&lt; &quot;+&quot;; for (int i = 0; i &lt; m_str.length(); ++i) cout &lt;&lt; &quot;-&quot;; cout &lt;&lt; &quot;+&quot; &lt;&lt; endl; &#125;private: std::string m_str;&#125;;int main()&#123; std::shared_ptr&lt;IDisplayImpl&gt; impl1(new StringDisplayImpl(&quot;Hello, China&quot;)); std::shared_ptr&lt;Display&gt; d1(new Display(impl1.get())); std::shared_ptr&lt;IDisplayImpl&gt; impl2(new StringDisplayImpl(&quot;Hello, Tao&quot;)); std::shared_ptr&lt;Display&gt; d2(new CountDisplay(impl2.get())); std::shared_ptr&lt;IDisplayImpl&gt; impl3(new StringDisplayImpl(&quot;Hello,Universe&quot;)); std::shared_ptr&lt;CountDisplay&gt; d3(new CountDisplay(impl3.get())); d1-&gt;display(); d2-&gt;display(); d3-&gt;display(); d3-&gt;mulitDisplay(4); return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:06--适配器模式","slug":"designPatter/设计模式-06-适配器模式","date":"2022-10-15T14:15:26.000Z","updated":"2022-10-21T05:57:58.977Z","comments":true,"path":"2022/10/15/designPatter/设计模式-06-适配器模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-06-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。 2、应用场景3、UML 二、案例1、案例11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;class Controller &#123;public: Controller()&#123;&#125; virtual ~Controller()&#123;&#125; virtual void pathPlanning() = 0;&#125;;class DxfParser &#123;public: DxfParser()&#123;&#125; void parseFile()&#123; printf(&quot;parseFile\\n&quot;); &#125;&#125;;class PathPlanner &#123;public: PathPlanner()&#123;&#125; void calculate()&#123; printf(&quot;calculate\\n&quot;); &#125;&#125;;class Adapter:public Controller &#123;public: Adapter()&#123; dxfParser = new DxfParser(); pathPlanner = new PathPlanner(); &#125; void pathPlanning()&#123; printf(&quot;pathPlanning\\n&quot;); dxfParser-&gt;parseFile(); pathPlanner-&gt;calculate(); &#125;private: DxfParser *dxfParser; PathPlanner *pathPlanner;&#125;;int main()&#123; Controller *controller = new Adapter(); controller-&gt;pathPlanning(); delete controller; return 0;&#125; 2、案例212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;class Banner &#123;public: Banner(const std::string &amp;str) : m_str(str) &#123;&#125; void showWithParen() &#123; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; m_str &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; &#125; void showWithAster() &#123; std::cout &lt;&lt; &quot;*&quot; &lt;&lt; m_str &lt;&lt; &quot;*&quot; &lt;&lt; std::endl; &#125;private: std::string m_str;&#125;;class Painter &#123;public: virtual ~Painter() &#123;&#125; virtual void printStrong() = 0; virtual void printWeak() = 0;&#125;;class PainterBanner : public Banner, public Painter &#123;public: PainterBanner(const std::string &amp;str) : Banner(str) &#123;&#125; virtual void printStrong() override &#123; showWithParen(); &#125; virtual void printWeak() override &#123; showWithAster(); &#125;&#125;;int main()&#123; Painter *painter = new PainterBanner(std::string(&quot;HelloWorld&quot;)); painter-&gt;printStrong(); painter-&gt;printWeak(); delete painter; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:05--单例模式","slug":"designPatter/设计模式-05-单例模式","date":"2022-10-15T14:14:36.000Z","updated":"2022-10-21T05:45:06.174Z","comments":true,"path":"2022/10/15/designPatter/设计模式-05-单例模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-05-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念保证一个类只有一个实例，并提供一个访问它的全局访问点 2、应用场景一个无状态的类使用单例模式节省内存资源 3、UML 二、案例1、案例112345678910111213141516171819202122class Singleton &#123;public: static Singleton* getInstance() &#123; if (instance == NULL) &#123; m_mutex.lock(); if (instance == NULL)&#123; printf(&quot;create Singleton\\n&quot;); instance = new Singleton(); &#125; m_mutex.unlock(); &#125; return instance; &#125;private: Singleton()&#123;&#125; static Singleton* instance; static std::mutex m_mutex;&#125;;Singleton* Singleton::instance = NULL;std::mutex Singleton::m_mutex; 2、案例21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;template &lt;class T&gt;class SingleTon &#123;public: static T &amp;GetInstance() &#123; static T ins; return ins; &#125; SingleTon(const SingleTon &amp;) = delete; SingleTon &amp;operator=(const SingleTon &amp;) = delete; virtual ~SingleTon() &#123;&#125;protected: SingleTon() &#123;&#125;&#125;;class Apple : public SingleTon&lt;Apple&gt; &#123; friend SingleTon&lt;Apple&gt;;public: void show() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125; ~Apple() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125;protected: Apple() &#123;&#125;&#125;;class Orange : public SingleTon&lt;Orange&gt; &#123; friend SingleTon&lt;Orange&gt;;public: ~Orange() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125; void show() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125;protected: Orange()&#123;&#125;&#125;;int main()&#123; Apple::GetInstance().show(); cout &lt;&lt; &amp;Apple::GetInstance() &lt;&lt; endl; Apple::GetInstance().show(); cout &lt;&lt; &amp;Apple::GetInstance() &lt;&lt; endl; Orange::GetInstance().show(); Orange::GetInstance().show(); Orange::GetInstance().show(); return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:04--原型模式","slug":"designPatter/设计模式-04-原型模式","date":"2022-10-15T14:14:15.000Z","updated":"2022-10-21T05:44:45.269Z","comments":true,"path":"2022/10/15/designPatter/设计模式-04-原型模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-04-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象 2、应用场景用new创建一个对象需要非常繁琐的数据准备或者权限，可以考虑使用原型模式 3、UML 二、案例1、案例1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class WorkModel &#123;public: char *modelName; void setWorkModelName(char *iName)&#123; this-&gt;modelName = iName; &#125;&#125;;class PrototypeWork &#123;public: PrototypeWork()&#123;&#125; virtual PrototypeWork *clone() = 0;&#125;;class ConcreteWork :public PrototypeWork &#123;public: ConcreteWork()&#123;&#125; ConcreteWork(char* iName, int iIdNum, char* modelName)&#123; this-&gt;name = iName; this-&gt;idNum = iIdNum; this-&gt;workModel = new WorkModel(); this-&gt;workModel-&gt;setWorkModelName(modelName); &#125; ConcreteWork *clone()&#123; ConcreteWork *work = new ConcreteWork(); work-&gt;setName(this-&gt;name); work-&gt;setIdNum(this-&gt;idNum); work-&gt;workModel = this-&gt;workModel; return work; &#125; void setName(char* iName)&#123; this-&gt;name = iName; &#125; void setIdNum(int iIdNum)&#123; this-&gt;idNum = iIdNum; &#125; void setModel(WorkModel *iWorkModel)&#123; this-&gt;workModel = iWorkModel; &#125; void printWorkInfo()&#123; printf(&quot;name:%s\\n&quot;, this-&gt;name); printf(&quot;idNum:%d\\n&quot;, this-&gt;idNum); printf(&quot;modelName:%s\\n&quot;, this-&gt;workModel-&gt;modelName); &#125;private: char* name; int idNum; WorkModel *workModel;&#125;;int main()&#123; ConcreteWork *singleWork = new ConcreteWork(&quot;Single&quot;, 1001, &quot;Single_Model&quot;); printf(&quot;\\nSingleConcreteWork\\n&quot;); ConcreteWork *jungleWork = singleWork-&gt;clone(); printf(&quot;\\nJungleConcreteWork\\n&quot;); printf(&quot;\\njungleClone&quot;); jungleWork-&gt;setName(&quot;jungle&quot;); jungleWork-&gt;setIdNum(1002); WorkModel *jungleModel = new WorkModel(); jungleModel-&gt;setWorkModelName(&quot;Jungle_Model&quot;); jungleWork-&gt;setModel(jungleModel); printf(&quot;\\nSingleInfo\\n&quot;); singleWork-&gt;printWorkInfo(); printf(&quot;\\nJungleInfo\\n&quot;); jungleWork-&gt;printWorkInfo(); return 0;&#125; 2、案例2``` C #include &lt;iostream&gt; #include &lt;functional&gt; #include &lt;memory&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;unordered_map&gt; #include &lt;cassert&gt; using namespace std; class IProduct &#123; public: virtual ~IProduct() &#123;&#125; virtual IProduct *Clone() = 0; virtual void Use(const std::string &amp;str) = 0; &#125;; class MessageBox : public IProduct &#123; public: MessageBox(const std::string &amp;str) : m_name(str) &#123;&#125; IProduct *Clone() override &#123; return new MessageBox(m_name); &#125; void Use(const std::string &amp;str) &#123; std::cout &lt;&lt; &quot;Message box &quot; &lt;&lt; m_name &lt;&lt; &quot; &quot; &lt;&lt; str &lt;&lt; std::endl; &#125; private: std::string m_name; &#125;; class ProductMgr &#123; public: void Register(const std::string &amp;name, IProduct *pro) &#123; m_map.insert(&#123; name, pro &#125;); &#125; IProduct *Create(const std::string &amp;name) &#123; auto it = m_map.find(name); if (it != m_map.end()) return it-&gt;second-&gt;Clone(); else return nullptr; &#125; private: std::unordered_map&lt;std::string, IProduct *&gt; m_map; &#125;; int main() &#123; ProductMgr mgr; IProduct *p1 = new MessageBox(&quot;Hello&quot;); mgr.Register(&quot;MB&quot;, p1); p1-&gt;Use(&quot;World&quot;); auto p2 = mgr.Create(&quot;MB&quot;); p2-&gt;Use(&quot;World&quot;); cout &lt;&lt; p1 &lt;&lt; endl; cout &lt;&lt; p2 &lt;&lt; endl; auto pp = mgr.Create(&quot;Not&quot;); assert(pp == nullptr); delete p1; delete p2; return 0; &#125; ...","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:03--建造者模式","slug":"designPatter/设计模式-03-建造者模式","date":"2022-10-15T14:13:17.000Z","updated":"2022-10-21T05:58:03.057Z","comments":true,"path":"2022/10/15/designPatter/设计模式-03-建造者模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-03-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。 2、应用场景一个类的各个组成部分的具体实现类或者算法经常面临着变化，但是将他们组合在一起的算法却相对稳定。提供一种封装机制 将稳定的组合算法于易变的各个组成部分隔离开来。 3、UML 二、案例1、案例1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class House &#123;public: House() &#123;&#125; void setFloor(string iFloor) &#123; this-&gt;floor = iFloor; &#125; void setWall(string iWall) &#123; this-&gt;wall = iWall; &#125; void setRoof(string iRoof) &#123; this-&gt;roof = iRoof; &#125; void printfHouseInfo() &#123; printf(&quot;Floor:%s\\t\\n&quot;, this-&gt;floor.c_str()); printf(&quot;Wall:%s\\t\\n&quot;, this-&gt;wall.c_str()); printf(&quot;Roof:%s\\t\\n&quot;, this-&gt;roof.c_str()); &#125;private: string floor; string wall; string roof;&#125;;class AbstractBuilder &#123;public: AbstractBuilder() &#123; house = new House(); &#125; virtual ~AbstractBuilder() &#123; if (house != nullptr) &#123; delete house; house = nullptr; &#125; &#125; virtual void buildFloor() = 0; virtual void buildWall() = 0; virtual void buildRoof() = 0; virtual House *getHouse() = 0; House *house;&#125;;class ConcreteBuilderA : public AbstractBuilder &#123;public: ConcreteBuilderA() &#123; printf(&quot;ConcreteBuilderA\\n&quot;); &#125; ~ConcreteBuilderA() &#123; &#125; void buildFloor() &#123; this-&gt;house-&gt;setFloor(&quot;Floor_A&quot;); &#125; void buildWall() &#123; this-&gt;house-&gt;setWall(&quot;Wall_A&quot;); &#125; void buildRoof() &#123; this-&gt;house-&gt;setRoof(&quot;Roof_A&quot;); &#125; House *getHouse() &#123; return this-&gt;house; &#125;&#125;;class ConcreteBuilderB : public AbstractBuilder &#123;public: ConcreteBuilderB() &#123; printf(&quot;ConcreteBuilderB\\n&quot;); &#125; ~ConcreteBuilderB() &#123; &#125; void buildFloor() &#123; this-&gt;house-&gt;setFloor(&quot;Floor_B&quot;); &#125; void buildWall() &#123; this-&gt;house-&gt;setWall(&quot;Wall_B&quot;); &#125; void buildRoof() &#123; this-&gt;house-&gt;setRoof(&quot;Roof_B&quot;); &#125; House *getHouse() &#123; return this-&gt;house; &#125;&#125;;class Director &#123;public: Director() :builder(nullptr) &#123;&#125; ~Director() &#123; if (this-&gt;builder != nullptr) &#123; delete builder; builder = nullptr; &#125; &#125; void setBuilder(AbstractBuilder *iBuilder) &#123; this-&gt;builder = iBuilder; &#125; House *construct() &#123; builder-&gt;buildFloor(); builder-&gt;buildWall(); builder-&gt;buildRoof(); return builder-&gt;getHouse(); &#125;private: AbstractBuilder *builder;&#125;;int main()&#123; AbstractBuilder *builder; Director *director = new Director(); House *house; builder = new ConcreteBuilderA(); director-&gt;setBuilder(builder); house = director-&gt;construct(); house-&gt;printfHouseInfo(); delete builder; builder = new ConcreteBuilderB(); director-&gt;setBuilder(builder); house = director-&gt;construct(); house-&gt;printfHouseInfo(); delete director; return 0;&#125; 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;class IBuilder &#123;public: virtual ~IBuilder() &#123;&#125; virtual void makeTitle(const std::string &amp;title) = 0; virtual void makeString(const std::string &amp;str) = 0; virtual void makeItems(const std::vector&lt;std::string&gt; &amp;items) = 0; virtual void close() = 0;&#125;;class TextBuilder : public IBuilder &#123;public: void makeTitle(const std::string &amp;title) override &#123; m_str.append(&quot;============================\\n&quot;); m_str.append(&quot;[&quot; + title + &quot;]\\n&quot;); m_str.append(&quot;\\n&quot;); &#125; void makeString(const std::string &amp;str) override &#123; m_str.append(&quot; * &quot; + str + &quot;\\n&quot;); m_str.append(&quot;\\n&quot;); &#125; void makeItems(const std::vector&lt;std::string&gt; &amp;items) override &#123; for (auto item : items) &#123; m_str.append(&quot; . &quot; + item + &quot;\\n&quot;); &#125; m_str.append(&quot;\\n&quot;); &#125; void close() override &#123; m_str.append(&quot;============================\\n&quot;); &#125; std::string getResult() const &#123; return m_str; &#125;private: std::string m_str;&#125;;class Director &#123;public: Director(IBuilder *builder) : m_builder(builder) &#123;&#125; void construct() &#123; m_builder-&gt;makeTitle(&quot;Greeting&quot;); m_builder-&gt;makeString(u8&quot;从早上到下午&quot;); m_builder-&gt;makeItems(std::vector&lt;std::string&gt;&#123; u8&quot;早上好&quot;, u8&quot;下午好&quot; &#125;); m_builder-&gt;makeString(u8&quot;晚上&quot;); m_builder-&gt;makeItems(std::vector&lt;std::string&gt;&#123; u8&quot;晚上好&quot;, u8&quot;晚安&quot;, u8&quot;再见&quot; &#125;); m_builder-&gt;close(); &#125;private: IBuilder *m_builder;&#125;;int main()&#123; TextBuilder *builder = new TextBuilder; Director director(builder); director.construct(); std::string result = builder-&gt;getResult(); std::cout &lt;&lt; result &lt;&lt; std::endl; delete builder; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:02--抽象工厂模式","slug":"designPatter/设计模式-02-抽象工厂模式","date":"2022-10-15T14:11:56.000Z","updated":"2022-10-21T05:41:11.352Z","comments":true,"path":"2022/10/15/designPatter/设计模式-02-抽象工厂模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-02-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。 2、应用场景一系列相互依赖的对象有不同的具体实现。提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合。 3、UML 二、案例1、案例1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class AbstractBall &#123;public: virtual ~AbstractBall()&#123;&#125; AbstractBall()&#123;&#125; void play()&#123;&#125;;&#125;;class Basketball : public AbstractBall &#123;public: Basketball() &#123; play(); &#125; void play()&#123; printf(&quot;Jungle play Basketball\\n\\n&quot;); &#125;&#125;;class Football : public AbstractBall &#123;public: Football()&#123; play(); &#125; void play()&#123; printf(&quot;Jungle play Football\\n\\n&quot;); &#125;&#125;;class AbstractShirt &#123;public: virtual ~AbstractShirt()&#123;&#125; AbstractShirt()&#123;&#125; void wearShirt()&#123;&#125;;&#125;;class BasketballShirt :public AbstractShirt &#123;public: BasketballShirt()&#123; wearShirt(); &#125; void wearShirt()&#123; printf(&quot;Jungle wear Basketball Shirt\\n\\n&quot;); &#125;&#125;;class FootballShirt :public AbstractShirt &#123;public: FootballShirt()&#123; wearShirt(); &#125; void wearShirt()&#123; printf(&quot;Jungle wear Football Shirt\\n\\n&quot;); &#125;&#125;;class AbstractFactory &#123;public: virtual ~AbstractFactory()&#123;&#125; virtual AbstractBall *getBall() = 0; virtual AbstractShirt *getShirt() = 0;&#125;;class BasketballFactory :public AbstractFactory &#123;public: BasketballFactory()&#123; printf(&quot;BasketballFactory\\n&quot;); &#125; AbstractBall *getBall()&#123; printf(&quot;Jungle get basketball\\n&quot;); return new Basketball(); &#125; AbstractShirt *getShirt()&#123; printf(&quot;Jungle get basketball shirt\\n&quot;); return new BasketballShirt(); &#125;&#125;;class FootballFactory :public AbstractFactory &#123;public: FootballFactory()&#123; printf(&quot;FootballFactory\\n&quot;); &#125; AbstractBall *getBall()&#123; printf(&quot;Jungle get football\\n&quot;); return new Football(); &#125; AbstractShirt *getShirt()&#123; printf(&quot;Jungle get football shirt\\n&quot;); return new FootballShirt(); &#125;&#125;;int main()&#123; AbstractFactory *fac = NULL; AbstractBall *ball = NULL; AbstractShirt *shirt = NULL; fac = new BasketballFactory(); ball = fac-&gt;getBall(); shirt = fac-&gt;getShirt(); delete fac; delete ball; delete shirt; fac = new FootballFactory(); ball = fac-&gt;getBall(); shirt = fac-&gt;getShirt(); delete fac; delete ball; delete shirt; return 0;&#125; 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;class IItem &#123;public: virtual ~IItem() &#123;&#125; IItem(const std::string &amp;caption) : m_caption(caption) &#123;&#125; virtual std::string makeHTML() = 0;protected: std::string m_caption;&#125;;class ILink : public IItem &#123;public: virtual ~ILink() &#123;&#125; ILink(const std::string &amp;caption, const std::string &amp;url) : IItem(caption), m_url(url) &#123;&#125;protected: std::string m_url;&#125;;class ITray : public IItem &#123;public: virtual ~ITray() &#123;&#125; ITray(const std::string &amp;caption) : IItem(caption) &#123;&#125; void addItem(IItem *item) &#123; m_itemList.push_back(item); &#125;protected: std::vector&lt;IItem *&gt; m_itemList;&#125;;class ListTray : public ITray &#123;public: using ITray::ITray; std::string makeHTML() override &#123; std::string str; str.append(&quot;&lt;li&gt;\\n&quot;); str.append(m_caption + &quot;\\n&quot;); str.append(&quot;&lt;ul&gt;\\n&quot;); for (auto item : m_itemList) &#123; str.append(item-&gt;makeHTML()); &#125; str.append(&quot;&lt;/ul&gt;\\n&quot;); str.append(&quot;&lt;/li&gt;\\n&quot;); return str; &#125;&#125;;class ListLink : public ILink &#123;public: using ILink::ILink; std::string makeHTML() override &#123; return &quot;&lt;li&gt;&lt;a href=\\&quot;&quot; + m_url + &quot;\\&quot;&gt; &quot; + m_caption + &quot;&lt;/a&gt; &lt;/li&gt;\\n&quot;; &#125;&#125;;class IPage &#123;public: virtual ~IPage() &#123;&#125; IPage(const std::string &amp;title, const std::string &amp;author) : m_title(title), m_author(author) &#123;&#125; void addItem(IItem *item) &#123; m_itemList.push_back(item); &#125; void output() &#123; std::cout &lt;&lt; makeHTML() &lt;&lt; std::endl; &#125; virtual std::string makeHTML() = 0;protected: std::string m_title; std::string m_author; std::vector&lt;IItem *&gt; m_itemList;&#125;;class ListPage : public IPage &#123;public: using IPage::IPage; std::string makeHTML() override &#123; std::string str; str.append(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot; + m_title + &quot;&lt;/head&gt;&lt;/title&gt;\\n&quot;); str.append(&quot;&lt;body&gt;\\n&quot;); str.append(&quot;&lt;h1&gt;&quot; + m_title + &quot;&lt;/h1&gt;\\n&quot;); str.append(&quot;&lt;ul&gt;\\n&quot;); for (auto item : m_itemList) &#123; str.append(item-&gt;makeHTML()); &#125; str.append(&quot;&lt;/ul&gt;\\n&quot;); str.append(&quot;&lt;address&gt;&quot; + m_author + &quot;&lt;/address&gt;\\n&quot;); str.append(&quot;&lt;/body&gt;\\n&quot;); str.append(&quot;&lt;/html&gt;&quot;); return str; &#125;&#125;;class IFactory &#123;public: virtual ~IFactory() &#123;&#125; virtual ILink *createLink(const std::string &amp;caption, const std::string &amp;url) = 0; virtual ITray *createTray(const std::string &amp;caption) = 0; virtual IPage *createPage(const std::string &amp;title, const std::string &amp;author) = 0;&#125;;class IFactoryHelper &#123;public: static void registerFactory(const std::string &amp;name, std::function&lt;IFactory *()&gt; createCallback) &#123; s_createrMap.insert(std::make_pair(name, createCallback)); &#125; static IFactory *getFactory(const std::string &amp;name) &#123; auto itor = s_createrMap.find(name); return itor-&gt;second(); &#125;private: static std::unordered_map&lt;std::string, std::function&lt;IFactory *()&gt;&gt; s_createrMap;&#125;;std::unordered_map&lt;std::string, std::function&lt;IFactory *()&gt;&gt; IFactoryHelper::s_createrMap;class ListFactory : public IFactory &#123;public: ILink *createLink(const std::string &amp;caption, const std::string &amp;url) override &#123; return new ListLink(caption, url); &#125; ITray *createTray(const std::string &amp;caption) override &#123; return new ListTray(caption); &#125; IPage *createPage(const std::string &amp;title, const std::string &amp;author) override &#123; return new ListPage(title, author); &#125;&#125;;static int ListFactoryInit = []() -&gt; int &#123; std::cout &lt;&lt; &quot;1&quot; &lt;&lt; std::endl; IFactoryHelper::registerFactory(&quot;ListFactory&quot;, []() &#123; return new ListFactory; &#125;); return 0;&#125;();int main()&#123; std::shared_ptr&lt;IFactory&gt; factory(IFactoryHelper::getFactory(&quot;ListFactory&quot;)); assert(factory != nullptr); std::shared_ptr&lt;ILink&gt; people(factory-&gt;createLink(u8&quot;人民日报&quot;, u8&quot;http://www.people.com.cn/&quot;)); std::shared_ptr&lt;ILink&gt; gmw(factory-&gt;createLink(u8&quot;光明网&quot;, u8&quot;http://www.gmw.cn/&quot;)); std::shared_ptr&lt;ILink&gt; us_yahoo(factory-&gt;createLink(u8&quot;us_yahoo&quot;, u8&quot;http://www.yahoo.com/&quot;)); std::shared_ptr&lt;ILink&gt; jp_yahoo(factory-&gt;createLink(u8&quot;jp_yahoo&quot;, u8&quot;http://www.yahoo.com.jp/&quot;)); std::shared_ptr&lt;ILink&gt; google(factory-&gt;createLink(u8&quot;google&quot;, u8&quot;http://www.google.com&quot;)); std::shared_ptr&lt;ITray&gt; trayNews(factory-&gt;createTray(&quot;news&quot;)); trayNews-&gt;addItem(people.get()); trayNews-&gt;addItem(gmw.get()); std::shared_ptr&lt;ITray&gt; trayYahoo(factory-&gt;createTray(&quot;yahoo!&quot;)); trayYahoo-&gt;addItem(us_yahoo.get()); trayYahoo-&gt;addItem(jp_yahoo.get()); std::shared_ptr&lt;ITray&gt; traySearch(factory-&gt;createTray(&quot;traySearch&quot;)); trayYahoo-&gt;addItem(trayYahoo.get()); trayYahoo-&gt;addItem(google.get()); std::shared_ptr&lt;IPage&gt; page(factory-&gt;createPage(&quot;LinkPage&quot;, &quot;tao&quot;)); page-&gt;addItem(trayNews.get()); page-&gt;addItem(traySearch.get()); page-&gt;output(); return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:01--工厂方法模式","slug":"designPatter/设计模式-01-工厂方法模式","date":"2022-10-15T14:11:40.000Z","updated":"2022-10-21T05:40:31.403Z","comments":true,"path":"2022/10/15/designPatter/设计模式-01-工厂方法模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-01-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。 2、应用场景于需求的变化，一个类的子类经常面临着剧烈的变化，但他却拥有比较稳定的接口。使用一种封装机制来“隔离这种易变对象的变化”，工厂方法定义一个用于创建对象的接口，让子类来确定创建哪一个具体类的对象，将对象的实例化延迟。 3、UML 二、案例1、案例112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class AbstractSportProduct &#123;public: AbstractSportProduct() &#123;&#125; virtual ~AbstractSportProduct()&#123;&#125; void printName()&#123;&#125;; void play()&#123;&#125;;&#125;;class Basketball : public AbstractSportProduct &#123;public: Basketball()&#123; printName(); play(); &#125; void printName()&#123; printf(&quot;Jungle get Basketball\\n&quot;); &#125; void play()&#123; printf(&quot;Jungle play Basketball\\n&quot;); &#125;&#125;;class AbstractFactory &#123;public: virtual AbstractSportProduct *getSportProduct() = 0; virtual ~AbstractFactory()&#123;&#125;&#125;;class BasketballFactory : public AbstractFactory &#123;public: BasketballFactory() &#123; printf(&quot;BasketballFactory\\n&quot;); &#125; AbstractSportProduct *getSportProduct() &#123; printf(&quot;basketball&quot;); return new Basketball(); &#125;&#125;;int main()&#123; AbstractFactory *fac = NULL; AbstractSportProduct *product = NULL; fac = new BasketballFactory(); product = fac-&gt;getSportProduct(); if (fac) &#123; delete fac; &#125; if (product) &#123; delete product; &#125; return 0;&#125; 2、案例212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;class IProduct &#123;public: virtual ~IProduct() &#123;&#125; virtual void use() = 0;&#125;;class IDCard : public IProduct &#123;public: IDCard(const std::string &amp;owner) : m_owner(owner) &#123;&#125; void use() override &#123; std::cout &lt;&lt; &quot;use IDCare with owner&quot; &lt;&lt; m_owner &lt;&lt; std::endl; &#125;private: std::string m_owner;&#125;;class IFactory &#123;public: virtual ~IFactory() &#123;&#125; virtual void registerProduct(IProduct *) = 0; virtual IProduct *createProduct(const std::string &amp;owner) = 0; virtual IProduct *create(const std::string &amp;owner) &#123; auto *pro = createProduct(owner); registerProduct(pro); return pro; &#125;&#125;;class IDCareFactory : public IFactory &#123;public: IProduct *createProduct(const std::string &amp;owner) &#123; return new IDCard(owner); &#125; void registerProduct(IProduct *pro) &#123; m_productList.push_back(pro); &#125;private: std::vector&lt;IProduct *&gt; m_productList;&#125;;int main()&#123; IFactory *fac = new IDCareFactory; IProduct *pro = fac-&gt;create(&quot;tao&quot;); IProduct *pro2 = fac-&gt;create(&quot;tao2&quot;); pro-&gt;use(); pro2-&gt;use(); delete pro; delete fac; delete pro2; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++:06--function与bind及Lamda实现回调函数","slug":"C++/C-06-function与bind及Lamda实现回调函数","date":"2022-10-15T01:59:13.000Z","updated":"2022-10-16T01:41:46.766Z","comments":true,"path":"2022/10/15/C++/C-06-function与bind及Lamda实现回调函数/","link":"","permalink":"http://example.com/2022/10/15/C++/C-06-function%E4%B8%8Ebind%E5%8F%8ALamda%E5%AE%9E%E7%8E%B0%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","excerpt":"","text":"一、使用std::function作为函数入参1、基于传值的方式传递参数12#include &lt;functional&gt;void registerCallBack(std::function&lt;void()&gt;); 上面的代码实现了一个注册回调函数的机制，入参std::function&lt;void()&gt;是一个模板类对象， 它可以用一个函数签名为void()的可调用对象来进行初始化。 1234// 方法（A）registerCallBack([=]&#123; .... // 回调函数的实现部分&#125;) 这里使用了lambda表达式作为函数的入参，lambda表达式会生成一个匿名的闭包， 基于这个闭包构造了一个std::function&lt;void()&gt;的对象， 然后通过传值调用的方式把这个对象传递registerCallBack函数中使用。 2、基于引用的方式传递参数当然还可以如下实现这个注册函数，入参通过const引用的方式传递，这里的引用必须是const的， 这是因为调用registerCallBack函数的地方生成了一个临时的std::function()对象， 是一个右值，否则编译会报错。 123//方法(B)#include &lt;functional&gt;void registerCallBack(std::function&lt;void()&gt; const&amp;); 这传值和引用区别就在于，在registerCallBack函数内部怎么使用这个入参， 1) 如果只是简单的调用一下std::func()类，那么两种都没有问题，可能使用引用的效率更高； 2) 如果register函数内部需要保存这个std::func()，并用于以后使用，那么方法A直接保存没有问题， 方法B就必须做一次拷贝，否则方法B中，当临时的对象销毁时，有可能出现引用悬空的问题。 3、传值方式下的std::function对象保存如果要在registerCallBack函数内部保存传入的function对象，可以使用std::move，效率更高。 123456789class CallBackHolder &#123;public:void registerCallBack(std::function&lt;void()&gt; func) &#123; callback = std::move(func);&#125; private: std::function&lt;void()&gt; callback; &#125; 二、类的成员函数作为函数入参类的成员函数都会默认有个隐藏的this指针，所以不像普通的函数直接作为入参就可以了。 1、使用bind和function来实现1234567891011121314151617class classA &#123;typedef std::function&lt;void(int i)&gt; callback_t;... void registCb(callback_t func) &#123; cbHandle = std::move(func); &#125;private: callback_t cbHandle;&#125;;class classB &#123;public: classB(classA&amp; cA) &#123; cA.registCb(bind(&amp;classB::handle, this, placeholders::_1)); &#125;&#125;; 2、使用lambda表达式实现123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;class classA &#123;typedef std::function&lt;void(int i)&gt; callback_t;public: classA() &#123;&#125; ~classA() &#123;&#125; void handle(int i) &#123; std::cout &lt;&lt; &quot;classA::handle&quot; &lt;&lt; std::endl; cbHandle(i); &#125; void registCb(callback_t func) &#123;cbHandle = std::move(func);&#125;private: callback_t cbHandle;&#125;;class classB &#123;public: classB(classA&amp; cA) &#123; cA.registCb([this](int i)&#123;classB::handle(i);&#125;); &#125; ~classB() &#123;&#125; void handle(int i)&#123; std::cout &lt;&lt; &quot;classB, handle message&quot; &lt;&lt; i &lt;&lt; std::endl; &#125;&#125;;int main()&#123; classA testa; classB testb(testa); testa.handle(10);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:05--Lamda表达式使用场景","slug":"C++/C-05-Lamda表达式使用场景","date":"2022-10-14T06:54:13.000Z","updated":"2022-10-21T02:06:11.698Z","comments":true,"path":"2022/10/14/C++/C-05-Lamda表达式使用场景/","link":"","permalink":"http://example.com/2022/10/14/C++/C-05-Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"一、lamda表达式变量截取方式1、定义 1) 变量截取方式 2) Lambda表达式的参数列表 3) Mutable 标识 4) 异常标识 5) 返回值 6) “函数”体，也就是lambda表达式需要进行的实际操作 2、变量截取方式[] 不截取任何变量 [&amp;] 截取外部作用域中所有变量，并作为引用在函数体中使用 [&#x3D;] 截取外部作用域中所有变量，并拷贝一份在函数体中使用 [&#x3D;, &amp;foo]截取外部作用域中所有变量，并拷贝一份在函数体中使用，但是对foo使用引用 [bar] 截取bar变量并且拷贝一份在函数体重使用，同时不截取其他变量 [this] 截取当前类中的this指针。如果已经使用了&amp;或者&#x3D;就默认添加此选项 二、lamda表达式使用场景1、场景1简化写法。 //1.1vector数组求和 1234567891011int main()&#123; std::vector&lt;int&gt; some_list; int total = 0; for (int i = 0; i &lt; 5; ++i) some_list.push_back(i); for_each(begin(some_list), end(some_list), [&amp;total](int x) &#123;total += x;&#125;); return 0;&#125; //1.2vector数组排序 123456789101112int main(void)&#123; int data[6] = &#123; 3, 4, 12, 2, 1, 6 &#125;; vector&lt;int&gt; testdata; testdata.insert(testdata.begin(), data, data + 6); // 排序算法 sort(testdata.begin(), testdata.end(), [](int a, int b) &#123; return a &gt; b; &#125;); return 0;&#125; 2、场景2以前类中开启线程都需要通过静态成员函数，现在通过Lambda表达式， 在中括号[this]中可以直接访问到类中的成员变量。 123456789101112131415161718192021222324class A&#123;public: A(); ~A();//析构private: std::unique_ptr&lt;std::thread&gt; monitorThread; int a;&#125;;A::A()&#123; monitorThread = make_unique&lt;thread&gt;([this] &#123; while (true) &#123; cout &lt;&lt; &quot;i can access a &quot; &lt;&lt; a++ &lt;&lt; endl; Sleep(100); &#125; &#125;);&#125;A::~A()&#123;&#125; 3、场景3回调函数实现 123456789101112131415161718192021222324252627class MathCallBack &#123; int ops1,ops2; int result;public: void Add(int a,int b, function&lt;void (int)&gt; func) &#123; ops1 = abs(a); ops2 = abs(b); result = ops1+ops2; func(result); &#125;&#125;;int main()&#123; MathCallBack math; int c1 = 0; math.Add(1, 3, [&amp;c1](int result) -&gt; void &#123; printf(&quot;result = %d\\n&quot;, result); c1 = result; &#125;); printf(&quot;c1 = %d\\n&quot;, c1); return 0;&#125; lambda表达式可以以引用方式捕获上下文中的变量，达到回调的效果。 4、更多参考例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364vector&lt; int&gt; vec;/* 1. simple lambda */ auto it = std::find_if(vec.begin(), vec.end(), [](int i) &#123; return i &gt; 50; &#125;); class A &#123; public: bool operator(int i) const &#123; return i &gt; 50; &#125; &#125;;auto it = std::find_if(vec.begin(), vec.end(), A()); /* 2. lambda return syntax */ function&lt;int(int)&gt; square = [](int i) -&gt; int &#123;return i * i;&#125; /* 3. lambda expr: capture of local variable */ &#123; int min_val = 10; int max_val = 1000; auto it = find_if(vec.begin(), vec.end(), [=](int i) &#123;return i &gt; min_val &amp;&amp; i &lt; max_val;&#125;); auto it = find_if(vec.begin(), vec.end(), [&amp;](int i) &#123;return i &gt; min_val &amp;&amp; i &lt; max_val;&#125;); auto it = find_if(vec.begin(), vec.end(), [=, &amp;max_value](int i) &#123;return i &gt; min_val &amp;&amp; i &lt; max_val;&#125;); &#125; /* 4. lambda expr: capture of class member */ class A &#123; public: void DoSomething(); private: std::vector&lt;int&gt; m_vec; int m_min_val; int m_max_va; &#125;; /* 4.1 capture member by this */ void A::DoSomething() &#123; auto it = find_if(m_vec.begin(), m_vec.end(), [this](int i)&#123; return i &gt; m_min_val &amp;&amp; i &lt; m_max_val;&#125;); &#125; /* 4.2 capture member by default pass-by-value */ void A::DoSomething() &#123; auto it = find_if(m_vec.begin(), m_vec.end(), [=](int i)&#123; return i &gt; m_min_val &amp;&amp; i &lt; m_max_val; &#125;); &#125; /* 4.3 capture member by default pass-by-reference */ void A::DoSomething() &#123; auto it = find_if(m_vec.begin(), m_vec.end(), [&amp;](int i)&#123; return i &gt; m_min_val &amp;&amp; i &lt; m_max_val;&#125;); &#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:04--std::function和std::bind的用法","slug":"C++/C-04-std-function和std-bind的用法","date":"2022-10-14T06:26:43.000Z","updated":"2022-10-16T01:41:35.186Z","comments":true,"path":"2022/10/14/C++/C-04-std-function和std-bind的用法/","link":"","permalink":"http://example.com/2022/10/14/C++/C-04-std-function%E5%92%8Cstd-bind%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"一、std::function的用法1、保存自由函数123456789void printA(int a)&#123; cout &lt;&lt; a &lt;&lt; endl;&#125;std::function&lt;void(int a)&gt; func;func = printA;func(2); 2、保存lamda表达式12std::function&lt;void()&gt; func_1 = []()&#123;cout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl;&#125;;func_1(); 3、保存函数对象12345678910class CStudent&#123;public: void operator() (string strName, int nAge) &#123; cout &lt;&lt; strName &lt;&lt; &quot; : &quot; &lt;&lt; nAge &lt;&lt; endl; &#125;&#125;;CStudent stu;function&lt;void (string, int)&gt; f = stu;f(&quot;Mike&quot;, 12); 4、保存成员函数1234567891011121314struct Foo &#123; Foo(int num) : num_(num) &#123;&#125; void print_add(int i) const &#123; cout &lt;&lt; num_+i &lt;&lt; &#x27;\\n&#x27;; &#125; int num_;&#125;;int main()&#123; std::function&lt;void(const Foo&amp;, int)&gt; f_add_display = &amp;Foo::print_add; Foo foo(2); f_add_display(foo, 1); return 0;&#125; 在实际使用中都用 auto 关键字来代替std::function… 这一长串了 一、std::bind的用法1、用法案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859using namespace std;class A &#123;public: void fun_3(int k, int m) &#123; cout&lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; endl; &#125;&#125;;void fun(int x, int y, int z)&#123; cout&lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; z &lt;&lt; endl;&#125;void fun_2(int &amp;a, int &amp;b)&#123; a++; b++; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;&#125;int main(int argc, const char * argv[])&#123; /* 表示绑定函数fun的第一，二，三个参数值为： 1 2 3 */ auto f1 = std::bind(fun,1,2,3); f1(); //print:1 2 3 /* 前两个形参为占位符，调用时确定，第三个为3 */ auto f2 = std::bind(fun, placeholders::_1, placeholders::_2, 3); f2(1, 2); //print:1 2 3 /* 前两个形参为占位符，调用时确定，第三个为3 */ auto f3 = std::bind(fun, placeholders::_2, placeholders::_1, 3); /* 注意： f2和f3的区别 */ f3(1, 2); //print:2 1 3 int n = 2; int m = 3; auto f4 = std::bind(fun_2, n, placeholders::_1); f4(m); //print: 3 4 /* 打印4，说明bind通过std::placeholders传递的参数是通过引用传递的 */ cout &lt;&lt; m &lt;&lt; endl; /* 打印2，说明：bind对于预先绑定的函数参数是通过值传递的 */ cout &lt;&lt; n &lt;&lt; endl; A a; auto f5 = std::bind(&amp;A::fun_3, a, placeholders::_1, placeholders::_2); f5(10, 20); //print:10 20 std::function&lt;void(int,int)&gt; fc = bind(&amp;A::fun_3, a, placeholders::_1, placeholders::_2); fc(10,20); //print:10 20 return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:03--多级混合继承、虚基类","slug":"C++/C-03-多级混合继承、虚基类","date":"2022-10-13T10:26:35.000Z","updated":"2022-10-16T01:41:28.862Z","comments":true,"path":"2022/10/13/C++/C-03-多级混合继承、虚基类/","link":"","permalink":"http://example.com/2022/10/13/C++/C-03-%E5%A4%9A%E7%BA%A7%E6%B7%B7%E5%90%88%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%9F%BA%E7%B1%BB/","excerpt":"","text":"一、多级混合继承1、例子1234567891011121314151617181920212223242526272829303132//菱形继承class A &#123;public: int data;&#125;;class B : public A &#123;public: int data;&#125;;class C : public A &#123;public: int data;&#125;;class D : public B, public C &#123;public: int data;&#125;;int main()&#123; D c; D.data=1; D.B::data=2;//访问B中的 D.C.::data=3;//访问C中的 D.B::A::data=4;//访问B继承的A D.C::A::data=5;//访问C继承的A D.A::data=4;//错误，产生二义性，不知道是B、C中哪一个&#125; 2、内存大小 3、内存图解 一、虚基类1、概念1) 也称虚继承、菱形继承。用于多级混合继承时，保留一个虚基类。 2) 构造顺序 先构造虚基类，如果有多个虚基类，按声明（从左至右）依次构造; 再构造基类，如果有多个基类，按声明（从左至右）依次构造; 如果有子对象，再构造子对像，如果有多个子对象，按声明的顺序（从上至下）依次构造; 最后构造自己。 2、例子1234567891011121314151617181920212223242526272829303132class A &#123;public: A(int data)&#123;&#125;//1 int data;&#125;;class B : virtual public A &#123;public: B():A(1)&#123;&#125;//2 int data;&#125;;class C : virtual public A &#123;public: C() : A(2)&#123;&#125;//3 int data;&#125;;class D : public B, public C &#123;public: D() : A(3)&#123;&#125;//4 int data;&#125;;int main() &#123; D d; d.data=1; d.B::data=2; d.C::data=3; d.B::A.data=4; d.C::A::data=5;&#125; 1) 构造顺序为：1-2-3-4 2) 构造顺序解释：构造类D对象d的时候，发现继承于B，于是去构造B， 构造B的时候，发现继承于虚基类A，于是构造虚基类A，接着构造B。 再接着构造C，发现C继承于虚基类A，但发现虚基类A已经被B构造过了， 所以不再构造A，直接构造C。最后构造D。 3) 如果虚基类构造函数为带参构造，则其子类，以及子类拓展出来的子类， 都要在成员初始化列表对其进行构造函数的初始化。 4) d的data赋值为1，继承于B、C，分别赋值为2,3，顺序为从左至右。 A的值本来为4，后来执行到最后一行的时候被赋值为5 3、内存大小 4、内存图解","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:02--成员变量初始化方式","slug":"C++/C-02-成员变量初始化方式","date":"2022-10-13T08:58:08.000Z","updated":"2022-10-30T13:55:09.488Z","comments":true,"path":"2022/10/13/C++/C-02-成员变量初始化方式/","link":"","permalink":"http://example.com/2022/10/13/C++/C-02-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/","excerpt":"","text":"一、成员变量3种初始化方式1) 在构造函数体内赋值初始化 2) 在自定义的公有函数体中赋值初始化（一般用于成员变量的初始化） 3) 在构造函数的成员初始化列表初始化 二、构造函数体内初始化1、说明在构造函数体内的初始化方式，本质是是为成员变量赋值，而不是真正意义上的初始化。 2、案例1234567891011class Cperson &#123;public: Cperson(int age, float height) &#123; m_age = age; m_height = height; &#125;private: int m_age; float m_height;&#125; 三、自定义的公有函数体中赋值初始化1、说明与构造函数体内初始化方式一样，此种方式本质上也是赋值，而不是初始化。 2、案例1234567891011class Cperson &#123;public: void setPerson(int age, float height) &#123; m_age = age; m_height = height; &#125;private: int m_age; float m_height;&#125; 四、成员初始化列表初始化1、说明1) 写在构造函数的后面，随着构造函数的执行而执行。 2) 初始化列表初始化优先于构造函数内的代码执行顺序。 3) 一般只对无动态内存的成员、const成员、引用初始化, 其中const成员、引用成员必须在初始化列表初始化。 4) 成员初始化列表初始化效率更高。 5) 有动态内存的成员必须在构造函数内部进行初始化。 2、案例1 (const成员、引用成员必须在初始化列表初始化)123456789101112131415class Person &#123;public: Person(int i);private: const int id; int&amp; m_id;&#125;;Person::Person(int i)&#123; id = i; //错误，const成员变量必须在成员初始化列表初始化 m_id = id; //错误，引用也必须在成员初始化列表初始化&#125; 3、案例2 (成员初始化列表初始化效率更高)1234567891011class Word&#123;public: Word()&#123; _name=0; //先创建一个临时string对象，赋值为0，然后拷贝给_name _cnt=0; //构造函数结束之后，临时对象析构释放 &#125;private: string _name; int _cnt;&#125;; 但是如果使用下面的成员初始化列表初始化，那么就省去了创建临时对象再拷贝的过程 12345678 class Word&#123; public: Word() :_name(0),_cnt(0)&#123;&#125; //直接初始化_name，不创建临时对象 private: string _name; int _cnt;&#125;; 五、总结1) 成员初始化列表初始化成员才是真正意义上的初始化，其他两种方式都是为赋值。 2) 初始化是直接初始化。而赋值是先初始化一个临时变量，再赋值。前者效率高。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:01--this指针","slug":"C++/C-01-this指针","date":"2022-10-13T08:09:26.000Z","updated":"2022-10-16T01:41:16.814Z","comments":true,"path":"2022/10/13/C++/C-01-this指针/","link":"","permalink":"http://example.com/2022/10/13/C++/C-01-this%E6%8C%87%E9%92%88/","excerpt":"","text":"一、this指针应用1、剖析1) 对于类成员函数而言，并不是一个对象对应一个单独的成员函数体，而是此类的所有对象共用这个成员函数体。 当程序被编译之后，此成员函数地址已经确定。 1) 调用类的成员函数时，会将当前对象的this指针传递给成员函数，然后在函数体内对类的数据成员访问时， 就会被转换为“this-&gt;数据成员”的形式。 1) 如果成员函数内部没有访问对象的任何数据成员，那么传进来的this指针实际没有任何用处， 这样的函数与全局函数并没有太大区别。 &amp;nbsp; 2、案例11234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class MyClass &#123;public: int data; MyClass(int data) &#123; this-&gt;data = data; &#125; void print() &#123; //cout&lt;&lt; data &lt;&lt; endl; cout &lt;&lt; &quot;hello!&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; MyClass *pMyClass; pMyClass = new MyClass(1); pMyClass-&gt;print(); pMyClass[0].print(); pMyClass[1].print(); pMyClass[10000000].print(); return 0;&#125; 程序输出如下： 结果分析： 1) 此处我们创建了一个对象，但是访问后面越界之后仍然可以访问成功。 2) 如果一个成员函数没有操作任何类的数据成员，因此这个成员函数与全局函数类型，调用之后都会打印“hello!”。 &amp;nbsp; 3、案例21234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class MyClass &#123;public: int data; MyClass(int data) &#123; this-&gt;data = data; &#125; void print() &#123; cout&lt;&lt; data &lt;&lt; endl; cout &lt;&lt; &quot;hello!&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; MyClass *pMyClass; pMyClass = new MyClass(1); pMyClass-&gt;print(); pMyClass[0].print(); pMyClass[1].print(); pMyClass[10000000].print(); return 0;&#125; 程序输出如下： 结果分析： 1) 此处我们的成员函数访问了类的数据成员，那么每次打印数据时都会通过this指针调用。 2) 但是此处我们只创建了一个对象，所以当调用pMyClass[1]和pMyClass[10000000]越界了，找不到对象，从而报错。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ubuntu搭建Qt4Android的开发环境","slug":"ubuntu/ubuntu搭建Qt4Android的开发环境","date":"2022-09-29T05:45:30.000Z","updated":"2022-10-16T03:33:57.869Z","comments":true,"path":"2022/09/29/ubuntu/ubuntu搭建Qt4Android的开发环境/","link":"","permalink":"http://example.com/2022/09/29/ubuntu/ubuntu%E6%90%AD%E5%BB%BAQt4Android%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"一、软件版本选择1234android-studio: android-studio-2020.3.1.26-linux.tar.gzandroid-sdk: android-sdk_r24.4.1-linux.tgzandroid-ndk: android-ndk-r19c-linux-x86_64.zipQt: 5.12.8 二、安装软件1、安装jdk123456sudo apt install -y openjdk-8-jdkvi /etc/profileexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64export PATH=$PATH:$&#123;JAVA_HOME&#125;/binsource /etc/profile 2、安装sdk解压并运行android-studio, 将sdk、tool等下载到一个空的文件夹android-sdk下 解压android-sdk_r24.4.1-linux.tgz并赋值其目录下的tools到android-sdk下 3、解压ndk解压 android-ndk-r19c-linux-x86_64.zip 4、设置交叉编译","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"ubuntu安装VNC-无需显示屏","slug":"ubuntu/ubuntu安装VNC-无需显示屏","date":"2022-09-28T06:35:13.000Z","updated":"2022-10-16T03:33:52.097Z","comments":true,"path":"2022/09/28/ubuntu/ubuntu安装VNC-无需显示屏/","link":"","permalink":"http://example.com/2022/09/28/ubuntu/ubuntu%E5%AE%89%E8%A3%85VNC-%E6%97%A0%E9%9C%80%E6%98%BE%E7%A4%BA%E5%B1%8F/","excerpt":"","text":"一、安装1、安装VNC1234sudo apt-get install x11vnc –y/* generate password */sudo x11vnc -storepasswd /etc/x11vnc.pass 2、启动VNC1sudo x11vnc -display :0 -auth /var/run/lightdm/root/:0 -forever -bg -o /var/log/x11vnc.log -rfbauth /etc/x11vnc.pass -rfbport 5901 一、配置无显示器访问1、生成配置文件1234sudo Xorg :1 –configure/* 此时会在root路径下生成xorg.conf.new文件 */cp /root/xorg.conf.new /usr/share/X11/xorg.conf.d/xorg.conf 2、安装虚拟显卡驱动1sudo apt install xserver-xorg-video-dummy 3、添加虚拟显卡配置1234567891011121314151617181920212223242526272829sudo vi /usr/share/X11/xorg.conf.d/xorg.conf/* 在文件最后添加以下内容 */Section &quot;Monitor&quot; Identifier &quot;Monitor1&quot; HorizSync 1.0 - 2000.0 VertRefresh 1.0 - 200.0 # Add 16:9 modes, others are automatically detected. Modeline &quot;1280x720&quot; 74.48 1280 1336 1472 1664 720 721 724 746 Modeline &quot;1920x1080&quot; 172.80 1920 2040 2248 2576 1080 1081 1084 1118EndSectionSection &quot;Device&quot; Identifier &quot;Card1&quot; Driver &quot;dummy&quot; VideoRam 256000EndSection Section &quot;Screen&quot; DefaultDepth 24 Identifier &quot;Screen1&quot; Device &quot;Card1&quot; Monitor &quot;Monitor1&quot; SubSection &quot;Display&quot; Depth 24 Modes &quot;1920x1080&quot; EndSubSectionEndSection 4、虚拟与真实显示器同时工作配置修改步骤3中的配置文件最上面的ServerLayout: 12345Section &quot;ServerLayout&quot; Identifier &quot;X.org Configured&quot; Screen 0 &quot;Screen0&quot; 0 0 Screen 1 &quot;Screen1&quot; 0 0EndSection","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"树莓派3B+xenomai+igh","slug":"servoCtrl/树莓派3B-xenomai-igh","date":"2022-09-28T05:42:02.000Z","updated":"2022-10-16T03:34:20.236Z","comments":true,"path":"2022/09/28/servoCtrl/树莓派3B-xenomai-igh/","link":"","permalink":"http://example.com/2022/09/28/servoCtrl/%E6%A0%91%E8%8E%93%E6%B4%BE3B-xenomai-igh/","excerpt":"","text":"一、源码包准备1、安装依赖软件1sudo apt install git bc bison flex libssl-dev make 2、源码版本12345git clone https://github.com/raspberrypi/linux.gitgit checkout rpi-4.1.ygit clone http://git.xenomai.org/xenomai-3.git/git checkout v3.0.2 二、实时内核移植1、打实时补丁12345cd xenomai-3scripts/prepare-kernel.sh --linux=../linux/ --arch=arm --ipipe=./kernel/cobalt/arch/arm/patches/ipipe-core-4.1.18-arm-4.patchcd ../linuxcat ../patch-xenomai-3-on-bcm-2709.patch | patch -p1 2、配置内核123456789101112131415161718make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfigmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig/* config linux kernel with the following options */CPU Power Management ---&gt;CPU Frequency scaling ---&gt; [ ] CPU Frequency scalingCPU idle ---&gt; [ ] CPU idle PM supportKernel Features ---&gt; [ ] Contiguous Memory Allocator [ ] Allow for memory compactionKernel Hacking ---&gt; [ ] KGDB: kernel debuggerBoot options ---&gt; Kernel command line type ---&gt; [X] Extend bootloader kernel arguments 3、编译内核及模块1234make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs -j20mkdir modulesmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- INSTALL_MOD_PATH=modules modules_install 4、安装到系统123456cp arch/arm/boot/zImage /media/$&#123;USER&#125;/bootcp arch/arm/boot/dts/bcm2710-rpi-3-b.dtb /media/$&#123;USER&#125;/bootrm -rf /media/$&#123;USER&#125;/boot/overlays/*cp arch/arm/boot/dts/overlays/*.dtb* /media/$&#123;USER&#125;/boot/overlays/sudo cp -r linux/dist/lib/modules/* /media/$&#123;USER&#125;/$&#123;ROOTFS&#125;/lib/modules 5、修改系统启动项12kernel=$&#123;zImage name&#125;device_tree=bcm2710-rpi-3-b.dtb 三、安装xenomai1、配置123cd xenomai-3./scripts/bootstrap --with-core=cobalt –enable-debug=partial./configure CFLAGS=&quot;-march=armv7-a -mtune=cortex-a8 -mfloat-abi=hard -mfpu=neon -ffast-math&quot; --host=arm-linux-gnueabihf --target=arm-linux-gnueabihf --enable-smp 2、编译12mkdir targetmake DESTDIR=$&#123;PWD&#125;/target install 3、安装到系统1sudo cp -a target/* /media/$&#123;USER&#125;/$&#123;ROOTFS&#125;/ 三、安装IGH1、源码包123git clone https://gitlab.com/etherlab.org/ethercat.gitcd ethercatgit checkout stable-1.5 2、配置123mkdir etherlab./bootstrap./configure --prefix=$&#123;PWD&#125;/etherlab --with-linux-dir=$&#123;PWD&#125;/../linux --enable-8139too=no --enable-generic=yes CC=arm-linux-gnueabihf-gcc --host=arm-linux-gnueabihf 3、编译12make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- all modules -j20make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- install -j20 4、可能出现的问题及解决123issue: /usr/bin/ld: error: ethercat use VFP register arguments, ../master/soe_errors.o does notsolve: touch ~/ethercat/master/soe_errors.c 5、安装到系统123456789101112131415161718mkdir -p $&#123;PWD&#125;/etherlab/modulescp devices/ec_generic.ko etherlab/modules/cp master/ec_master.ko etherlab/modules/sudo cp -r etherlab/ /opt sudo ln -fs /opt/etherlab/etc/init.d/ethercat /etc/init.d/sudo ln -fs /opt/etherlab/bin/ethercat /usr/local/bin/sudo mkdir /etc/sysconfigsudo ln -fs /opt/etherlab/etc/sysconfig/ethercat /etc/sysconfig/sudo susudo echo KERNEL==\\&quot;EtherCAT[0-9]*\\&quot;, MODE=\\&quot;0664\\&quot; &gt; /etc/udev/rules.d/99-EtherCAT.rulesexitsudo cp /opt/etherlab/modules/ec_master.ko /lib/modules/4.14.91-rt49-v7+sudo depmodvi ~/.bashrcPATH=$PATH:/opt/etherlab/binsource ~/.bashrc 6、配置网卡123vi /etc/sysconfig/ethercatMASTER0_DEVICE=”b8:27:eb:7d:26:a2” //填写实际的MACDEVICE_MODULES=”generic” 7、启动igh1sudo /etc/init.d/ethercat start 6、测试经过测试发现igh1.5.2可以在pi3上运行，但是效果很差，代码运行后不能识别对应的pdo，原因待查找","categories":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]},{"title":"x86工控机安装igh","slug":"servoCtrl/x86工控机安装igh","date":"2022-09-27T13:51:31.000Z","updated":"2022-10-16T03:34:08.809Z","comments":true,"path":"2022/09/27/servoCtrl/x86工控机安装igh/","link":"","permalink":"http://example.com/2022/09/27/servoCtrl/x86%E5%B7%A5%E6%8E%A7%E6%9C%BA%E5%AE%89%E8%A3%85igh/","excerpt":"","text":"一、网卡驱动类型1、通用型优点: generic通用型的网卡驱动对物理网卡没有太多要求，只需要Linux系统支持其驱动， 就能在IGH的配置中将其选作网卡驱动。 缺点: 实时性较差，尤其是进行dc同步控制时表现更为明显。 2、本地型优点: native本地型网卡驱动是官方专门适配的几款Intel网卡，实时性方面有良好的保证 缺点: 只支持几款网卡，并且还需专门的内核版本支持。 二、安装通用型网卡驱动1、下载源码包https://sourceforge.net/p/etherlabmaster/code/ci/stable-1.5/tree/ 2、配置1234cd path/to/ethercatMaster./bootstrapmkdir etherlab./configure --prefix=/home/lufahai/xenohegongda/etherlabmaster/etherlab --with-linux-dir=/home/lufahai/xenohegongda/linux-4.9.51 --enable-cycles --enable-hrtimer --enable-8139too=no --enable-generic=yes configure中的路径需要根据本地实际路径修改 3、编译及安装1234make -j16make modules -j16sudo make installsudo make modules_install 4、创建软连接12345678910111213mkdir -p ~/ethercat/etherlab/modulescp devices/ec_generic.ko etherlab/modules/cp master/ec_master.ko etherlab/modules/sudo cp -r etherlab/ /opt sudo ln -fs /opt/etherlab/etc/init.d/ethercat /etc/init.d/sudo ln -fs /opt/etherlab/bin/ethercat /usr/local/bin/sudo mkdir /etc/sysconfigsudo ln -fs /opt/etherlab/etc/sysconfig/ethercat /etc/sysconfig/sudo suecho KERNEL==\\&quot;EtherCAT[0-9]*\\&quot;, MODE=\\&quot;0664\\&quot; &gt; /etc/udev/rules.d/99-EtherCAT.rulesexitsudo cp /opt/etherlab/modules/ec_master.ko /lib/modules/4.9.51-xenomai3.1+sudo depmod 此步骤中的路径需要根据本地实际路径修改 5、配置网卡ifconfig 找出网卡的MAC地址 123sudo vi /etc/sysconfig/ethercatMASTER0_DEVICE=”b8:27:eb:7d:26:a2” //填写实际MACDEVICE_MODULES=”generic” 6、增加系统路径在~/.bashrc 末尾增加下面内容并source 12PATH=$PATH:/opt/etherlab/binsource ~/.bashrc 7、添加库文件供程序链接如果没有将xenomai的库添加到系统路径中，程序在链接的时候就会出现 error: while loading shared libraries... 解决： 123sudo vi /etc/ld.so.conf/usr/xenomai/lib //文件中增加这一行sudo ldconfig -v //使其生效 三、安装native型网卡驱动1、内核及igh源码版本的下载地址安装native型网卡驱动需要内核支持此网卡驱动， 最好的内核无疑是igh官方经过优化后的，下载地址如下 内核：https://source.denx.de/Xenomai/linux-dovetail branch选择 v5.10.y-dovetail igh源码： https://gitlab.com/etherlab.org/ethercat/-/tree/e1000e-5.10 branch选择 e1000e-5.10 xenomai选择3.2.1版本 2、Linux内核配置由于使用官方提供的内核，所以打补丁与另一篇搭建实时系统博客中的方法略有不同 12cd path/to/kernel../xenomai-v3.2.1/scripts/prepare-kernel.sh --arch=x86_64 Linux5.10的内核配置可以参考下面的附录，编译及安装过程与4.x内核移植 3、native型网卡配置12345cd path/to/ighsourceTree./scrip/bootstrapmkdir etherlab./configure --prefix=/home/huger/rtlinux/ethercat-e1000e-5.10/etherlab -enable-8139too=no -enable-e1000e=yes 4、编译及安装123make all modules -j16sudo make modules_install install -j16sudo depmod 5、创建软链接与通用型相同 6、配置网卡sudo vi /etc/sysconfig/ethercat MASTER0_DEVICE=”b8:27:eb:7d:26:a2” //填写实际MAC DEVICE_MODULES=”e1000e” 三、Linux5.10内核配置附录1234567891011121314151617181920212223242526272829303132333435363738394041424344Recommended options:* General setup --&gt; Local version - append to kernel release: -xenomai-3.0.5 --&gt; Timers subsystem --&gt; High Resolution Timer Support (Enable)* Xenomai/cobalt --&gt; Sizes and static limits --&gt; Number of registry slots (512 --&gt; 4096) --&gt; Size of system heap (Kb) (512 --&gt; 4096) --&gt; Size of private heap (Kb) (64 --&gt; 256) --&gt; Size of shared heap (Kb) (64 --&gt; 256) --&gt; Maximum number of POSIX timers per process (128 --&gt; 512) --&gt; Drivers --&gt; RTnet --&gt; RTnet, TCP/IP socket interface (Enable) --&gt; Drivers --&gt; New intel(R) PRO/1000 PCIe (Enable) --&gt; Realtek 8169 (Enable) --&gt; Loopback (Enable) --&gt; Add-Ons --&gt; Real-Time Capturing Support (Enable)* Power management and ACPI options --&gt; CPU Frequency scaling --&gt; CPU Frequency scaling (Disable) --&gt; ACPI (Advanced Configuration and Power Interface) Support --&gt; Processor (Disable) --&gt; CPU Idle --&gt; CPU idle PM support (Disable)* Pocessor type and features --&gt; Enable maximum number of SMP processors and NUMA nodes (Disable) // Ref : http://xenomai.org/pipermail/xenomai/2017-September/037718.html --&gt; Processor family --&gt; Core 2/newer Xeon (if &quot;cat /proc/cpuinfo | grep family&quot; returns 6, set as Generic otherwise) // Xenomai will issue a warning about CONFIG_MIGRATION, disable those in this order --&gt; Transparent Hugepage Support (Disable) --&gt; Allow for memory compaction (Disable) --&gt; Contiguous Memory Allocation (Disable) --&gt; Allow for memory compaction --&gt; Page Migration (Disable)* Device Drivers --&gt; Staging drivers --&gt; Unisys SPAR driver support --&gt; Unisys visorbus driver (Disable) ​","categories":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]},{"title":"x86工控机搭建ubuntu18+xenomai实时系统","slug":"servoCtrl/x86工控机搭建ubuntu18-xenomai实时系统","date":"2022-09-27T08:37:14.000Z","updated":"2022-10-16T03:34:15.764Z","comments":true,"path":"2022/09/27/servoCtrl/x86工控机搭建ubuntu18-xenomai实时系统/","link":"","permalink":"http://example.com/2022/09/27/servoCtrl/x86%E5%B7%A5%E6%8E%A7%E6%9C%BA%E6%90%AD%E5%BB%BAubuntu18-xenomai%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"一、安装系统及软件依赖1、系统选择选择安装 ubuntu18.04.6 LTS 2、软件依赖1sudo apt install libc6-dev libncurses5-dev libssl-dev build-essential bison flex lib32stdc++6 lib32z1 autoconf automake libtool pkg-config libelf-dev 3、软件版本及下载kernel: 4.9.38: https://mirrors.edge.kernel.org/pub/linux/kernel/ xenomai3.1及补丁: https://xenomai.org/downloads/ 二、配置内核1、打补丁123cd linux-4.9.38../xenomai-3.1/scripts/prepare-kernel.sh --arch=x86_64 --ipipe=ipipe-core-4.9.38-x86-3.patch 2、安装内核管理包1sudo apt install kernel-package 在弹出的界面中选择 “keep the local version…….” 3、配置kernel1make menuconfig 安装附录中的选项配置内核，去除xenomai相关的警告 4、去除编译错误1vi .config 找到SYSTEM_TRUSTED_KEYS将其赋值为空，使用#注释掉CONFIG_DEBUG_INFO_BTF 12SYSTEM_TRUSTED_KEYS=&quot;&quot;#CONFIG_DEBUG_INFO_BTF 5、编译内核1CONCURRENCY_LEVEL=$(nproc) make-kpkg --rootcmd fakeroot --initrd kernel_image kernel_headers 6、参考文档https://blog.csdn.net/qq_28882933/article/details/123626659?spm=1001.2014.3001.5502 三、安装新内核并修改grub1、安装内核编译完成后会在上一层目录生成对应的deb安装包 12cd ..sudo dpkg -i *.deb 2、增加非root用户123sudo addgroup xenomai --gid 1234sudo addgroup root xenomaisudo usermod -a -G xenomai $USER 3、查看当前系统下的所有可用内核1cat /boot/grub/grub.cfg | grep menuentry 记住刚才安装的实时内核下标号 4、修改grub启动项1sudo vi /etc/default/grub 倒数第二个选项，要在后面加命令行“xenomai.allowed_group=1234”即上步骤新增的组，具体修改如下: 5、更新grub12sudo update-grubsudo reboot 四、安装xenomai1、编译源文件1234567cd xenomai-3.1./configure --with-pic --with-core=cobalt --enable-smp --disable-tls --enable-dlopen-libs --disable-clock-monotonic-rawmake -j`nproc`sudo make install 2、配置系统路径12345678910111213echo &#x27;### Xenomaiexport XENOMAI_ROOT_DIR=/usr/xenomaiexport XENOMAI_PATH=/usr/xenomaiexport PATH=$PATH:$XENOMAI_PATH/bin:$XENOMAI_PATH/sbinexport PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$XENOMAI_PATH/lib/pkgconfigexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$XENOMAI_PATH/libexport OROCOS_TARGET=xenomai&#x27; &gt;&gt; ~/.xenomai_rcecho &#x27;source ~/.xenomai_rc&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc 3、实时性测试123sudo chmod -R 777 /dev/rtdm/memdev-privatesudo chmod -R 777 /dev/rtdm/memdev-sharedxeno latency 4、修改 lat best为负的方法123sudo suecho 0 &gt; /proc/xenomai/latencyxeno latency 运行一小段时间待其稳定后查看此时lat best 的数值, 将此数值乘1000 后重新echo 1echo value*1000 &gt; /proc/xenomai/latency 五、添加库文件供程序链接如果没有将xenomai的库添加到系统路径中，程序在链接的时候就会出现 error: while loading shared libraries... 解决： 123sudo vi /etc/ld.so.conf/usr/xenomai/lib //文件中增加这一行sudo ldconfig -v //使其生效 六、内核配置附录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 #进入menuconfig界面，会看影响xenomai实时性的警告信息：#*** WARNING! Page migration (CONFIG_MIGRATION) may increase ***#*** latency. ***#*** WARNING! At least one of APM, CPU frequency scaling, ACPI ‘processor‘ ***#*** or CPU idle features is enabled. Any of these options may ***#*** cause troubles with Xenomai. You should disable them. ***#具体配置如下所示： * General setup --&gt; Local version - append to kernel release: -xenomai-3.1 --&gt; Timers subsystem --&gt; High Resolution Timer Support (Enable) * Xenomai/cobalt --&gt; Sizes and static limits --&gt; Number of registry slots (512 --&gt; 4096) --&gt; Size of system heap (Kb) (512 --&gt; 4096) --&gt; Size of private heap (Kb) (64 --&gt; 256) --&gt; Size of shared heap (Kb) (64 --&gt; 256) --&gt; Maximum number of POSIX timers per process (128 --&gt; 512) --&gt; Drivers --&gt; RTnet --&gt; RTnet, TCP/IP socket interface (Enable) --&gt; Drivers --&gt; New intel(R) PRO/1000 PCIe (Enable) --&gt; Realtek 8169 (Enable) --&gt; Loopback (Enable) --&gt; Add-Ons --&gt; Real-Time Capturing Support (Enable) * Power management and ACPI options --&gt; CPU Frequency scaling --&gt; CPU Frequency scaling (Disable) --&gt; ACPI (Advanced Configuration and Power Interface) Support --&gt; Processor (Disable) --&gt; CPU Idle --&gt; CPU idle PM support (Disable) * Pocessor type and features --&gt; Enable maximum number of SMP processors and NUMA nodes (Disable) // Ref : http://xenomai.org/pipermail/xenomai/2017-September/037718.html --&gt; Processor family --&gt; Core 2/newer Xeon (if &quot;cat /proc/cpuinfo | grep family&quot; returns 6, set as Generic otherwise) // Xenomai will issue a warning about CONFIG_MIGRATION, disable those in this orde --&gt; Transparent Hugepage Support (Disable) --&gt; Allow for memory compaction (Disable) --&gt; Contiguous Memory Allocation (Disable) --&gt; Allow for memory compaction --&gt; Page Migration (Disable) * Device Drivers --&gt; Staging drivers --&gt; Unisys SPAR driver support --&gt; Unisys visorbus driver (Disable)","categories":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]},{"title":"ubuntu安装hexo踩坑","slug":"ubuntu/ubuntu安装hexo踩坑","date":"2022-09-27T07:04:27.000Z","updated":"2022-10-16T03:33:43.945Z","comments":true,"path":"2022/09/27/ubuntu/ubuntu安装hexo踩坑/","link":"","permalink":"http://example.com/2022/09/27/ubuntu/ubuntu%E5%AE%89%E8%A3%85hexo%E8%B8%A9%E5%9D%91/","excerpt":"","text":"软件问题导致无法安装HEXO现象及原因如果默认使用 1sudo apt install nodejs npm 系统会默认安装低版本的软件，然而在执行 1npm install -g hexo 会提示版本太低 解决123sudo apt install curlcurl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -sudo apt-get install -y nodejs 这就安装了高版本的软件，可以直接安装hexo. 部署到github上后网页乱码解决打开网址 http://ipaddress.com/ 右上角进行查找 assets-cdn.github.com，得到相应的IP 然后在 /etc/hosts中增加 185.199.109.153 assets-cdn.github.com 以实ip为准，如果一个ip无效，那么就多试其他ip","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]}],"categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://example.com/categories/Linux%E9%A9%B1%E5%8A%A8/"},{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"},{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Linux驱动[实践]","slug":"Linux驱动-实践","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E5%AE%9E%E8%B7%B5/"},{"name":"Linux驱动[理论]","slug":"Linux驱动-理论","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8-%E7%90%86%E8%AE%BA/"},{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"},{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]}