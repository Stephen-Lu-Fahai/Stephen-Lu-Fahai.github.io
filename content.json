{"meta":{"title":"StephenLu`s Blog","subtitle":"Embedded Software Engineering","description":"","author":"Stephen Lu","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-09-27T07:44:47.000Z","updated":"2022-09-27T07:45:37.738Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-27T07:44:42.000Z","updated":"2022-09-27T07:45:26.354Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ubuntu18安装ROS1和ROS2","slug":"ubuntu18安装ROS1和ROS2","date":"2022-10-19T11:09:38.000Z","updated":"2022-10-20T02:38:46.674Z","comments":true,"path":"2022/10/19/ubuntu18安装ROS1和ROS2/","link":"","permalink":"http://example.com/2022/10/19/ubuntu18%E5%AE%89%E8%A3%85ROS1%E5%92%8CROS2/","excerpt":"","text":"一、安装ROS11、添加源1sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; 2、设置公钥1sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 3、安装1) 安装 12sudo apt updatesudo apt install ros-melodic-desktop-full 4、初始化1sudo rosdep init 如果遇到问题，那就在 /etc/hosts后面添加 123456789101112131415161718192021222324252627282930313233343536373839199.232.28.133 raw.githubusercontent.com192.30.253.118 gist.github.com185.199.110.153 github.io151.101.113.194 github.global.ssl.fastly.net52.216.227.168 github-cloud.s3.amazonaws.com52.74.223.119 github.com199.232.28.133 avatars1.githubusercontent.com199.232.28.133 avatars2.githubusercontent.com199.232.28.133 avatars0.githubusercontent.com199.232.28.133 avatars3.githubusercontent.com199.232.28.133 user-images.githubusercontent.com199.232.28.133 avatars.githubusercontent.com199.232.28.133 github.map.fastly.net199.232.28.133 avatars7.githubusercontent.com54.239.31.69 aws.amazon.com54.239.30.25 console.aws.amazon.com54.239.96.90 ap-northeast-1.console.aws.amazon.com54.240.226.81 ap-southeast-1.console.aws.amazon.com54.240.193.125 ap-southeast-2.console.aws.amazon.com54.239.54.102 eu-central-1.console.aws.amazon.com177.72.244.194 sa-east-1.console.aws.amazon.com176.32.114.59 eu-west-1.console.aws.amazon.com54.239.31.128 us-west-1.console.aws.amazon.com54.240.254.230 us-west-2.console.aws.amazon.com54.239.38.102 s3-console-us-standard.console.aws.amazon.com54.231.49.3 s3.amazonaws.com52.219.0.4 s3-ap-northeast-1.amazonaws.com54.231.242.170 s3-ap-southeast-1.amazonaws.com54.231.251.21 s3-ap-southeast-2.amazonaws.com54.231.193.37 s3-eu-central-1.amazonaws.com52.218.16.140 s3-eu-west-1.amazonaws.com52.92.72.2 s3-sa-east-1.amazonaws.com54.231.236.6 s3-us-west-1.amazonaws.com54.231.168.160 s3-us-west-2.amazonaws.com52.216.80.48 github-cloud.s3.amazonaws.com54.231.40.3 github-com.s3.amazonaws.com52.216.20.171 github-production-release-asset-2e65be.s3.amazonaws.com52.216.228.168 github-production-user-asset-6210df.s3.amazonaws.com 接着修改/etc/resolv.conf 在其后增加 12nameserver 8.8.8.8nameserver 8.8.4.4 再次执行 sudo rosdep init 5、update根据提示执行 1rosdep update 可能会显示报错 read operation timed out，原因是raw.githubusercontent.com网站被墙掉了，解决如下： 1sudo cp -r ../ros_github/ /etc/ros/ 1) 修改路径Python配置路径 1sudo gedit /usr/lib/python2.7/dist-packages/rosdistro/__init__.py 注释第68行路径代码，然后改为 file:///etc/ros/ros_github/index-v4.yaml，如下图： 1) 修改20-default路径 改为下面的路径： 12345678sudo gedit /etc/ros/rosdep/sources.list.d/20-default.listyaml file:///etc/ros/ros_github/osx-homebrew.yaml osx#genericyaml file:///etc/ros/ros_github/base.yamlyaml file:///etc/ros/ros_github/python.yamlyaml file:///etc/ros/ros_github/ruby.yamlgbpdistro file:///etc/ros/ros_github/fuerte.yaml fuerte 再次执行 rosdep update 三、安装ROS21、设置编码123sudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8export LANG=en_US.UTF-8 2、更新软件源1234sudo apt update &amp;&amp; sudo apt install curl gnupg2 lsb-releasecurl http://repo.ros2.org/repos.key | sudo apt-key add -sudo sh -c &#x27;echo &quot;deb [arch=amd64,arm64] http://packages.ros.org/ros2/ubuntu `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros2-latest.list&#x27; 3、安装1sudo apt install ros-dashing-desktop 4、安装其他工具1234567sudo apt install python3-argcompletesource /opt/ros/dashing/setup.bashsudo apt updatesudo apt install ros-dashing-ros1-bridge 3、配置ROS1和ROS2共存界面1234567891011121314#source /opt/ros/melodic/setup.bash#source /opt/ros/dashing/setup.bash# ROS 1.0 melodic or ROS 2.0 Dashingecho Hello alvin! ROS 1.0 or ROS 2.0? 1=Melodic 2=Dashing read ROSif (($ROS==1));thensource /opt/ros/melodic/setup.bashecho &quot;Melodic&quot;elif (($ROS==2));thensource /opt/ros/dashing/setup.bashecho &quot;Dashing&quot;elseecho &quot;Non-ROS&quot;fi","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"设计模式:23--访问者模式","slug":"designPatter/设计模式-23-访问者模式","date":"2022-10-15T14:21:29.000Z","updated":"2022-10-17T09:10:13.404Z","comments":true,"path":"2022/10/15/designPatter/设计模式-23-访问者模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-23-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念1) 双重分发 accept 调用方法是 element.accept(visitor) visit调用方法是visitor.visit(element) 2) 将处理算法从数据结构中分离出来 易于增加Visitor 难以增加Element Element必须向Visitor公开足够的信息 2、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:22--模板方法模式","slug":"designPatter/设计模式-22-模板方法模式","date":"2022-10-15T14:21:07.000Z","updated":"2022-10-17T09:10:09.380Z","comments":true,"path":"2022/10/15/designPatter/设计模式-22-模板方法模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-22-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念在父类中定义处理流程的框架，在子类中实现具体处理 2、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:21--策略模式","slug":"designPatter/设计模式-21-策略模式","date":"2022-10-15T14:20:44.000Z","updated":"2022-10-17T09:10:04.256Z","comments":true,"path":"2022/10/15/designPatter/设计模式-21-策略模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-21-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念将算法与其它部分分离开，只定义与算法相关的接口，然后在程序中以委托的方式来使用 使用委托这种弱关联关系可以很方便地整体替换算法。 程序运行过程中也可以替换算法 2、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:20--状态模式","slug":"designPatter/设计模式-20-状态模式","date":"2022-10-15T14:20:27.000Z","updated":"2022-10-17T09:09:59.808Z","comments":true,"path":"2022/10/15/designPatter/设计模式-20-状态模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-20-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念用类表示状态，通过切换类改变对象状态 2、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:19--观察者模式","slug":"designPatter/设计模式-19-观察者模式","date":"2022-10-15T14:20:06.000Z","updated":"2022-10-17T09:09:55.020Z","comments":true,"path":"2022/10/15/designPatter/设计模式-19-观察者模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-19-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念观察对象的状态发生变化时，通知给观察者。 观察者模式适用于根据对象状态进行相应处理的场景。 2、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:18--备忘录模式","slug":"designPatter/设计模式-18-备忘录模式","date":"2022-10-15T14:19:47.000Z","updated":"2022-10-17T09:09:51.500Z","comments":true,"path":"2022/10/15/designPatter/设计模式-18-备忘录模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-18-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念记录对象状态 Undo撤销 Redo恢复 History 历史 Snapshot快照 2、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:17--中介模式","slug":"designPatter/设计模式-17-中介模式","date":"2022-10-15T14:19:32.000Z","updated":"2022-10-17T09:09:47.432Z","comments":true,"path":"2022/10/15/designPatter/设计模式-17-中介模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-17-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念可以使对象之间的关系数量急剧减少 中转作用（结构性） 协调作用（行为性） 2、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:16--迭代模式","slug":"designPatter/设计模式-16-迭代模式","date":"2022-10-15T14:19:03.000Z","updated":"2022-10-17T09:09:43.924Z","comments":true,"path":"2022/10/15/designPatter/设计模式-16-迭代模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-16-%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念访问一个聚合对象的内容而无需暴露其内部实现 支持对聚合对象的多种遍历 为遍历不同的聚合结构提供统一的接口 健壮性考虑：遍历的同时更改迭代器所在聚合结构，会导致问题 2、UML 二、案例1、案例11 2、案例21","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:15--解释器模式","slug":"designPatter/设计模式-15-解释器模式","date":"2022-10-15T14:18:43.000Z","updated":"2022-10-17T12:58:50.004Z","comments":true,"path":"2022/10/15/designPatter/设计模式-15-解释器模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-15-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。 2、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class Variable;class Context&#123;public: void registerVariable(Variable *var, int value) &#123; m_map.insert(&#123; var, value &#125;); &#125; int lookUpValue(Variable *var) &#123; auto itor = m_map.find(var); if (itor != m_map.end()) &#123; return itor-&gt;second; &#125; return 0; &#125;private: std::unordered_map&lt;Variable *, int&gt; m_map;&#125;;class Expression&#123;public: virtual ~Expression() &#123;&#125; virtual int interpret(Context *ctx) = 0;&#125;;class Variable : public Expression&#123;public: virtual int interpret(Context *ctx) &#123; return ctx-&gt;lookUpValue(this); &#125;&#125;;class Constant : public Expression&#123;public: Constant(int value) : m_value(value) &#123;&#125; virtual int interpret(Context *ctx) override &#123; return m_value; &#125;private: int m_value;&#125;;class Add : public Expression&#123;public: Add(Expression *left, Expression *right) : m_left(left), m_right(right) &#123;&#125; virtual int interpret(Context *ctx) override &#123; return m_left-&gt;interpret(ctx) + m_right-&gt;interpret(ctx); &#125;private: Expression *m_left, *m_right;&#125;;class Sub : public Expression&#123;public: Sub(Expression *left, Expression *right) : m_left(left), m_right(right) &#123;&#125; virtual int interpret(Context *ctx) override &#123; return m_left-&gt;interpret(ctx) - m_right-&gt;interpret(ctx); &#125;private: Expression *m_left, *m_right;&#125;;class Mul : public Expression&#123;public: Mul(Expression *left, Expression *right) : m_left(left), m_right(right) &#123;&#125; virtual int interpret(Context *ctx) override &#123; return m_left-&gt;interpret(ctx) * m_right-&gt;interpret(ctx); &#125;private: Expression *m_left, *m_right;&#125;;class Div : public Expression&#123;public: Div(Expression *left, Expression *right) : m_left(left), m_right(right) &#123;&#125; virtual int interpret(Context *ctx) override &#123; assert(m_right-&gt;interpret(ctx) != 0); return m_left-&gt;interpret(ctx) / m_right-&gt;interpret(ctx); &#125;private: Expression *m_left, *m_right;&#125;;int main()&#123; Context ctx; Variable a; Variable b; Constant c(1024); ctx.registerVariable(&amp;a, 22); ctx.registerVariable(&amp;b, 11); Expression *e1 = new Mul(&amp;a, &amp;b); //242 Expression *e2 = new Div(&amp;a, &amp;b); //1 Expression *e3 = new Add(e2, &amp;c); //1025 Expression *e = new Sub(e1, e3); std::cout &lt;&lt; e-&gt;interpret(&amp;ctx) &lt;&lt; std::endl; delete e1, e2, e3, e; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:14--命令模式","slug":"designPatter/设计模式-14-命令模式","date":"2022-10-15T14:18:23.000Z","updated":"2022-10-17T12:53:41.345Z","comments":true,"path":"2022/10/15/designPatter/设计模式-14-命令模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-14-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念用一个类表示“请进行这项工作”的命令 2、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class ICommand&#123;public: virtual ~ICommand() &#123;&#125; virtual void execute() = 0;&#125;;class Drawable&#123;public: virtual ~Drawable() &#123;&#125; virtual void draw(int x, int y) = 0;&#125;;class MacroCommand : public ICommand&#123;public: ~MacroCommand() &#123; clear(); &#125; virtual void execute() override &#123; for (auto cmd : m_commandList) &#123; cmd-&gt;execute(); &#125; &#125; void addCommand(ICommand *cmd) &#123; m_commandList.push_back(cmd); &#125; void clear() &#123; for (auto cmd : m_commandList) &#123; delete cmd; &#125; m_commandList.clear(); &#125; void undo() &#123; if (!m_commandList.empty()) &#123; auto cmd = m_commandList.back(); delete cmd; m_commandList.pop_back(); &#125; &#125;private: std::vector&lt;ICommand *&gt; m_commandList;&#125;;class DrawCommand : public ICommand&#123;public: DrawCommand(int x, int y, Drawable *drawable) : m_x(x), m_y(y), m_drawable(drawable) &#123;&#125; virtual void execute() override &#123; m_drawable-&gt;draw(m_x, m_y); &#125;private: int m_x; int m_y; Drawable *m_drawable;&#125;;class DrawCanvas : public Drawable&#123;public: DrawCanvas(MacroCommand *macroCommand) : m_macroCommand(macroCommand) &#123;&#125; virtual void draw(int x, int y) override &#123; std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; std::endl; &#125; void paint() &#123; m_macroCommand-&gt;execute(); &#125;private: MacroCommand *m_macroCommand;&#125;;int main()&#123; MacroCommand macroCommand; DrawCanvas canvas(&amp;macroCommand); macroCommand.addCommand(new DrawCommand(1, 2, &amp;canvas)); canvas.draw(20, 10); canvas.paint(); return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:13--责任链模式","slug":"designPatter/设计模式-13-责任链模式","date":"2022-10-15T14:18:06.000Z","updated":"2022-10-19T10:39:11.317Z","comments":true,"path":"2022/10/15/designPatter/设计模式-13-责任链模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-13-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念甩锅 2、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class Trouble &#123;public: Trouble(int number) : m_number(number) &#123;&#125; int getNumber() const &#123; return m_number; &#125; std::string toString() const &#123; return &quot;[ Trouble &quot; + std::to_string(m_number) + &quot; ]&quot;; &#125;private: int m_number;&#125;;class Support &#123;public: virtual ~Support() &#123;&#125; Support(const std::string &amp;name) : m_name(name) &#123;&#125; Support *setNext(Support *next) &#123; m_next = next; return next; &#125; void support(Trouble *trouble) &#123; if (resolve(trouble)) done(trouble); else if (m_next) m_next-&gt;support(trouble); else fail(trouble); &#125; std::string toString() const &#123; return &quot;[&quot; + m_name + &quot;]&quot;; &#125; virtual bool resolve(Trouble *trouble) = 0;protected: void done(Trouble *trouble) &#123; std::cout &lt;&lt; trouble-&gt;toString() &lt;&lt; &quot; is solved by &quot; &lt;&lt; toString() &lt;&lt; std::endl; &#125; void fail(Trouble *trouble) &#123; std::cout &lt;&lt; trouble-&gt;toString() &lt;&lt; &quot; cannot be resolved.&quot; &lt;&lt; std::endl; &#125;private: std::string m_name; Support *m_next = nullptr;&#125;;class NoSupport : public Support &#123;public: using Support::Support; virtual bool resolve(Trouble *trouble) override &#123; return false; &#125;&#125;;class OddSupport : public Support &#123;public: using Support::Support; virtual bool resolve(Trouble *trouble) override &#123; return (trouble-&gt;getNumber() % 2 == 0); &#125;&#125;;class LimitSupport : public Support &#123;public: LimitSupport(const std::string &amp;name, int limit) : Support(name), m_limit(limit)&#123;&#125; virtual bool resolve(Trouble *trouble) override &#123; return (trouble-&gt;getNumber() &lt;= m_limit); &#125;private: int m_limit;&#125;;class SpecialSupport : public Support &#123;public: SpecialSupport(const std::string &amp;name, int num) : Support(name), m_num (num) &#123;&#125; virtual bool resolve(Trouble *trouble) override &#123; return (trouble-&gt;getNumber() == m_num); &#125; private: int m_num;&#125;;int main()&#123; Support *s1 = new NoSupport(&quot;Alance&quot;); Support *s2 = new LimitSupport(&quot;Bob&quot;, 30); Support *s3 = new OddSupport(&quot;Charlie&quot;); Support *s4 = new SpecialSupport(&quot;David&quot;, 55); s1-&gt;setNext(s2)-&gt;setNext(s3)-&gt;setNext(s4); for (int i = 0; i &lt; 100; ++i) &#123; Trouble t(i); s1-&gt;support(&amp;t); &#125; delete s1; delete s2; delete s3; delete s4; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:12--代理模式","slug":"designPatter/设计模式-12-代理模式","date":"2022-10-15T14:17:42.000Z","updated":"2022-10-19T10:34:39.138Z","comments":true,"path":"2022/10/15/designPatter/设计模式-12-代理模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-12-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念部分工作交给代理人 2、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class Printable &#123;public: virtual ~Printable() &#123;&#125; virtual void setPrinterName(const std::string &amp;name) = 0; virtual const std::string &amp;getPrinterName() const = 0; virtual void print() = 0;&#125;;class Printer : public Printable &#123;public: Printer(const std::string &amp;name) : m_name(name) &#123; heavyJob(); &#125; virtual void setPrinterName(const std::string &amp;name) override &#123; m_name = name; &#125; virtual const std::string &amp;getPrinterName() const &#123; return m_name; &#125; void print() override &#123; std::cout &lt;&lt; __FUNCTION__ &lt;&lt; getPrinterName() &lt;&lt; std::endl; &#125;private: void heavyJob() &#123; std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot; start &quot; &lt;&lt; std::endl; for (int i = 0; i &lt; 5; ++i) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(300)); &#125; std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot; end &quot; &lt;&lt; std::endl; &#125;private: std::string m_name;&#125;;class PrinterProxy : public Printable &#123;public: PrinterProxy(const std::string &amp;name) : m_name(name) &#123;&#125; ~PrinterProxy() &#123; delete m_printer; &#125; virtual void setPrinterName(const std::string &amp;name) override &#123; if (m_printer != nullptr) &#123; m_printer-&gt;setPrinterName(name); &#125; m_name = name; &#125; virtual const std::string &amp;getPrinterName() const override &#123; return m_name; &#125; void print() override &#123; if (nullptr == m_printer)&#123; m_printer = new Printer(m_name); &#125; m_printer-&gt;print(); &#125;private: Printer *m_printer = nullptr; std::string m_name;&#125;;int main()&#123; Printable *p = new PrinterProxy(&quot;123&quot;); std::cout &lt;&lt; p-&gt;getPrinterName() &lt;&lt; std::endl; p-&gt;setPrinterName(&quot;456&quot;); std::cout &lt;&lt; p-&gt;getPrinterName() &lt;&lt; std::endl; p-&gt;print(); p-&gt;setPrinterName(&quot;789&quot;); p-&gt;print(); delete p; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:11--享元模式","slug":"designPatter/设计模式-11-享元模式","date":"2022-10-15T14:17:27.000Z","updated":"2022-10-17T12:48:50.530Z","comments":true,"path":"2022/10/15/designPatter/设计模式-11-享元模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-11-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念尽量共享实例避免new出实例。 2、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;static const char *strList[] = &#123; &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;......##........\\n&quot; &quot;..######........\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;..##########....\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..........##....\\n&quot; &quot;......####......\\n&quot; &quot;....##..........\\n&quot; &quot;..##............\\n&quot; &quot;..##########....\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..........##....\\n&quot; &quot;......####......\\n&quot; &quot;..........##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;........##......\\n&quot; &quot;......####......\\n&quot; &quot;....##..##......\\n&quot; &quot;..##....##......\\n&quot; &quot;..########......\\n&quot; &quot;........##......\\n&quot; &quot;......######....\\n&quot; &quot;................\\n&quot;, &quot;..##########....\\n&quot; &quot;..##............\\n&quot; &quot;..##............\\n&quot; &quot;..########......\\n&quot; &quot;..........##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##............\\n&quot; &quot;..########......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;..##########....\\n&quot; &quot;..##......##....\\n&quot; &quot;..........##....\\n&quot; &quot;........##......\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;......##........\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;....######......\\n&quot; &quot;..##......##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....########....\\n&quot; &quot;..........##....\\n&quot; &quot;..##......##....\\n&quot; &quot;....######......\\n&quot; &quot;................\\n&quot;, &quot;................\\n&quot; &quot;................\\n&quot; &quot;................\\n&quot; &quot;................\\n&quot; &quot;..##########....\\n&quot; &quot;................\\n&quot; &quot;................\\n&quot; &quot;................\\n&quot; &#125;;class BigChar&#123;public: BigChar(int order) : m_char(strList[order % 11]) &#123;&#125; void show() &#123; std::cout &lt;&lt; m_char &lt;&lt; std::endl; &#125;private: const char *m_char;&#125;;class BigCharFactory&#123;public: ~BigCharFactory() &#123; for (auto i : m_map) &#123; delete i.second; &#125; m_map.clear(); &#125; BigChar *getBigChar(int order) &#123; BigChar *b = nullptr; int tOrder = order % 11; auto it = m_map.find(tOrder); if (it == m_map.end()) &#123; b = new BigChar(tOrder); m_map.insert(&#123; tOrder, b &#125;); return b; &#125; else &#123; return it-&gt;second; &#125; &#125;private: std::unordered_map&lt;int, BigChar *&gt; m_map;&#125;;int main()&#123; BigCharFactory f; for (int i = 0; i &lt; 20; ++i) &#123; for (int j = 0; j &lt; 2; ++j) &#123; BigChar *b = f.getBigChar(i); std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; std::endl; b-&gt;show(); &#125; &#125; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:10--外观模式","slug":"designPatter/设计模式-10-外观模式","date":"2022-10-15T14:16:48.000Z","updated":"2022-10-17T09:18:29.404Z","comments":true,"path":"2022/10/15/designPatter/设计模式-10-外观模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-10-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念为互相关联在一起的错综复杂的类整理出高层接口，Facade角色对外只有一个简单的接口。 Facade角色还会考虑到系统内部各个类之间的责任和依赖关系，按照正确的顺序调用各个类。 2、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;using namespace std;class DataBase &#123;public: ~DataBase() = default; static DataBase &amp;GetInstance() &#123; static DataBase db; return db; &#125; std::string getNameByEmail(const std::string &amp;email) const &#123; auto it = m_map.find(email); if (it != m_map.end()) return it-&gt;second; else return &#123;&#125;; &#125;protected: DataBase(const DataBase &amp;) = delete; DataBase(DataBase &amp;&amp;) = delete; DataBase &amp;operator=(const DataBase &amp;) = delete; DataBase &amp;operator=(DataBase &amp;&amp;) = delete;private: DataBase() &#123;&#125;private: std::unordered_map&lt;std::string, std::string&gt; m_map&#123; &#123; &quot;zhangsan@zhangsan.com&quot;, &quot;zhangsan&quot; &#125;, &#123; &quot;lisi@lisi.com&quot;, &quot;lisi&quot; &#125;, &#123; &quot;wangwu@wangwu.com&quot;, &quot;wangwu&quot; &#125; &#125;;&#125;;class HtmlWriter&#123;public: void title(const std::string &amp;title) &#123; m_ss &lt;&lt; &quot;&lt;html&gt;&quot; &lt;&lt; &quot;&lt;head&gt;&quot; &lt;&lt; &quot;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&quot; &lt;&lt; &quot;&lt;/head&gt;&quot; &lt;&lt; &quot;&lt;body&gt;\\n&quot; &lt;&lt; &quot;&lt;h1&gt;&quot; + title + &quot;&lt;/h1&gt;\\n&quot;; &#125; void paragraph(const std::string &amp;msg) &#123; m_ss &lt;&lt; &quot;&lt;p&gt;&quot; + msg + &quot;&lt;/p&gt;\\n&quot;; &#125; void link(const std::string &amp;herf, const std::string &amp;caption) &#123; paragraph(&quot;&lt;a herf=\\&quot;&quot; + herf + &quot;\\&quot;&gt;&quot; + caption + &quot;&lt;/a&gt;&quot;); &#125; void mailto(const std::string &amp;mailAddr, const std::string &amp;userName)&#123; link(&quot;mailto:&quot; + mailAddr, userName); &#125; void close() &#123; m_ss &lt;&lt; &quot;&lt;/body&gt;&quot; &lt;&lt; &quot;&lt;/html&gt;\\n&quot;; &#125; std::string toString() const &#123; return m_ss.str(); &#125;private: std::stringstream m_ss;&#125;;class PageMaker&#123;public: ~PageMaker() = default; PageMaker(const PageMaker &amp;) = delete; PageMaker(PageMaker &amp;&amp;) = delete; PageMaker &amp;operator=(const PageMaker &amp;) = delete; PageMaker &amp;operator=(PageMaker &amp;&amp;) = delete; static PageMaker &amp;GetInstance() &#123; static PageMaker pm; return pm; &#125; void makeWelcomePage(const std::string &amp;mailAddr) &#123; auto name = DataBase::GetInstance().getNameByEmail(mailAddr); HtmlWriter writer; writer.title(&quot;Welcome to &quot; + name + &quot;&#x27;s page!&quot;); writer.paragraph(name + u8&quot;欢迎来到&quot; + name + u8&quot;的主页.&quot;); writer.paragraph(u8&quot;等着你的邮件哦！&quot;); writer.mailto(mailAddr, name); writer.close(); std::cout &lt;&lt; writer.toString() &lt;&lt; std::endl; &#125;protected: PageMaker() &#123;&#125;private:&#125;;int main()&#123; assert(DataBase::GetInstance().getNameByEmail(&quot;&quot;).empty()); PageMaker::GetInstance().makeWelcomePage(&quot;zhangsan@zhangsan.com&quot;); return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:09--装饰模式","slug":"designPatter/设计模式-09-装饰模式","date":"2022-10-15T14:16:29.000Z","updated":"2022-10-19T10:41:56.707Z","comments":true,"path":"2022/10/15/designPatter/设计模式-09-装饰模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-09-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念不断地为对象添加装饰 特性： 接口透明 不改变装饰物的前提下，增加功能 动态增加功能 只需要一些装饰物，即可添加很多功能 缺点： 增加许多功能类似的小类 2、UML 二、案例1、案例11 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;class IDisplay &#123;public: virtual ~IDisplay() &#123;&#125; virtual int getRows() const = 0; virtual int getColumns() const = 0; virtual std::string getRow(int index) const = 0; void show() &#123; int r = getRows(); for (int i = 0; i &lt; r; ++i) &#123; std::cout &lt;&lt; getRow(i) &lt;&lt; std::endl; &#125; &#125;&#125;;class StringDisplay : public IDisplay &#123;public: StringDisplay(const std::string &amp;str) : m_str(str) &#123;&#125; virtual int getRows() const override &#123; return 1; &#125; virtual int getColumns() const override &#123; return static_cast&lt;int&gt;(m_str.length()); &#125; virtual std::string getRow(int index) const override &#123; if (index == 0) return m_str; else return &#123;&#125;; &#125;private: std::string m_str;&#125;;class Border : public IDisplay &#123;public: Border(IDisplay *display) : m_display(display) &#123;&#125; virtual ~Border() &#123; delete m_display; &#125;protected: IDisplay *m_display;&#125;;class FullBorder : public Border &#123;public: FullBorder(IDisplay *display) : Border(display) &#123;&#125; virtual int getRows() const override &#123; return 1 + m_display-&gt;getRows() + 1; &#125; virtual int getColumns() const override &#123; return 1 + m_display-&gt;getColumns() + 1; &#125; virtual std::string getRow(int index) const override &#123; if (index == 0) return &quot;+&quot; + makeLine(&#x27;-&#x27;, m_display-&gt;getColumns()) + &quot;+&quot;; else if (index == m_display-&gt;getRows() + 1) return &quot;+&quot; + makeLine(&#x27;-&#x27;, m_display-&gt;getColumns()) + &quot;+&quot;; else return &quot;|&quot; + m_display-&gt;getRow(index - 1) + &quot;|&quot;; &#125;private: std::string makeLine(char ch, int count) const &#123; std::string str; str.resize(count, ch); return str; &#125;&#125;;class SideBorder : public Border &#123;public: SideBorder(IDisplay *display, const char &amp;borderChar) : Border(display), m_borderChar(borderChar) &#123;&#125; virtual int getRows() const override &#123; return m_display-&gt;getRows(); &#125; virtual int getColumns() const override &#123; return 1 + m_display-&gt;getColumns() + 1; &#125; virtual std::string getRow(int index) const override &#123; return m_borderChar + m_display-&gt;getRow(index) + m_borderChar; &#125;private: char m_borderChar;&#125;;int main()&#123; IDisplay *d1 = new StringDisplay(&quot;Hello&quot;); assert(d1-&gt;getRow(-1).empty()); IDisplay *d2 = new SideBorder(d1, &#x27;#&#x27;); IDisplay *d3 = new FullBorder(d2); d1-&gt;show(); d2-&gt;show(); d3-&gt;show(); IDisplay *d4 = new SideBorder(new FullBorder(new FullBorder(new SideBorder(new FullBorder(new StringDisplay(&quot;Hello,World&quot;)), &#x27;*&#x27;))), &#x27;/&#x27;); d4-&gt;show(); delete d1; delete d4; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:08--组合模式","slug":"designPatter/设计模式-08-组合模式","date":"2022-10-15T14:16:07.000Z","updated":"2022-10-19T10:40:39.150Z","comments":true,"path":"2022/10/15/designPatter/设计模式-08-组合模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-08-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念使容器与内容具有一致性(也可以称作多个与单个的一致性)，创造出递归结构的模式。 2、UML 二、案例1、案例12、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;class Entry &#123;public: virtual ~Entry() &#123;&#125; virtual std::string getName() const = 0; virtual int getSize() const = 0; virtual void addEntryy(Entry *entry) &#123;&#125; virtual void printList(const std::string &amp;str) = 0; void printList() &#123; printList(&quot;&quot;); &#125; std::string toString() const &#123; return getName() + &quot; (&quot; + std::to_string(getSize()) + &quot;)&quot;; &#125;&#125;;class File : public Entry &#123;public: File(const std::string &amp;name, int size) : m_name(name), m_size(size) &#123;&#125; virtual std::string getName() const override &#123; return m_name; &#125; virtual int getSize() const override &#123; return m_size; &#125; virtual void printList(const std::string &amp;str) override &#123; std::cout &lt;&lt; str &lt;&lt; &quot;/&quot; &lt;&lt; toString() &lt;&lt; std::endl; &#125;private: std::string m_name; int m_size;&#125;;class Directory : public Entry &#123;public: Directory(const std::string &amp;name) : m_name(name) &#123;&#125; ~Directory() &#123; for (auto it : m_dirs) &#123; delete it; &#125; m_dirs.clear(); &#125; virtual std::string getName() const override &#123; return m_name; &#125; virtual int getSize() const &#123; int size = 0; for (auto it : m_dirs) &#123; size += it-&gt;getSize(); &#125; return size; &#125; virtual void addEntryy(Entry *entry) override &#123; m_dirs.push_back(entry); &#125; virtual void printList(const std::string &amp;str) override &#123; std::cout &lt;&lt; str &lt;&lt; &quot;/&quot; &lt;&lt; toString() &lt;&lt; std::endl; for (auto it : m_dirs) &#123; it-&gt;printList(str + &quot;/&quot; + m_name); &#125; &#125;private: std::string m_name; std::vector&lt;Entry *&gt; m_dirs;&#125;;int main()&#123; Directory *root = new Directory(&quot;root&quot;); Directory *bin = new Directory(&quot;bin&quot;); Directory *tmp = new Directory(&quot;tmp&quot;); Directory *usr = new Directory(&quot;usr&quot;); root-&gt;addEntryy(bin); root-&gt;addEntryy(tmp); root-&gt;addEntryy(usr); bin-&gt;addEntryy(new File(&quot;vi&quot;, 3000)); bin-&gt;addEntryy(new File(&quot;latex&quot;, 2000)); static_cast&lt;Entry *&gt;(root)-&gt;printList(); Directory *yuki = new Directory(&quot;yuki&quot;); Directory *hanako = new Directory(&quot;hanako&quot;); Directory *tomura = new Directory(&quot;tomura&quot;); usr-&gt;addEntryy(yuki); usr-&gt;addEntryy(hanako); usr-&gt;addEntryy(tomura); yuki-&gt;addEntryy(new File(&quot;diary.html&quot;, 100)); hanako-&gt;addEntryy(new File(&quot;memo.tex&quot;, 1024)); tomura-&gt;addEntryy(new File(&quot;junk.mail&quot;, 40)); static_cast&lt;Entry *&gt;(root)-&gt;printList(); // for test coverage &#123; File *f = new File(&quot;123.txt&quot;, 1); f-&gt;addEntryy(root); f-&gt;printList(&quot;&quot;); delete f; &#125; &#123; yuki-&gt;printList(&quot;&quot;); &#125; &#123; File *f = new File(&quot;123.txt&quot;, 1); Entry *e = new Directory(&quot;test&quot;); e-&gt;addEntryy(f); e-&gt;printList(&quot;&quot;); e-&gt;toString(); delete e; &#125; delete root; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:07--桥接模式","slug":"designPatter/设计模式-07-桥接模式","date":"2022-10-15T14:15:47.000Z","updated":"2022-10-19T05:40:06.111Z","comments":true,"path":"2022/10/15/designPatter/设计模式-07-桥接模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-07-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念用于分离 类的功能层次结构 和 类的实现层次结构 2、UML 二、案例1、案例11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;class Game &#123;public: Game()&#123;&#125; virtual ~Game()&#123;&#125; virtual void play() = 0;private:&#125;;class GameA : public Game &#123;public: GameA()&#123;&#125; void play()&#123; printf(&quot;Jungle play gameA\\n&quot;); &#125;&#125;;class GameB : public Game &#123;public: GameB()&#123;&#125; void play()&#123; printf(&quot;Jungle play gameB\\n&quot;); &#125;&#125;;class Phone &#123;public: Phone()&#123;&#125; virtual ~Phone()&#123;&#125; virtual void setupGame(Game *igame) = 0; virtual void play() = 0;private: Game *game;&#125;;class PhoneA:public Phone &#123;public: PhoneA()&#123;&#125; void setupGame(Game *igame)&#123; this-&gt;game = igame; &#125; void play()&#123; this-&gt;game-&gt;play(); &#125;private: Game *game;&#125;;class PhoneB :public Phone &#123;public: PhoneB()&#123;&#125; void setupGame(Game *igame)&#123; this-&gt;game = igame; &#125; void play()&#123; this-&gt;game-&gt;play(); &#125;private: Game *game;&#125;;int main()&#123; Game *game; Phone *phone; phone = new PhoneA(); game = new GameA(); phone-&gt;setupGame(game); phone-&gt;play(); printf(&quot;++++++++++++++++++++++++++++++++++\\n&quot;); delete game; game = new GameB(); phone-&gt;setupGame(game); phone-&gt;play(); delete phone; delete game; return 0;&#125; 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;class IDisplayImpl &#123;public: virtual ~IDisplayImpl() &#123;&#125; virtual void rawOpen() = 0; virtual void rawPrint() = 0; virtual void rawClose() = 0;&#125;;class Display &#123;public: virtual ~Display() &#123;&#125; Display(IDisplayImpl *impl) : m_pImpl(impl) &#123;&#125; virtual void open() &#123; m_pImpl-&gt;rawOpen(); &#125; virtual void print() &#123; m_pImpl-&gt;rawPrint(); &#125; virtual void close() &#123; m_pImpl-&gt;rawClose(); &#125; void display() &#123; open(); print(); close(); &#125;private: IDisplayImpl *m_pImpl;&#125;;class CountDisplay : public Display &#123;public: using Display::Display; void mulitDisplay(unsigned int count) &#123; open(); for (unsigned int i = 0; i &lt; count; ++i) print(); close(); &#125;&#125;;class StringDisplayImpl : public IDisplayImpl&#123;public: StringDisplayImpl(const std::string &amp;str) : m_str(str) &#123;&#125; virtual void rawOpen() override &#123; printLine(); &#125; virtual void rawPrint() override &#123; cout &lt;&lt; &quot;|&quot; &lt;&lt; m_str &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; &#125; virtual void rawClose() override &#123; printLine(); &#125;private: void printLine() &#123; cout &lt;&lt; &quot;+&quot;; for (int i = 0; i &lt; m_str.length(); ++i) cout &lt;&lt; &quot;-&quot;; cout &lt;&lt; &quot;+&quot; &lt;&lt; endl; &#125;private: std::string m_str;&#125;;int main()&#123; std::shared_ptr&lt;IDisplayImpl&gt; impl1(new StringDisplayImpl(&quot;Hello, China&quot;)); std::shared_ptr&lt;Display&gt; d1(new Display(impl1.get())); std::shared_ptr&lt;IDisplayImpl&gt; impl2(new StringDisplayImpl(&quot;Hello, Tao&quot;)); std::shared_ptr&lt;Display&gt; d2(new CountDisplay(impl2.get())); std::shared_ptr&lt;IDisplayImpl&gt; impl3(new StringDisplayImpl(&quot;Hello,Universe&quot;)); std::shared_ptr&lt;CountDisplay&gt; d3(new CountDisplay(impl3.get())); d1-&gt;display(); d2-&gt;display(); d3-&gt;display(); d3-&gt;mulitDisplay(4); return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:06--适配器模式","slug":"designPatter/设计模式-06-适配器模式","date":"2022-10-15T14:15:26.000Z","updated":"2022-10-19T10:40:11.482Z","comments":true,"path":"2022/10/15/designPatter/设计模式-06-适配器模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-06-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念Painter为要适配的类/接口 Banner为适配者 PainterBanner是适配器。 适配器继承了Painter接口，同时继承了Banner，利用Banner已有的功能 实现Painter的接口 2、UML 二、案例1、案例11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;class Controller &#123;public: Controller()&#123;&#125; virtual ~Controller()&#123;&#125; virtual void pathPlanning() = 0;&#125;;class DxfParser &#123;public: DxfParser()&#123;&#125; void parseFile()&#123; printf(&quot;parseFile\\n&quot;); &#125;&#125;;class PathPlanner &#123;public: PathPlanner()&#123;&#125; void calculate()&#123; printf(&quot;calculate\\n&quot;); &#125;&#125;;class Adapter:public Controller &#123;public: Adapter()&#123; dxfParser = new DxfParser(); pathPlanner = new PathPlanner(); &#125; void pathPlanning()&#123; printf(&quot;pathPlanning\\n&quot;); dxfParser-&gt;parseFile(); pathPlanner-&gt;calculate(); &#125;private: DxfParser *dxfParser; PathPlanner *pathPlanner;&#125;;int main()&#123; Controller *controller = new Adapter(); controller-&gt;pathPlanning(); delete controller; return 0;&#125; 2、案例212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;class Banner &#123;public: Banner(const std::string &amp;str) : m_str(str) &#123;&#125; void showWithParen() &#123; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; m_str &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; &#125; void showWithAster() &#123; std::cout &lt;&lt; &quot;*&quot; &lt;&lt; m_str &lt;&lt; &quot;*&quot; &lt;&lt; std::endl; &#125;private: std::string m_str;&#125;;class Painter &#123;public: virtual ~Painter() &#123;&#125; virtual void printStrong() = 0; virtual void printWeak() = 0;&#125;;class PainterBanner : public Banner, public Painter &#123;public: PainterBanner(const std::string &amp;str) : Banner(str) &#123;&#125; virtual void printStrong() override &#123; showWithParen(); &#125; virtual void printWeak() override &#123; showWithAster(); &#125;&#125;;int main()&#123; Painter *painter = new PainterBanner(std::string(&quot;HelloWorld&quot;)); painter-&gt;printStrong(); painter-&gt;printWeak(); delete painter; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:05--单例模式","slug":"designPatter/设计模式-05-单例模式","date":"2022-10-15T14:14:36.000Z","updated":"2022-10-19T05:33:31.738Z","comments":true,"path":"2022/10/15/designPatter/设计模式-05-单例模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-05-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念整个软件生命周期，只存在一个对象实例 关键是构造函数私有化，不允许多次构造 实现中使用了模板+参数包的形式。 具体使用时，子类T需要继承于SingleTon&lt;T&gt;类，并设置SingleTon&lt;T&gt;为友元 2、UML 二、案例1、案例112345678910111213141516171819202122class Singleton &#123;public: static Singleton* getInstance() &#123; if (instance == NULL) &#123; m_mutex.lock(); if (instance == NULL)&#123; printf(&quot;create Singleton\\n&quot;); instance = new Singleton(); &#125; m_mutex.unlock(); &#125; return instance; &#125;private: Singleton()&#123;&#125; static Singleton* instance; static std::mutex m_mutex;&#125;;Singleton* Singleton::instance = NULL;std::mutex Singleton::m_mutex; 2、案例21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;using namespace std;template &lt;class T&gt;class SingleTon &#123;public: static T &amp;GetInstance() &#123; static T ins; return ins; &#125; SingleTon(const SingleTon &amp;) = delete; SingleTon &amp;operator=(const SingleTon &amp;) = delete; virtual ~SingleTon() &#123;&#125;protected: SingleTon() &#123;&#125;&#125;;class Apple : public SingleTon&lt;Apple&gt; &#123; friend SingleTon&lt;Apple&gt;;public: void show() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125; ~Apple() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125;protected: Apple() &#123;&#125;&#125;;class Orange : public SingleTon&lt;Orange&gt; &#123; friend SingleTon&lt;Orange&gt;;public: ~Orange() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125; void show() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125;protected: Orange()&#123;&#125;&#125;;int main()&#123; Apple::GetInstance().show(); cout &lt;&lt; &amp;Apple::GetInstance() &lt;&lt; endl; Apple::GetInstance().show(); cout &lt;&lt; &amp;Apple::GetInstance() &lt;&lt; endl; Orange::GetInstance().show(); Orange::GetInstance().show(); Orange::GetInstance().show(); return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:04--原型模式","slug":"designPatter/设计模式-04-原型模式","date":"2022-10-15T14:14:15.000Z","updated":"2022-10-19T05:31:52.713Z","comments":true,"path":"2022/10/15/designPatter/设计模式-04-原型模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-04-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念通过复制，生成实例。 2、UML 二、案例1、案例1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class WorkModel &#123;public: char *modelName; void setWorkModelName(char *iName)&#123; this-&gt;modelName = iName; &#125;&#125;;class PrototypeWork &#123;public: PrototypeWork()&#123;&#125; virtual PrototypeWork *clone() = 0;&#125;;class ConcreteWork :public PrototypeWork &#123;public: ConcreteWork()&#123;&#125; ConcreteWork(char* iName, int iIdNum, char* modelName)&#123; this-&gt;name = iName; this-&gt;idNum = iIdNum; this-&gt;workModel = new WorkModel(); this-&gt;workModel-&gt;setWorkModelName(modelName); &#125; ConcreteWork *clone()&#123; ConcreteWork *work = new ConcreteWork(); work-&gt;setName(this-&gt;name); work-&gt;setIdNum(this-&gt;idNum); work-&gt;workModel = this-&gt;workModel; return work; &#125; void setName(char* iName)&#123; this-&gt;name = iName; &#125; void setIdNum(int iIdNum)&#123; this-&gt;idNum = iIdNum; &#125; void setModel(WorkModel *iWorkModel)&#123; this-&gt;workModel = iWorkModel; &#125; void printWorkInfo()&#123; printf(&quot;name:%s\\n&quot;, this-&gt;name); printf(&quot;idNum:%d\\n&quot;, this-&gt;idNum); printf(&quot;modelName:%s\\n&quot;, this-&gt;workModel-&gt;modelName); &#125;private: char* name; int idNum; WorkModel *workModel;&#125;;int main()&#123; ConcreteWork *singleWork = new ConcreteWork(&quot;Single&quot;, 1001, &quot;Single_Model&quot;); printf(&quot;\\nSingleConcreteWork\\n&quot;); ConcreteWork *jungleWork = singleWork-&gt;clone(); printf(&quot;\\nJungleConcreteWork\\n&quot;); printf(&quot;\\njungleClone&quot;); jungleWork-&gt;setName(&quot;jungle&quot;); jungleWork-&gt;setIdNum(1002); WorkModel *jungleModel = new WorkModel(); jungleModel-&gt;setWorkModelName(&quot;Jungle_Model&quot;); jungleWork-&gt;setModel(jungleModel); printf(&quot;\\nSingleInfo\\n&quot;); singleWork-&gt;printWorkInfo(); printf(&quot;\\nJungleInfo\\n&quot;); jungleWork-&gt;printWorkInfo(); return 0;&#125; 2、案例2``` C #include &lt;iostream&gt; #include &lt;functional&gt; #include &lt;memory&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;unordered_map&gt; #include &lt;cassert&gt; using namespace std; class IProduct &#123; public: virtual ~IProduct() &#123;&#125; virtual IProduct *Clone() = 0; virtual void Use(const std::string &amp;str) = 0; &#125;; class MessageBox : public IProduct &#123; public: MessageBox(const std::string &amp;str) : m_name(str) &#123;&#125; IProduct *Clone() override &#123; return new MessageBox(m_name); &#125; void Use(const std::string &amp;str) &#123; std::cout &lt;&lt; &quot;Message box &quot; &lt;&lt; m_name &lt;&lt; &quot; &quot; &lt;&lt; str &lt;&lt; std::endl; &#125; private: std::string m_name; &#125;; class ProductMgr &#123; public: void Register(const std::string &amp;name, IProduct *pro) &#123; m_map.insert(&#123; name, pro &#125;); &#125; IProduct *Create(const std::string &amp;name) &#123; auto it = m_map.find(name); if (it != m_map.end()) return it-&gt;second-&gt;Clone(); else return nullptr; &#125; private: std::unordered_map&lt;std::string, IProduct *&gt; m_map; &#125;; int main() &#123; ProductMgr mgr; IProduct *p1 = new MessageBox(&quot;Hello&quot;); mgr.Register(&quot;MB&quot;, p1); p1-&gt;Use(&quot;World&quot;); auto p2 = mgr.Create(&quot;MB&quot;); p2-&gt;Use(&quot;World&quot;); cout &lt;&lt; p1 &lt;&lt; endl; cout &lt;&lt; p2 &lt;&lt; endl; auto pp = mgr.Create(&quot;Not&quot;); assert(pp == nullptr); delete p1; delete p2; return 0; &#125; ...","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:03--建造者模式","slug":"designPatter/设计模式-03-建造者模式","date":"2022-10-15T14:13:17.000Z","updated":"2022-10-19T05:25:41.479Z","comments":true,"path":"2022/10/15/designPatter/设计模式-03-建造者模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-03-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念2、UML 二、案例1、案例1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class House &#123;public: House() &#123;&#125; void setFloor(string iFloor) &#123; this-&gt;floor = iFloor; &#125; void setWall(string iWall) &#123; this-&gt;wall = iWall; &#125; void setRoof(string iRoof) &#123; this-&gt;roof = iRoof; &#125; void printfHouseInfo() &#123; printf(&quot;Floor:%s\\t\\n&quot;, this-&gt;floor.c_str()); printf(&quot;Wall:%s\\t\\n&quot;, this-&gt;wall.c_str()); printf(&quot;Roof:%s\\t\\n&quot;, this-&gt;roof.c_str()); &#125;private: string floor; string wall; string roof;&#125;;class AbstractBuilder &#123;public: AbstractBuilder() &#123; house = new House(); &#125; virtual ~AbstractBuilder() &#123; if (house != nullptr) &#123; delete house; house = nullptr; &#125; &#125; virtual void buildFloor() = 0; virtual void buildWall() = 0; virtual void buildRoof() = 0; virtual House *getHouse() = 0; House *house;&#125;;class ConcreteBuilderA : public AbstractBuilder &#123;public: ConcreteBuilderA() &#123; printf(&quot;ConcreteBuilderA\\n&quot;); &#125; ~ConcreteBuilderA() &#123; &#125; void buildFloor() &#123; this-&gt;house-&gt;setFloor(&quot;Floor_A&quot;); &#125; void buildWall() &#123; this-&gt;house-&gt;setWall(&quot;Wall_A&quot;); &#125; void buildRoof() &#123; this-&gt;house-&gt;setRoof(&quot;Roof_A&quot;); &#125; House *getHouse() &#123; return this-&gt;house; &#125;&#125;;class ConcreteBuilderB : public AbstractBuilder &#123;public: ConcreteBuilderB() &#123; printf(&quot;ConcreteBuilderB\\n&quot;); &#125; ~ConcreteBuilderB() &#123; &#125; void buildFloor() &#123; this-&gt;house-&gt;setFloor(&quot;Floor_B&quot;); &#125; void buildWall() &#123; this-&gt;house-&gt;setWall(&quot;Wall_B&quot;); &#125; void buildRoof() &#123; this-&gt;house-&gt;setRoof(&quot;Roof_B&quot;); &#125; House *getHouse() &#123; return this-&gt;house; &#125;&#125;;class Director &#123;public: Director() :builder(nullptr) &#123;&#125; ~Director() &#123; if (this-&gt;builder != nullptr) &#123; delete builder; builder = nullptr; &#125; &#125; void setBuilder(AbstractBuilder *iBuilder) &#123; this-&gt;builder = iBuilder; &#125; House *construct() &#123; builder-&gt;buildFloor(); builder-&gt;buildWall(); builder-&gt;buildRoof(); return builder-&gt;getHouse(); &#125;private: AbstractBuilder *builder;&#125;;int main()&#123; AbstractBuilder *builder; Director *director = new Director(); House *house; builder = new ConcreteBuilderA(); director-&gt;setBuilder(builder); house = director-&gt;construct(); house-&gt;printfHouseInfo(); delete builder; builder = new ConcreteBuilderB(); director-&gt;setBuilder(builder); house = director-&gt;construct(); house-&gt;printfHouseInfo(); delete director; return 0;&#125; 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;class IBuilder &#123;public: virtual ~IBuilder() &#123;&#125; virtual void makeTitle(const std::string &amp;title) = 0; virtual void makeString(const std::string &amp;str) = 0; virtual void makeItems(const std::vector&lt;std::string&gt; &amp;items) = 0; virtual void close() = 0;&#125;;class TextBuilder : public IBuilder &#123;public: void makeTitle(const std::string &amp;title) override &#123; m_str.append(&quot;============================\\n&quot;); m_str.append(&quot;[&quot; + title + &quot;]\\n&quot;); m_str.append(&quot;\\n&quot;); &#125; void makeString(const std::string &amp;str) override &#123; m_str.append(&quot; * &quot; + str + &quot;\\n&quot;); m_str.append(&quot;\\n&quot;); &#125; void makeItems(const std::vector&lt;std::string&gt; &amp;items) override &#123; for (auto item : items) &#123; m_str.append(&quot; . &quot; + item + &quot;\\n&quot;); &#125; m_str.append(&quot;\\n&quot;); &#125; void close() override &#123; m_str.append(&quot;============================\\n&quot;); &#125; std::string getResult() const &#123; return m_str; &#125;private: std::string m_str;&#125;;class Director &#123;public: Director(IBuilder *builder) : m_builder(builder) &#123;&#125; void construct() &#123; m_builder-&gt;makeTitle(&quot;Greeting&quot;); m_builder-&gt;makeString(u8&quot;从早上到下午&quot;); m_builder-&gt;makeItems(std::vector&lt;std::string&gt;&#123; u8&quot;早上好&quot;, u8&quot;下午好&quot; &#125;); m_builder-&gt;makeString(u8&quot;晚上&quot;); m_builder-&gt;makeItems(std::vector&lt;std::string&gt;&#123; u8&quot;晚上好&quot;, u8&quot;晚安&quot;, u8&quot;再见&quot; &#125;); m_builder-&gt;close(); &#125;private: IBuilder *m_builder;&#125;;int main()&#123; TextBuilder *builder = new TextBuilder; Director director(builder); director.construct(); std::string result = builder-&gt;getResult(); std::cout &lt;&lt; result &lt;&lt; std::endl; delete builder; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:02--抽象工厂模式","slug":"designPatter/设计模式-02-抽象工厂模式","date":"2022-10-15T14:11:56.000Z","updated":"2022-10-19T05:18:22.588Z","comments":true,"path":"2022/10/15/designPatter/设计模式-02-抽象工厂模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-02-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念抽象工厂的工作是将“抽象零件” 组装成 “抽象产品” 2、UML 二、案例1、案例1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;#include &lt;utility&gt;#include &lt;sstream&gt;#include &lt;thread&gt;using namespace std;class AbstractBall &#123;public: virtual ~AbstractBall()&#123;&#125; AbstractBall()&#123;&#125; void play()&#123;&#125;;&#125;;class Basketball : public AbstractBall &#123;public: Basketball() &#123; play(); &#125; void play()&#123; printf(&quot;Jungle play Basketball\\n\\n&quot;); &#125;&#125;;class Football : public AbstractBall &#123;public: Football()&#123; play(); &#125; void play()&#123; printf(&quot;Jungle play Football\\n\\n&quot;); &#125;&#125;;class AbstractShirt &#123;public: virtual ~AbstractShirt()&#123;&#125; AbstractShirt()&#123;&#125; void wearShirt()&#123;&#125;;&#125;;class BasketballShirt :public AbstractShirt &#123;public: BasketballShirt()&#123; wearShirt(); &#125; void wearShirt()&#123; printf(&quot;Jungle wear Basketball Shirt\\n\\n&quot;); &#125;&#125;;class FootballShirt :public AbstractShirt &#123;public: FootballShirt()&#123; wearShirt(); &#125; void wearShirt()&#123; printf(&quot;Jungle wear Football Shirt\\n\\n&quot;); &#125;&#125;;class AbstractFactory &#123;public: virtual ~AbstractFactory()&#123;&#125; virtual AbstractBall *getBall() = 0; virtual AbstractShirt *getShirt() = 0;&#125;;class BasketballFactory :public AbstractFactory &#123;public: BasketballFactory()&#123; printf(&quot;BasketballFactory\\n&quot;); &#125; AbstractBall *getBall()&#123; printf(&quot;Jungle get basketball\\n&quot;); return new Basketball(); &#125; AbstractShirt *getShirt()&#123; printf(&quot;Jungle get basketball shirt\\n&quot;); return new BasketballShirt(); &#125;&#125;;class FootballFactory :public AbstractFactory &#123;public: FootballFactory()&#123; printf(&quot;FootballFactory\\n&quot;); &#125; AbstractBall *getBall()&#123; printf(&quot;Jungle get football\\n&quot;); return new Football(); &#125; AbstractShirt *getShirt()&#123; printf(&quot;Jungle get football shirt\\n&quot;); return new FootballShirt(); &#125;&#125;;int main()&#123; AbstractFactory *fac = NULL; AbstractBall *ball = NULL; AbstractShirt *shirt = NULL; fac = new BasketballFactory(); ball = fac-&gt;getBall(); shirt = fac-&gt;getShirt(); delete fac; delete ball; delete shirt; fac = new FootballFactory(); ball = fac-&gt;getBall(); shirt = fac-&gt;getShirt(); delete fac; delete ball; delete shirt; return 0;&#125; 2、案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;cassert&gt;class IItem &#123;public: virtual ~IItem() &#123;&#125; IItem(const std::string &amp;caption) : m_caption(caption) &#123;&#125; virtual std::string makeHTML() = 0;protected: std::string m_caption;&#125;;class ILink : public IItem &#123;public: virtual ~ILink() &#123;&#125; ILink(const std::string &amp;caption, const std::string &amp;url) : IItem(caption), m_url(url) &#123;&#125;protected: std::string m_url;&#125;;class ITray : public IItem &#123;public: virtual ~ITray() &#123;&#125; ITray(const std::string &amp;caption) : IItem(caption) &#123;&#125; void addItem(IItem *item) &#123; m_itemList.push_back(item); &#125;protected: std::vector&lt;IItem *&gt; m_itemList;&#125;;class ListTray : public ITray &#123;public: using ITray::ITray; std::string makeHTML() override &#123; std::string str; str.append(&quot;&lt;li&gt;\\n&quot;); str.append(m_caption + &quot;\\n&quot;); str.append(&quot;&lt;ul&gt;\\n&quot;); for (auto item : m_itemList) &#123; str.append(item-&gt;makeHTML()); &#125; str.append(&quot;&lt;/ul&gt;\\n&quot;); str.append(&quot;&lt;/li&gt;\\n&quot;); return str; &#125;&#125;;class ListLink : public ILink &#123;public: using ILink::ILink; std::string makeHTML() override &#123; return &quot;&lt;li&gt;&lt;a href=\\&quot;&quot; + m_url + &quot;\\&quot;&gt; &quot; + m_caption + &quot;&lt;/a&gt; &lt;/li&gt;\\n&quot;; &#125;&#125;;class IPage &#123;public: virtual ~IPage() &#123;&#125; IPage(const std::string &amp;title, const std::string &amp;author) : m_title(title), m_author(author) &#123;&#125; void addItem(IItem *item) &#123; m_itemList.push_back(item); &#125; void output() &#123; std::cout &lt;&lt; makeHTML() &lt;&lt; std::endl; &#125; virtual std::string makeHTML() = 0;protected: std::string m_title; std::string m_author; std::vector&lt;IItem *&gt; m_itemList;&#125;;class ListPage : public IPage &#123;public: using IPage::IPage; std::string makeHTML() override &#123; std::string str; str.append(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot; + m_title + &quot;&lt;/head&gt;&lt;/title&gt;\\n&quot;); str.append(&quot;&lt;body&gt;\\n&quot;); str.append(&quot;&lt;h1&gt;&quot; + m_title + &quot;&lt;/h1&gt;\\n&quot;); str.append(&quot;&lt;ul&gt;\\n&quot;); for (auto item : m_itemList) &#123; str.append(item-&gt;makeHTML()); &#125; str.append(&quot;&lt;/ul&gt;\\n&quot;); str.append(&quot;&lt;address&gt;&quot; + m_author + &quot;&lt;/address&gt;\\n&quot;); str.append(&quot;&lt;/body&gt;\\n&quot;); str.append(&quot;&lt;/html&gt;&quot;); return str; &#125;&#125;;class IFactory &#123;public: virtual ~IFactory() &#123;&#125; virtual ILink *createLink(const std::string &amp;caption, const std::string &amp;url) = 0; virtual ITray *createTray(const std::string &amp;caption) = 0; virtual IPage *createPage(const std::string &amp;title, const std::string &amp;author) = 0;&#125;;class IFactoryHelper &#123;public: static void registerFactory(const std::string &amp;name, std::function&lt;IFactory *()&gt; createCallback) &#123; s_createrMap.insert(std::make_pair(name, createCallback)); &#125; static IFactory *getFactory(const std::string &amp;name) &#123; auto itor = s_createrMap.find(name); return itor-&gt;second(); &#125;private: static std::unordered_map&lt;std::string, std::function&lt;IFactory *()&gt;&gt; s_createrMap;&#125;;std::unordered_map&lt;std::string, std::function&lt;IFactory *()&gt;&gt; IFactoryHelper::s_createrMap;class ListFactory : public IFactory &#123;public: ILink *createLink(const std::string &amp;caption, const std::string &amp;url) override &#123; return new ListLink(caption, url); &#125; ITray *createTray(const std::string &amp;caption) override &#123; return new ListTray(caption); &#125; IPage *createPage(const std::string &amp;title, const std::string &amp;author) override &#123; return new ListPage(title, author); &#125;&#125;;static int ListFactoryInit = []() -&gt; int &#123; std::cout &lt;&lt; &quot;1&quot; &lt;&lt; std::endl; IFactoryHelper::registerFactory(&quot;ListFactory&quot;, []() &#123; return new ListFactory; &#125;); return 0;&#125;();int main()&#123; std::shared_ptr&lt;IFactory&gt; factory(IFactoryHelper::getFactory(&quot;ListFactory&quot;)); assert(factory != nullptr); std::shared_ptr&lt;ILink&gt; people(factory-&gt;createLink(u8&quot;人民日报&quot;, u8&quot;http://www.people.com.cn/&quot;)); std::shared_ptr&lt;ILink&gt; gmw(factory-&gt;createLink(u8&quot;光明网&quot;, u8&quot;http://www.gmw.cn/&quot;)); std::shared_ptr&lt;ILink&gt; us_yahoo(factory-&gt;createLink(u8&quot;us_yahoo&quot;, u8&quot;http://www.yahoo.com/&quot;)); std::shared_ptr&lt;ILink&gt; jp_yahoo(factory-&gt;createLink(u8&quot;jp_yahoo&quot;, u8&quot;http://www.yahoo.com.jp/&quot;)); std::shared_ptr&lt;ILink&gt; google(factory-&gt;createLink(u8&quot;google&quot;, u8&quot;http://www.google.com&quot;)); std::shared_ptr&lt;ITray&gt; trayNews(factory-&gt;createTray(&quot;news&quot;)); trayNews-&gt;addItem(people.get()); trayNews-&gt;addItem(gmw.get()); std::shared_ptr&lt;ITray&gt; trayYahoo(factory-&gt;createTray(&quot;yahoo!&quot;)); trayYahoo-&gt;addItem(us_yahoo.get()); trayYahoo-&gt;addItem(jp_yahoo.get()); std::shared_ptr&lt;ITray&gt; traySearch(factory-&gt;createTray(&quot;traySearch&quot;)); trayYahoo-&gt;addItem(trayYahoo.get()); trayYahoo-&gt;addItem(google.get()); std::shared_ptr&lt;IPage&gt; page(factory-&gt;createPage(&quot;LinkPage&quot;, &quot;tao&quot;)); page-&gt;addItem(trayNews.get()); page-&gt;addItem(traySearch.get()); page-&gt;output(); return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:01--工厂方法模式","slug":"designPatter/设计模式-01-工厂方法模式","date":"2022-10-15T14:11:40.000Z","updated":"2022-10-19T10:39:31.670Z","comments":true,"path":"2022/10/15/designPatter/设计模式-01-工厂方法模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-01-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念父类决定实例的生成方式，但并不决定所要生成具体的类，具体处理全部交给子类处理。 将生成实例的框架与具体的实例类解耦。 2、UML 二、案例1、案例112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class AbstractSportProduct &#123;public: AbstractSportProduct() &#123;&#125; virtual ~AbstractSportProduct()&#123;&#125; void printName()&#123;&#125;; void play()&#123;&#125;;&#125;;class Basketball : public AbstractSportProduct &#123;public: Basketball()&#123; printName(); play(); &#125; void printName()&#123; printf(&quot;Jungle get Basketball\\n&quot;); &#125; void play()&#123; printf(&quot;Jungle play Basketball\\n&quot;); &#125;&#125;;class AbstractFactory &#123;public: virtual AbstractSportProduct *getSportProduct() = 0; virtual ~AbstractFactory()&#123;&#125;&#125;;class BasketballFactory : public AbstractFactory &#123;public: BasketballFactory() &#123; printf(&quot;BasketballFactory\\n&quot;); &#125; AbstractSportProduct *getSportProduct() &#123; printf(&quot;basketball&quot;); return new Basketball(); &#125;&#125;;int main()&#123; AbstractFactory *fac = NULL; AbstractSportProduct *product = NULL; fac = new BasketballFactory(); product = fac-&gt;getSportProduct(); if (fac) &#123; delete fac; &#125; if (product) &#123; delete product; &#125; return 0;&#125; 2、案例212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;class IProduct &#123;public: virtual ~IProduct() &#123;&#125; virtual void use() = 0;&#125;;class IDCard : public IProduct &#123;public: IDCard(const std::string &amp;owner) : m_owner(owner) &#123;&#125; void use() override &#123; std::cout &lt;&lt; &quot;use IDCare with owner&quot; &lt;&lt; m_owner &lt;&lt; std::endl; &#125;private: std::string m_owner;&#125;;class IFactory &#123;public: virtual ~IFactory() &#123;&#125; virtual void registerProduct(IProduct *) = 0; virtual IProduct *createProduct(const std::string &amp;owner) = 0; virtual IProduct *create(const std::string &amp;owner) &#123; auto *pro = createProduct(owner); registerProduct(pro); return pro; &#125;&#125;;class IDCareFactory : public IFactory &#123;public: IProduct *createProduct(const std::string &amp;owner) &#123; return new IDCard(owner); &#125; void registerProduct(IProduct *pro) &#123; m_productList.push_back(pro); &#125;private: std::vector&lt;IProduct *&gt; m_productList;&#125;;int main()&#123; IFactory *fac = new IDCareFactory; IProduct *pro = fac-&gt;create(&quot;tao&quot;); IProduct *pro2 = fac-&gt;create(&quot;tao2&quot;); pro-&gt;use(); pro2-&gt;use(); delete pro; delete fac; delete pro2; return 0;&#125;","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++:06--function与bind及Lamda实现回调函数","slug":"C++/C-06-function与bind及Lamda实现回调函数","date":"2022-10-15T01:59:13.000Z","updated":"2022-10-16T01:41:46.766Z","comments":true,"path":"2022/10/15/C++/C-06-function与bind及Lamda实现回调函数/","link":"","permalink":"http://example.com/2022/10/15/C++/C-06-function%E4%B8%8Ebind%E5%8F%8ALamda%E5%AE%9E%E7%8E%B0%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","excerpt":"","text":"一、使用std::function作为函数入参1、基于传值的方式传递参数12#include &lt;functional&gt;void registerCallBack(std::function&lt;void()&gt;); 上面的代码实现了一个注册回调函数的机制，入参std::function&lt;void()&gt;是一个模板类对象， 它可以用一个函数签名为void()的可调用对象来进行初始化。 1234// 方法（A）registerCallBack([=]&#123; .... // 回调函数的实现部分&#125;) 这里使用了lambda表达式作为函数的入参，lambda表达式会生成一个匿名的闭包， 基于这个闭包构造了一个std::function&lt;void()&gt;的对象， 然后通过传值调用的方式把这个对象传递registerCallBack函数中使用。 2、基于引用的方式传递参数当然还可以如下实现这个注册函数，入参通过const引用的方式传递，这里的引用必须是const的， 这是因为调用registerCallBack函数的地方生成了一个临时的std::function()对象， 是一个右值，否则编译会报错。 123//方法(B)#include &lt;functional&gt;void registerCallBack(std::function&lt;void()&gt; const&amp;); 这传值和引用区别就在于，在registerCallBack函数内部怎么使用这个入参， 1) 如果只是简单的调用一下std::func()类，那么两种都没有问题，可能使用引用的效率更高； 2) 如果register函数内部需要保存这个std::func()，并用于以后使用，那么方法A直接保存没有问题， 方法B就必须做一次拷贝，否则方法B中，当临时的对象销毁时，有可能出现引用悬空的问题。 3、传值方式下的std::function对象保存如果要在registerCallBack函数内部保存传入的function对象，可以使用std::move，效率更高。 123456789class CallBackHolder &#123;public:void registerCallBack(std::function&lt;void()&gt; func) &#123; callback = std::move(func);&#125; private: std::function&lt;void()&gt; callback; &#125; 二、类的成员函数作为函数入参类的成员函数都会默认有个隐藏的this指针，所以不像普通的函数直接作为入参就可以了。 1、使用bind和function来实现1234567891011121314151617class classA &#123;typedef std::function&lt;void(int i)&gt; callback_t;... void registCb(callback_t func) &#123; cbHandle = std::move(func); &#125;private: callback_t cbHandle;&#125;;class classB &#123;public: classB(classA&amp; cA) &#123; cA.registCb(bind(&amp;classB::handle, this, placeholders::_1)); &#125;&#125;; 2、使用lambda表达式实现123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;class classA &#123;typedef std::function&lt;void(int i)&gt; callback_t;public: classA() &#123;&#125; ~classA() &#123;&#125; void handle(int i) &#123; std::cout &lt;&lt; &quot;classA::handle&quot; &lt;&lt; std::endl; cbHandle(i); &#125; void registCb(callback_t func) &#123;cbHandle = std::move(func);&#125;private: callback_t cbHandle;&#125;;class classB &#123;public: classB(classA&amp; cA) &#123; cA.registCb([this](int i)&#123;classB::handle(i);&#125;); &#125; ~classB() &#123;&#125; void handle(int i)&#123; std::cout &lt;&lt; &quot;classB, handle message&quot; &lt;&lt; i &lt;&lt; std::endl; &#125;&#125;;int main()&#123; classA testa; classB testb(testa); testa.handle(10);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:05--Lamda表达式使用场景","slug":"C++/C-05-Lamda表达式使用场景","date":"2022-10-14T06:54:13.000Z","updated":"2022-10-16T01:41:40.274Z","comments":true,"path":"2022/10/14/C++/C-05-Lamda表达式使用场景/","link":"","permalink":"http://example.com/2022/10/14/C++/C-05-Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"一、lamda表达式变量截取方式1、定义 1) 变量截取方式 2) Lambda表达式的参数列表 3) Mutable 标识 4) 异常标识 5) 返回值 6) “函数”体，也就是lambda表达式需要进行的实际操作 2、变量截取方式[] 不截取任何变量 [&amp;] 截取外部作用域中所有变量，并作为引用在函数体中使用 [&#x3D;] 截取外部作用域中所有变量，并拷贝一份在函数体中使用 [&#x3D;, &amp;foo]截取外部作用域中所有变量，并拷贝一份在函数体中使用，但是对foo使用引用 [bar] 截取bar变量并且拷贝一份在函数体重使用，同时不截取其他变量 [this] 截取当前类中的this指针。如果已经使用了&amp;或者&#x3D;就默认添加此选项 二、lamda表达式使用场景1、场景1简化写法。 //1.1vector数组求和 123456789101112int main()&#123; std::vector&lt;int&gt; some_list; int total = 0; for (int i = 0; i &lt; 5; ++i) some_list.push_back(i); for_each(begin(some_list), end(some_list), [&amp;total](int x) &#123; total += x;&#125;); return 0;&#125; //1.2vector数组排序 123456789101112int main(void)&#123; int data[6] = &#123; 3, 4, 12, 2, 1, 6 &#125;; vector&lt;int&gt; testdata; testdata.insert(testdata.begin(), data, data + 6); // 排序算法 sort(testdata.begin(), testdata.end(), [](int a, int b) &#123; return a &gt; b; &#125;); return 0;&#125; 2、场景2以前类中开启线程都需要通过静态成员函数，现在通过Lambda表达式， 在中括号[this]中可以直接访问到类中的成员变量。 123456789101112131415161718192021222324class A&#123;public: A(); ~A();//析构private: std::unique_ptr&lt;std::thread&gt; monitorThread; int a;&#125;;A::A()&#123; monitorThread = make_unique&lt;thread&gt;([this] &#123; while (true) &#123; cout &lt;&lt; &quot;i can access a &quot; &lt;&lt; a++ &lt;&lt; endl; Sleep(100); &#125; &#125;);&#125;A::~A()&#123;&#125; 3、场景3回调函数实现 123456789101112131415161718192021222324252627class MathCallBack &#123; int ops1,ops2; int result;public: void Add(int a,int b, function&lt;void (int)&gt; func) &#123; ops1 = abs(a); ops2 = abs(b); result = ops1+ops2; func(result); &#125;&#125;;int main()&#123; MathCallBack math; int c1 = 0; math.Add(1, 3, [&amp;c1](int result) -&gt; void &#123; printf(&quot;result = %d\\n&quot;, result); c1 = result; &#125;); printf(&quot;c1 = %d\\n&quot;, c1); return 0;&#125; lambda表达式可以以引用方式捕获上下文中的变量，达到回调的效果。 4、更多参考例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364vector&lt; int&gt; vec;/* 1. simple lambda */ auto it = std::find_if(vec.begin(), vec.end(), [](int i) &#123; return i &gt; 50; &#125;); class A &#123; public: bool operator(int i) const &#123; return i &gt; 50; &#125; &#125;;auto it = std::find_if(vec.begin(), vec.end(), A()); /* 2. lambda return syntax */ function&lt;int(int)&gt; square = [](int i) -&gt; int &#123;return i * i;&#125; /* 3. lambda expr: capture of local variable */ &#123; int min_val = 10; int max_val = 1000; auto it = find_if(vec.begin(), vec.end(), [=](int i) &#123;return i &gt; min_val &amp;&amp; i &lt; max_val;&#125;); auto it = find_if(vec.begin(), vec.end(), [&amp;](int i) &#123;return i &gt; min_val &amp;&amp; i &lt; max_val;&#125;); auto it = find_if(vec.begin(), vec.end(), [=, &amp;max_value](int i) &#123;return i &gt; min_val &amp;&amp; i &lt; max_val;&#125;); &#125; /* 4. lambda expr: capture of class member */ class A &#123; public: void DoSomething(); private: std::vector&lt;int&gt; m_vec; int m_min_val; int m_max_va; &#125;; /* 4.1 capture member by this */ void A::DoSomething() &#123; auto it = find_if(m_vec.begin(), m_vec.end(), [this](int i)&#123; return i &gt; m_min_val &amp;&amp; i &lt; m_max_val;&#125;); &#125; /* 4.2 capture member by default pass-by-value */ void A::DoSomething() &#123; auto it = find_if(m_vec.begin(), m_vec.end(), [=](int i)&#123; return i &gt; m_min_val &amp;&amp; i &lt; m_max_val; &#125;); &#125; /* 4.3 capture member by default pass-by-reference */ void A::DoSomething() &#123; auto it = find_if(m_vec.begin(), m_vec.end(), [&amp;](int i)&#123; return i &gt; m_min_val &amp;&amp; i &lt; m_max_val;&#125;); &#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:04--std::function和std::bind的用法","slug":"C++/C-04-std-function和std-bind的用法","date":"2022-10-14T06:26:43.000Z","updated":"2022-10-16T01:41:35.186Z","comments":true,"path":"2022/10/14/C++/C-04-std-function和std-bind的用法/","link":"","permalink":"http://example.com/2022/10/14/C++/C-04-std-function%E5%92%8Cstd-bind%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"一、std::function的用法1、保存自由函数123456789void printA(int a)&#123; cout &lt;&lt; a &lt;&lt; endl;&#125;std::function&lt;void(int a)&gt; func;func = printA;func(2); 2、保存lamda表达式12std::function&lt;void()&gt; func_1 = []()&#123;cout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl;&#125;;func_1(); 3、保存函数对象12345678910class CStudent&#123;public: void operator() (string strName, int nAge) &#123; cout &lt;&lt; strName &lt;&lt; &quot; : &quot; &lt;&lt; nAge &lt;&lt; endl; &#125;&#125;;CStudent stu;function&lt;void (string, int)&gt; f = stu;f(&quot;Mike&quot;, 12); 4、保存成员函数1234567891011121314struct Foo &#123; Foo(int num) : num_(num) &#123;&#125; void print_add(int i) const &#123; cout &lt;&lt; num_+i &lt;&lt; &#x27;\\n&#x27;; &#125; int num_;&#125;;int main()&#123; std::function&lt;void(const Foo&amp;, int)&gt; f_add_display = &amp;Foo::print_add; Foo foo(2); f_add_display(foo, 1); return 0;&#125; 在实际使用中都用 auto 关键字来代替std::function… 这一长串了 一、std::bind的用法1、用法案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859using namespace std;class A &#123;public: void fun_3(int k, int m) &#123; cout&lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; endl; &#125;&#125;;void fun(int x, int y, int z)&#123; cout&lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; z &lt;&lt; endl;&#125;void fun_2(int &amp;a, int &amp;b)&#123; a++; b++; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;&#125;int main(int argc, const char * argv[])&#123; /* 表示绑定函数fun的第一，二，三个参数值为： 1 2 3 */ auto f1 = std::bind(fun,1,2,3); f1(); //print:1 2 3 /* 前两个形参为占位符，调用时确定，第三个为3 */ auto f2 = std::bind(fun, placeholders::_1, placeholders::_2, 3); f2(1, 2); //print:1 2 3 /* 前两个形参为占位符，调用时确定，第三个为3 */ auto f3 = std::bind(fun, placeholders::_2, placeholders::_1, 3); /* 注意： f2和f3的区别 */ f3(1, 2); //print:2 1 3 int n = 2; int m = 3; auto f4 = std::bind(fun_2, n, placeholders::_1); f4(m); //print: 3 4 /* 打印4，说明bind通过std::placeholders传递的参数是通过引用传递的 */ cout &lt;&lt; m &lt;&lt; endl; /* 打印2，说明：bind对于预先绑定的函数参数是通过值传递的 */ cout &lt;&lt; n &lt;&lt; endl; A a; auto f5 = std::bind(&amp;A::fun_3, a, placeholders::_1, placeholders::_2); f5(10, 20); //print:10 20 std::function&lt;void(int,int)&gt; fc = bind(&amp;A::fun_3, a, placeholders::_1, placeholders::_2); fc(10,20); //print:10 20 return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:03--多级混合继承、虚基类","slug":"C++/C-03-多级混合继承、虚基类","date":"2022-10-13T10:26:35.000Z","updated":"2022-10-16T01:41:28.862Z","comments":true,"path":"2022/10/13/C++/C-03-多级混合继承、虚基类/","link":"","permalink":"http://example.com/2022/10/13/C++/C-03-%E5%A4%9A%E7%BA%A7%E6%B7%B7%E5%90%88%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%9F%BA%E7%B1%BB/","excerpt":"","text":"一、多级混合继承1、例子1234567891011121314151617181920212223242526272829303132//菱形继承class A &#123;public: int data;&#125;;class B : public A &#123;public: int data;&#125;;class C : public A &#123;public: int data;&#125;;class D : public B, public C &#123;public: int data;&#125;;int main()&#123; D c; D.data=1; D.B::data=2;//访问B中的 D.C.::data=3;//访问C中的 D.B::A::data=4;//访问B继承的A D.C::A::data=5;//访问C继承的A D.A::data=4;//错误，产生二义性，不知道是B、C中哪一个&#125; 2、内存大小 3、内存图解 一、虚基类1、概念1) 也称虚继承、菱形继承。用于多级混合继承时，保留一个虚基类。 2) 构造顺序 先构造虚基类，如果有多个虚基类，按声明（从左至右）依次构造; 再构造基类，如果有多个基类，按声明（从左至右）依次构造; 如果有子对象，再构造子对像，如果有多个子对象，按声明的顺序（从上至下）依次构造; 最后构造自己。 2、例子1234567891011121314151617181920212223242526272829303132class A &#123;public: A(int data)&#123;&#125;//1 int data;&#125;;class B : virtual public A &#123;public: B():A(1)&#123;&#125;//2 int data;&#125;;class C : virtual public A &#123;public: C() : A(2)&#123;&#125;//3 int data;&#125;;class D : public B, public C &#123;public: D() : A(3)&#123;&#125;//4 int data;&#125;;int main() &#123; D d; d.data=1; d.B::data=2; d.C::data=3; d.B::A.data=4; d.C::A::data=5;&#125; 1) 构造顺序为：1-2-3-4 2) 构造顺序解释：构造类D对象d的时候，发现继承于B，于是去构造B， 构造B的时候，发现继承于虚基类A，于是构造虚基类A，接着构造B。 再接着构造C，发现C继承于虚基类A，但发现虚基类A已经被B构造过了， 所以不再构造A，直接构造C。最后构造D。 3) 如果虚基类构造函数为带参构造，则其子类，以及子类拓展出来的子类， 都要在成员初始化列表对其进行构造函数的初始化。 4) d的data赋值为1，继承于B、C，分别赋值为2,3，顺序为从左至右。 A的值本来为4，后来执行到最后一行的时候被赋值为5 3、内存大小 4、内存图解","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:02--成员变量初始化方式","slug":"C++/C-02-成员变量初始化方式","date":"2022-10-13T08:58:08.000Z","updated":"2022-10-16T01:41:22.430Z","comments":true,"path":"2022/10/13/C++/C-02-成员变量初始化方式/","link":"","permalink":"http://example.com/2022/10/13/C++/C-02-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/","excerpt":"","text":"一、成员变量3种初始化方式1) 在构造函数体内赋值初始化 2) 在自定义的公有函数体中赋值初始化（一般用于成员变量的初始化） 3) 在构造函数的成员初始化列表初始化 二、构造函数体内初始化1、说明在构造函数体内的初始化方式，本质是是为成员变量赋值，而不是真正意义上的初始化。 2、案例1234567891011class Cperson &#123;public: Cperson(int age, float height) &#123; m_age = age; m_height = height; &#125;private: int m_age; float m_height;&#125; 三、自定义的公有函数体中赋值初始化1、说明与构造函数体内初始化方式一样，此种方式本质上也是赋值，而不是初始化。 2、案例1234567891011class Cperson &#123;public: void setPerson(int age, float height) &#123; m_age = age; m_height = height; &#125;private: int m_age; float m_height;&#125; 四、成员初始化列表初始化1、说明1) 写在构造函数的后面，随着构造函数的执行而执行。 2) 初始化列表初始化优先于构造函数内的代码执行顺序。 3) 一般只对无动态内存的成员、const成员、引用初始化, 其中const成员、引用成员必须在初始化列表初始化。 4) 成员初始化列表初始化效率更高。 5) 有动态内存的成员必须在构造函数内部进行初始化。 2、案例1 (const成员、引用成员必须在初始化列表初始化)123456789101112131415class Person &#123;public: Person(int i);private: const int id; int&amp; m_id;&#125;;Person::Person(int i)&#123; id = i; //错误，const成员变量必须在成员初始化列表初始化 m_id = id; //错误，引用也必须在成员初始化列表初始化&#125; 3、案例2 (成员初始化列表初始化效率更高)1234567891011class Word&#123;public: Word()&#123; _name=0; //先创建一个临时string对象，赋值为0，然后拷贝给_name _cnt=0; //构造函数结束之后，临时对象析构释放 &#125;private: string _name; int _cnt;&#125;; 但是如果使用下面的成员初始化列表初始化，那么就省去了创建临时对象再拷贝的过程 12345678 class Word&#123; public: Word() :_name(0),_cnt(0)&#123;&#125; //直接初始化_name，不创建临时对象 private: string _name; int _cnt;&#125;; 五、总结1) 成员初始化列表初始化成员才是真正意义上的初始化，其他两种方式都是为赋值。 2) 初始化是直接初始化。而赋值是先初始化一个临时变量，再赋值。前者效率高。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:01--this指针","slug":"C++/C-01-this指针","date":"2022-10-13T08:09:26.000Z","updated":"2022-10-16T01:41:16.814Z","comments":true,"path":"2022/10/13/C++/C-01-this指针/","link":"","permalink":"http://example.com/2022/10/13/C++/C-01-this%E6%8C%87%E9%92%88/","excerpt":"","text":"一、this指针应用1、剖析1) 对于类成员函数而言，并不是一个对象对应一个单独的成员函数体，而是此类的所有对象共用这个成员函数体。 当程序被编译之后，此成员函数地址已经确定。 1) 调用类的成员函数时，会将当前对象的this指针传递给成员函数，然后在函数体内对类的数据成员访问时， 就会被转换为“this-&gt;数据成员”的形式。 1) 如果成员函数内部没有访问对象的任何数据成员，那么传进来的this指针实际没有任何用处， 这样的函数与全局函数并没有太大区别。 &amp;nbsp; 2、案例11234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class MyClass &#123;public: int data; MyClass(int data) &#123; this-&gt;data = data; &#125; void print() &#123; //cout&lt;&lt; data &lt;&lt; endl; cout &lt;&lt; &quot;hello!&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; MyClass *pMyClass; pMyClass = new MyClass(1); pMyClass-&gt;print(); pMyClass[0].print(); pMyClass[1].print(); pMyClass[10000000].print(); return 0;&#125; 程序输出如下： 结果分析： 1) 此处我们创建了一个对象，但是访问后面越界之后仍然可以访问成功。 2) 如果一个成员函数没有操作任何类的数据成员，因此这个成员函数与全局函数类型，调用之后都会打印“hello!”。 &amp;nbsp; 3、案例21234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class MyClass &#123;public: int data; MyClass(int data) &#123; this-&gt;data = data; &#125; void print() &#123; cout&lt;&lt; data &lt;&lt; endl; cout &lt;&lt; &quot;hello!&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; MyClass *pMyClass; pMyClass = new MyClass(1); pMyClass-&gt;print(); pMyClass[0].print(); pMyClass[1].print(); pMyClass[10000000].print(); return 0;&#125; 程序输出如下： 结果分析： 1) 此处我们的成员函数访问了类的数据成员，那么每次打印数据时都会通过this指针调用。 2) 但是此处我们只创建了一个对象，所以当调用pMyClass[1]和pMyClass[10000000]越界了，找不到对象，从而报错。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ubuntu搭建Qt4Android的开发环境","slug":"ubuntu/ubuntu搭建Qt4Android的开发环境","date":"2022-09-29T05:45:30.000Z","updated":"2022-10-16T03:33:57.869Z","comments":true,"path":"2022/09/29/ubuntu/ubuntu搭建Qt4Android的开发环境/","link":"","permalink":"http://example.com/2022/09/29/ubuntu/ubuntu%E6%90%AD%E5%BB%BAQt4Android%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"一、软件版本选择1234android-studio: android-studio-2020.3.1.26-linux.tar.gzandroid-sdk: android-sdk_r24.4.1-linux.tgzandroid-ndk: android-ndk-r19c-linux-x86_64.zipQt: 5.12.8 二、安装软件1、安装jdk123456sudo apt install -y openjdk-8-jdkvi /etc/profileexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64export PATH=$PATH:$&#123;JAVA_HOME&#125;/binsource /etc/profile 2、安装sdk解压并运行android-studio, 将sdk、tool等下载到一个空的文件夹android-sdk下 解压android-sdk_r24.4.1-linux.tgz并赋值其目录下的tools到android-sdk下 3、解压ndk解压 android-ndk-r19c-linux-x86_64.zip 4、设置交叉编译","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"ubuntu安装VNC-无需显示屏","slug":"ubuntu/ubuntu安装VNC-无需显示屏","date":"2022-09-28T06:35:13.000Z","updated":"2022-10-16T03:33:52.097Z","comments":true,"path":"2022/09/28/ubuntu/ubuntu安装VNC-无需显示屏/","link":"","permalink":"http://example.com/2022/09/28/ubuntu/ubuntu%E5%AE%89%E8%A3%85VNC-%E6%97%A0%E9%9C%80%E6%98%BE%E7%A4%BA%E5%B1%8F/","excerpt":"","text":"一、安装1、安装VNC1234sudo apt-get install x11vnc –y/* generate password */sudo x11vnc -storepasswd /etc/x11vnc.pass 2、启动VNC1sudo x11vnc -display :0 -auth /var/run/lightdm/root/:0 -forever -bg -o /var/log/x11vnc.log -rfbauth /etc/x11vnc.pass -rfbport 5901 一、配置无显示器访问1、生成配置文件1234sudo Xorg :1 –configure/* 此时会在root路径下生成xorg.conf.new文件 */cp /root/xorg.conf.new /usr/share/X11/xorg.conf.d/xorg.conf 2、安装虚拟显卡驱动1sudo apt install xserver-xorg-video-dummy 3、添加虚拟显卡配置1234567891011121314151617181920212223242526272829sudo vi /usr/share/X11/xorg.conf.d/xorg.conf/* 在文件最后添加以下内容 */Section &quot;Monitor&quot; Identifier &quot;Monitor1&quot; HorizSync 1.0 - 2000.0 VertRefresh 1.0 - 200.0 # Add 16:9 modes, others are automatically detected. Modeline &quot;1280x720&quot; 74.48 1280 1336 1472 1664 720 721 724 746 Modeline &quot;1920x1080&quot; 172.80 1920 2040 2248 2576 1080 1081 1084 1118EndSectionSection &quot;Device&quot; Identifier &quot;Card1&quot; Driver &quot;dummy&quot; VideoRam 256000EndSection Section &quot;Screen&quot; DefaultDepth 24 Identifier &quot;Screen1&quot; Device &quot;Card1&quot; Monitor &quot;Monitor1&quot; SubSection &quot;Display&quot; Depth 24 Modes &quot;1920x1080&quot; EndSubSectionEndSection 4、虚拟与真实显示器同时工作配置修改步骤3中的配置文件最上面的ServerLayout: 12345Section &quot;ServerLayout&quot; Identifier &quot;X.org Configured&quot; Screen 0 &quot;Screen0&quot; 0 0 Screen 1 &quot;Screen1&quot; 0 0EndSection","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"树莓派3B+xenomai+igh","slug":"servoCtrl/树莓派3B-xenomai-igh","date":"2022-09-28T05:42:02.000Z","updated":"2022-10-16T03:34:20.236Z","comments":true,"path":"2022/09/28/servoCtrl/树莓派3B-xenomai-igh/","link":"","permalink":"http://example.com/2022/09/28/servoCtrl/%E6%A0%91%E8%8E%93%E6%B4%BE3B-xenomai-igh/","excerpt":"","text":"一、源码包准备1、安装依赖软件1sudo apt install git bc bison flex libssl-dev make 2、源码版本12345git clone https://github.com/raspberrypi/linux.gitgit checkout rpi-4.1.ygit clone http://git.xenomai.org/xenomai-3.git/git checkout v3.0.2 二、实时内核移植1、打实时补丁12345cd xenomai-3scripts/prepare-kernel.sh --linux=../linux/ --arch=arm --ipipe=./kernel/cobalt/arch/arm/patches/ipipe-core-4.1.18-arm-4.patchcd ../linuxcat ../patch-xenomai-3-on-bcm-2709.patch | patch -p1 2、配置内核123456789101112131415161718make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfigmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig/* config linux kernel with the following options */CPU Power Management ---&gt;CPU Frequency scaling ---&gt; [ ] CPU Frequency scalingCPU idle ---&gt; [ ] CPU idle PM supportKernel Features ---&gt; [ ] Contiguous Memory Allocator [ ] Allow for memory compactionKernel Hacking ---&gt; [ ] KGDB: kernel debuggerBoot options ---&gt; Kernel command line type ---&gt; [X] Extend bootloader kernel arguments 3、编译内核及模块1234make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs -j20mkdir modulesmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- INSTALL_MOD_PATH=modules modules_install 4、安装到系统123456cp arch/arm/boot/zImage /media/$&#123;USER&#125;/bootcp arch/arm/boot/dts/bcm2710-rpi-3-b.dtb /media/$&#123;USER&#125;/bootrm -rf /media/$&#123;USER&#125;/boot/overlays/*cp arch/arm/boot/dts/overlays/*.dtb* /media/$&#123;USER&#125;/boot/overlays/sudo cp -r linux/dist/lib/modules/* /media/$&#123;USER&#125;/$&#123;ROOTFS&#125;/lib/modules 5、修改系统启动项12kernel=$&#123;zImage name&#125;device_tree=bcm2710-rpi-3-b.dtb 三、安装xenomai1、配置123cd xenomai-3./scripts/bootstrap --with-core=cobalt –enable-debug=partial./configure CFLAGS=&quot;-march=armv7-a -mtune=cortex-a8 -mfloat-abi=hard -mfpu=neon -ffast-math&quot; --host=arm-linux-gnueabihf --target=arm-linux-gnueabihf --enable-smp 2、编译12mkdir targetmake DESTDIR=$&#123;PWD&#125;/target install 3、安装到系统1sudo cp -a target/* /media/$&#123;USER&#125;/$&#123;ROOTFS&#125;/ 三、安装IGH1、源码包123git clone https://gitlab.com/etherlab.org/ethercat.gitcd ethercatgit checkout stable-1.5 2、配置123mkdir etherlab./bootstrap./configure --prefix=$&#123;PWD&#125;/etherlab --with-linux-dir=$&#123;PWD&#125;/../linux --enable-8139too=no --enable-generic=yes CC=arm-linux-gnueabihf-gcc --host=arm-linux-gnueabihf 3、编译12make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- all modules -j20make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- install -j20 4、可能出现的问题及解决123issue: /usr/bin/ld: error: ethercat use VFP register arguments, ../master/soe_errors.o does notsolve: touch ~/ethercat/master/soe_errors.c 5、安装到系统123456789101112131415161718mkdir -p $&#123;PWD&#125;/etherlab/modulescp devices/ec_generic.ko etherlab/modules/cp master/ec_master.ko etherlab/modules/sudo cp -r etherlab/ /opt sudo ln -fs /opt/etherlab/etc/init.d/ethercat /etc/init.d/sudo ln -fs /opt/etherlab/bin/ethercat /usr/local/bin/sudo mkdir /etc/sysconfigsudo ln -fs /opt/etherlab/etc/sysconfig/ethercat /etc/sysconfig/sudo susudo echo KERNEL==\\&quot;EtherCAT[0-9]*\\&quot;, MODE=\\&quot;0664\\&quot; &gt; /etc/udev/rules.d/99-EtherCAT.rulesexitsudo cp /opt/etherlab/modules/ec_master.ko /lib/modules/4.14.91-rt49-v7+sudo depmodvi ~/.bashrcPATH=$PATH:/opt/etherlab/binsource ~/.bashrc 6、配置网卡123vi /etc/sysconfig/ethercatMASTER0_DEVICE=”b8:27:eb:7d:26:a2” //填写实际的MACDEVICE_MODULES=”generic” 7、启动igh1sudo /etc/init.d/ethercat start 6、测试经过测试发现igh1.5.2可以在pi3上运行，但是效果很差，代码运行后不能识别对应的pdo，原因待查找","categories":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]},{"title":"x86工控机安装igh","slug":"servoCtrl/x86工控机安装igh","date":"2022-09-27T13:51:31.000Z","updated":"2022-10-16T03:34:08.809Z","comments":true,"path":"2022/09/27/servoCtrl/x86工控机安装igh/","link":"","permalink":"http://example.com/2022/09/27/servoCtrl/x86%E5%B7%A5%E6%8E%A7%E6%9C%BA%E5%AE%89%E8%A3%85igh/","excerpt":"","text":"一、网卡驱动类型1、通用型优点: generic通用型的网卡驱动对物理网卡没有太多要求，只需要Linux系统支持其驱动， 就能在IGH的配置中将其选作网卡驱动。 缺点: 实时性较差，尤其是进行dc同步控制时表现更为明显。 2、本地型优点: native本地型网卡驱动是官方专门适配的几款Intel网卡，实时性方面有良好的保证 缺点: 只支持几款网卡，并且还需专门的内核版本支持。 二、安装通用型网卡驱动1、下载源码包https://sourceforge.net/p/etherlabmaster/code/ci/stable-1.5/tree/ 2、配置1234cd path/to/ethercatMaster./bootstrapmkdir etherlab./configure --prefix=/home/lufahai/xenohegongda/etherlabmaster/etherlab --with-linux-dir=/home/lufahai/xenohegongda/linux-4.9.51 --enable-cycles --enable-hrtimer --enable-8139too=no --enable-generic=yes configure中的路径需要根据本地实际路径修改 3、编译及安装1234make -j16make modules -j16sudo make installsudo make modules_install 4、创建软连接12345678910111213mkdir -p ~/ethercat/etherlab/modulescp devices/ec_generic.ko etherlab/modules/cp master/ec_master.ko etherlab/modules/sudo cp -r etherlab/ /opt sudo ln -fs /opt/etherlab/etc/init.d/ethercat /etc/init.d/sudo ln -fs /opt/etherlab/bin/ethercat /usr/local/bin/sudo mkdir /etc/sysconfigsudo ln -fs /opt/etherlab/etc/sysconfig/ethercat /etc/sysconfig/sudo suecho KERNEL==\\&quot;EtherCAT[0-9]*\\&quot;, MODE=\\&quot;0664\\&quot; &gt; /etc/udev/rules.d/99-EtherCAT.rulesexitsudo cp /opt/etherlab/modules/ec_master.ko /lib/modules/4.9.51-xenomai3.1+sudo depmod 此步骤中的路径需要根据本地实际路径修改 5、配置网卡ifconfig 找出网卡的MAC地址 123sudo vi /etc/sysconfig/ethercatMASTER0_DEVICE=”b8:27:eb:7d:26:a2” //填写实际MACDEVICE_MODULES=”generic” 6、增加系统路径在~/.bashrc 末尾增加下面内容并source 12PATH=$PATH:/opt/etherlab/binsource ~/.bashrc 7、添加库文件供程序链接如果没有将xenomai的库添加到系统路径中，程序在链接的时候就会出现 error: while loading shared libraries... 解决： 123sudo vi /etc/ld.so.conf/usr/xenomai/lib //文件中增加这一行sudo ldconfig -v //使其生效 三、安装native型网卡驱动1、内核及igh源码版本的下载地址安装native型网卡驱动需要内核支持此网卡驱动， 最好的内核无疑是igh官方经过优化后的，下载地址如下 内核：https://source.denx.de/Xenomai/linux-dovetail branch选择 v5.10.y-dovetail igh源码： https://gitlab.com/etherlab.org/ethercat/-/tree/e1000e-5.10 branch选择 e1000e-5.10 xenomai选择3.2.1版本 2、Linux内核配置由于使用官方提供的内核，所以打补丁与另一篇搭建实时系统博客中的方法略有不同 12cd path/to/kernel../xenomai-v3.2.1/scripts/prepare-kernel.sh --arch=x86_64 Linux5.10的内核配置可以参考下面的附录，编译及安装过程与4.x内核移植 3、native型网卡配置12345cd path/to/ighsourceTree./scrip/bootstrapmkdir etherlab./configure --prefix=/home/huger/rtlinux/ethercat-e1000e-5.10/etherlab -enable-8139too=no -enable-e1000e=yes 4、编译及安装123make all modules -j16sudo make modules_install install -j16sudo depmod 5、创建软链接与通用型相同 6、配置网卡sudo vi /etc/sysconfig/ethercat MASTER0_DEVICE=”b8:27:eb:7d:26:a2” //填写实际MAC DEVICE_MODULES=”e1000e” 三、Linux5.10内核配置附录1234567891011121314151617181920212223242526272829303132333435363738394041424344Recommended options:* General setup --&gt; Local version - append to kernel release: -xenomai-3.0.5 --&gt; Timers subsystem --&gt; High Resolution Timer Support (Enable)* Xenomai/cobalt --&gt; Sizes and static limits --&gt; Number of registry slots (512 --&gt; 4096) --&gt; Size of system heap (Kb) (512 --&gt; 4096) --&gt; Size of private heap (Kb) (64 --&gt; 256) --&gt; Size of shared heap (Kb) (64 --&gt; 256) --&gt; Maximum number of POSIX timers per process (128 --&gt; 512) --&gt; Drivers --&gt; RTnet --&gt; RTnet, TCP/IP socket interface (Enable) --&gt; Drivers --&gt; New intel(R) PRO/1000 PCIe (Enable) --&gt; Realtek 8169 (Enable) --&gt; Loopback (Enable) --&gt; Add-Ons --&gt; Real-Time Capturing Support (Enable)* Power management and ACPI options --&gt; CPU Frequency scaling --&gt; CPU Frequency scaling (Disable) --&gt; ACPI (Advanced Configuration and Power Interface) Support --&gt; Processor (Disable) --&gt; CPU Idle --&gt; CPU idle PM support (Disable)* Pocessor type and features --&gt; Enable maximum number of SMP processors and NUMA nodes (Disable) // Ref : http://xenomai.org/pipermail/xenomai/2017-September/037718.html --&gt; Processor family --&gt; Core 2/newer Xeon (if &quot;cat /proc/cpuinfo | grep family&quot; returns 6, set as Generic otherwise) // Xenomai will issue a warning about CONFIG_MIGRATION, disable those in this order --&gt; Transparent Hugepage Support (Disable) --&gt; Allow for memory compaction (Disable) --&gt; Contiguous Memory Allocation (Disable) --&gt; Allow for memory compaction --&gt; Page Migration (Disable)* Device Drivers --&gt; Staging drivers --&gt; Unisys SPAR driver support --&gt; Unisys visorbus driver (Disable) ​","categories":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]},{"title":"x86工控机搭建ubuntu18+xenomai实时系统","slug":"servoCtrl/x86工控机搭建ubuntu18-xenomai实时系统","date":"2022-09-27T08:37:14.000Z","updated":"2022-10-16T03:34:15.764Z","comments":true,"path":"2022/09/27/servoCtrl/x86工控机搭建ubuntu18-xenomai实时系统/","link":"","permalink":"http://example.com/2022/09/27/servoCtrl/x86%E5%B7%A5%E6%8E%A7%E6%9C%BA%E6%90%AD%E5%BB%BAubuntu18-xenomai%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"一、安装系统及软件依赖1、系统选择选择安装 ubuntu18.04.6 LTS 2、软件依赖1sudo apt install libc6-dev libncurses5-dev libssl-dev build-essential bison flex lib32stdc++6 lib32z1 autoconf automake libtool pkg-config libelf-dev 3、软件版本及下载kernel: 4.9.38: https://mirrors.edge.kernel.org/pub/linux/kernel/ xenomai3.1及补丁: https://xenomai.org/downloads/ 二、配置内核1、打补丁123cd linux-4.9.38../xenomai-3.1/scripts/prepare-kernel.sh --arch=x86_64 --ipipe=ipipe-core-4.9.38-x86-3.patch 2、安装内核管理包1sudo apt install kernel-package 在弹出的界面中选择 “keep the local version…….” 3、配置kernel1make menuconfig 安装附录中的选项配置内核，去除xenomai相关的警告 4、去除编译错误1vi .config 找到SYSTEM_TRUSTED_KEYS将其赋值为空，使用#注释掉CONFIG_DEBUG_INFO_BTF 12SYSTEM_TRUSTED_KEYS=&quot;&quot;#CONFIG_DEBUG_INFO_BTF 5、编译内核1CONCURRENCY_LEVEL=$(nproc) make-kpkg --rootcmd fakeroot --initrd kernel_image kernel_headers 6、参考文档https://blog.csdn.net/qq_28882933/article/details/123626659?spm=1001.2014.3001.5502 三、安装新内核并修改grub1、安装内核编译完成后会在上一层目录生成对应的deb安装包 12cd ..sudo dpkg -i *.deb 2、增加非root用户123sudo addgroup xenomai --gid 1234sudo addgroup root xenomaisudo usermod -a -G xenomai $USER 3、查看当前系统下的所有可用内核1cat /boot/grub/grub.cfg | grep menuentry 记住刚才安装的实时内核下标号 4、修改grub启动项1sudo vi /etc/default/grub 倒数第二个选项，要在后面加命令行“xenomai.allowed_group=1234”即上步骤新增的组，具体修改如下: 5、更新grub12sudo update-grubsudo reboot 四、安装xenomai1、编译源文件1234567cd xenomai-3.1./configure --with-pic --with-core=cobalt --enable-smp --disable-tls --enable-dlopen-libs --disable-clock-monotonic-rawmake -j`nproc`sudo make install 2、配置系统路径12345678910111213echo &#x27;### Xenomaiexport XENOMAI_ROOT_DIR=/usr/xenomaiexport XENOMAI_PATH=/usr/xenomaiexport PATH=$PATH:$XENOMAI_PATH/bin:$XENOMAI_PATH/sbinexport PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$XENOMAI_PATH/lib/pkgconfigexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$XENOMAI_PATH/libexport OROCOS_TARGET=xenomai&#x27; &gt;&gt; ~/.xenomai_rcecho &#x27;source ~/.xenomai_rc&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc 3、实时性测试123sudo chmod -R 777 /dev/rtdm/memdev-privatesudo chmod -R 777 /dev/rtdm/memdev-sharedxeno latency 4、修改 lat best为负的方法123sudo suecho 0 &gt; /proc/xenomai/latencyxeno latency 运行一小段时间待其稳定后查看此时lat best 的数值, 将此数值乘1000 后重新echo 1echo value*1000 &gt; /proc/xenomai/latency 五、添加库文件供程序链接如果没有将xenomai的库添加到系统路径中，程序在链接的时候就会出现 error: while loading shared libraries... 解决： 123sudo vi /etc/ld.so.conf/usr/xenomai/lib //文件中增加这一行sudo ldconfig -v //使其生效 六、内核配置附录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 #进入menuconfig界面，会看影响xenomai实时性的警告信息：#*** WARNING! Page migration (CONFIG_MIGRATION) may increase ***#*** latency. ***#*** WARNING! At least one of APM, CPU frequency scaling, ACPI ‘processor‘ ***#*** or CPU idle features is enabled. Any of these options may ***#*** cause troubles with Xenomai. You should disable them. ***#具体配置如下所示： * General setup --&gt; Local version - append to kernel release: -xenomai-3.1 --&gt; Timers subsystem --&gt; High Resolution Timer Support (Enable) * Xenomai/cobalt --&gt; Sizes and static limits --&gt; Number of registry slots (512 --&gt; 4096) --&gt; Size of system heap (Kb) (512 --&gt; 4096) --&gt; Size of private heap (Kb) (64 --&gt; 256) --&gt; Size of shared heap (Kb) (64 --&gt; 256) --&gt; Maximum number of POSIX timers per process (128 --&gt; 512) --&gt; Drivers --&gt; RTnet --&gt; RTnet, TCP/IP socket interface (Enable) --&gt; Drivers --&gt; New intel(R) PRO/1000 PCIe (Enable) --&gt; Realtek 8169 (Enable) --&gt; Loopback (Enable) --&gt; Add-Ons --&gt; Real-Time Capturing Support (Enable) * Power management and ACPI options --&gt; CPU Frequency scaling --&gt; CPU Frequency scaling (Disable) --&gt; ACPI (Advanced Configuration and Power Interface) Support --&gt; Processor (Disable) --&gt; CPU Idle --&gt; CPU idle PM support (Disable) * Pocessor type and features --&gt; Enable maximum number of SMP processors and NUMA nodes (Disable) // Ref : http://xenomai.org/pipermail/xenomai/2017-September/037718.html --&gt; Processor family --&gt; Core 2/newer Xeon (if &quot;cat /proc/cpuinfo | grep family&quot; returns 6, set as Generic otherwise) // Xenomai will issue a warning about CONFIG_MIGRATION, disable those in this orde --&gt; Transparent Hugepage Support (Disable) --&gt; Allow for memory compaction (Disable) --&gt; Contiguous Memory Allocation (Disable) --&gt; Allow for memory compaction --&gt; Page Migration (Disable) * Device Drivers --&gt; Staging drivers --&gt; Unisys SPAR driver support --&gt; Unisys visorbus driver (Disable)","categories":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]},{"title":"ubuntu安装hexo踩坑","slug":"ubuntu/ubuntu安装hexo踩坑","date":"2022-09-27T07:04:27.000Z","updated":"2022-10-16T03:33:43.945Z","comments":true,"path":"2022/09/27/ubuntu/ubuntu安装hexo踩坑/","link":"","permalink":"http://example.com/2022/09/27/ubuntu/ubuntu%E5%AE%89%E8%A3%85hexo%E8%B8%A9%E5%9D%91/","excerpt":"","text":"软件问题导致无法安装HEXO现象及原因如果默认使用 1sudo apt install nodejs npm 系统会默认安装低版本的软件，然而在执行 1npm install -g hexo 会提示版本太低 解决123sudo apt install curlcurl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -sudo apt-get install -y nodejs 这就安装了高版本的软件，可以直接安装hexo. 部署到github上后网页乱码解决打开网址 http://ipaddress.com/ 右上角进行查找 assets-cdn.github.com，得到相应的IP 然后在 /etc/hosts中增加 185.199.109.153 assets-cdn.github.com 以实ip为准，如果一个ip无效，那么就多试其他ip","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]}],"categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"},{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"},{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]}