{"meta":{"title":"StephenLu`s Blog","subtitle":"Embedded Software Engineering","description":"","author":"Stephen Lu","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-09-27T07:44:47.000Z","updated":"2022-09-27T07:45:37.738Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-27T07:44:42.000Z","updated":"2022-09-27T07:45:26.354Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式:23--访问者模式","slug":"designPatter/设计模式-23-访问者模式","date":"2022-10-15T14:21:29.000Z","updated":"2022-10-16T09:08:36.289Z","comments":true,"path":"2022/10/15/designPatter/设计模式-23-访问者模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-23-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念1) 双重分发 accept 调用方法是 element.accept(visitor) visit调用方法是visitor.visit(element) 2) 将处理算法从数据结构中分离出来 易于增加Visitor 难以增加Element Element必须向Visitor公开足够的信息 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:22--模板方法模式","slug":"designPatter/设计模式-22-模板方法模式","date":"2022-10-15T14:21:07.000Z","updated":"2022-10-16T09:06:51.193Z","comments":true,"path":"2022/10/15/designPatter/设计模式-22-模板方法模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-22-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念在父类中定义处理流程的框架，在子类中实现具体处理 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:21--策略模式","slug":"designPatter/设计模式-21-策略模式","date":"2022-10-15T14:20:44.000Z","updated":"2022-10-16T09:06:37.137Z","comments":true,"path":"2022/10/15/designPatter/设计模式-21-策略模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-21-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念将算法与其它部分分离开，只定义与算法相关的接口，然后在程序中以委托的方式来使用 使用委托这种弱关联关系可以很方便地整体替换算法。 程序运行过程中也可以替换算法 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:20--状态模式","slug":"designPatter/设计模式-20-状态模式","date":"2022-10-15T14:20:27.000Z","updated":"2022-10-16T09:06:19.189Z","comments":true,"path":"2022/10/15/designPatter/设计模式-20-状态模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-20-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念用类表示状态，通过切换类改变对象状态 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:19--观察者模式","slug":"designPatter/设计模式-19-观察者模式","date":"2022-10-15T14:20:06.000Z","updated":"2022-10-16T09:06:03.885Z","comments":true,"path":"2022/10/15/designPatter/设计模式-19-观察者模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-19-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念观察对象的状态发生变化时，通知给观察者。 观察者模式适用于根据对象状态进行相应处理的场景。 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:18--备忘录模式","slug":"designPatter/设计模式-18-备忘录模式","date":"2022-10-15T14:19:47.000Z","updated":"2022-10-16T09:05:43.905Z","comments":true,"path":"2022/10/15/designPatter/设计模式-18-备忘录模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-18-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念记录对象状态 Undo撤销 Redo恢复 History 历史 Snapshot快照 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:17--中介模式","slug":"designPatter/设计模式-17-中介模式","date":"2022-10-15T14:19:32.000Z","updated":"2022-10-16T07:30:25.478Z","comments":true,"path":"2022/10/15/designPatter/设计模式-17-中介模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-17-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:16--迭代模式","slug":"designPatter/设计模式-16-迭代模式","date":"2022-10-15T14:19:03.000Z","updated":"2022-10-16T09:05:02.565Z","comments":true,"path":"2022/10/15/designPatter/设计模式-16-迭代模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-16-%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念访问一个聚合对象的内容而无需暴露其内部实现 支持对聚合对象的多种遍历 为遍历不同的聚合结构提供统一的接口 健壮性考虑：遍历的同时更改迭代器所在聚合结构，会导致问题 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:15--解释器模式","slug":"designPatter/设计模式-15-解释器模式","date":"2022-10-15T14:18:43.000Z","updated":"2022-10-16T09:04:28.261Z","comments":true,"path":"2022/10/15/designPatter/设计模式-15-解释器模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-15-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:14--命令模式","slug":"designPatter/设计模式-14-命令模式","date":"2022-10-15T14:18:23.000Z","updated":"2022-10-16T09:04:01.872Z","comments":true,"path":"2022/10/15/designPatter/设计模式-14-命令模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-14-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念用一个类表示“请进行这项工作”的命令 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:13--责任链模式","slug":"designPatter/设计模式-13-责任链模式","date":"2022-10-15T14:18:06.000Z","updated":"2022-10-16T09:03:48.676Z","comments":true,"path":"2022/10/15/designPatter/设计模式-13-责任链模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-13-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念甩锅 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:12--代理模式","slug":"designPatter/设计模式-12-代理模式","date":"2022-10-15T14:17:42.000Z","updated":"2022-10-16T09:03:30.508Z","comments":true,"path":"2022/10/15/designPatter/设计模式-12-代理模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-12-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念部分工作交给代理人 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:11--享元模式","slug":"designPatter/设计模式-11-享元模式","date":"2022-10-15T14:17:27.000Z","updated":"2022-10-16T09:03:15.212Z","comments":true,"path":"2022/10/15/designPatter/设计模式-11-享元模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-11-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念尽量共享实例避免new出实例。 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:10--外观模式","slug":"designPatter/设计模式-10-外观模式","date":"2022-10-15T14:16:48.000Z","updated":"2022-10-16T09:02:58.948Z","comments":true,"path":"2022/10/15/designPatter/设计模式-10-外观模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-10-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念为互相关联在一起的错综复杂的类整理出高层接口，Facade角色对外只有一个简单的接口。 Facade角色还会考虑到系统内部各个类之间的责任和依赖关系，按照正确的顺序调用各个类。 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:09--装饰模式","slug":"designPatter/设计模式-09-装饰模式","date":"2022-10-15T14:16:29.000Z","updated":"2022-10-16T09:02:38.276Z","comments":true,"path":"2022/10/15/designPatter/设计模式-09-装饰模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-09-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念不断地为对象添加装饰 特性： 接口透明 不改变装饰物的前提下，增加功能 动态增加功能 只需要一些装饰物，即可添加很多功能 缺点： 增加许多功能类似的小类 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:08--组合模式","slug":"designPatter/设计模式-08-组合模式","date":"2022-10-15T14:16:07.000Z","updated":"2022-10-16T09:02:07.760Z","comments":true,"path":"2022/10/15/designPatter/设计模式-08-组合模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-08-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念使容器与内容具有一致性(也可以称作多个与单个的一致性)，创造出递归结构的模式。 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:07--桥接模式","slug":"designPatter/设计模式-07-桥接模式","date":"2022-10-15T14:15:47.000Z","updated":"2022-10-16T09:01:46.864Z","comments":true,"path":"2022/10/15/designPatter/设计模式-07-桥接模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-07-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念用于分离 类的功能层次结构 和 类的实现层次结构 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:06--适配器模式","slug":"designPatter/设计模式-06-适配器模式","date":"2022-10-15T14:15:26.000Z","updated":"2022-10-16T09:01:29.744Z","comments":true,"path":"2022/10/15/designPatter/设计模式-06-适配器模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-06-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念Painter为要适配的类/接口 Banner为适配者 PainterBanner是适配器。 适配器继承了Painter接口，同时继承了Banner，利用Banner已有的功能 实现Painter的接口 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:05--单例模式","slug":"designPatter/设计模式-05-单例模式","date":"2022-10-15T14:14:36.000Z","updated":"2022-10-16T09:00:45.488Z","comments":true,"path":"2022/10/15/designPatter/设计模式-05-单例模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-05-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念整个软件生命周期，只存在一个对象实例 关键是构造函数私有化，不允许多次构造 实现中使用了模板+参数包的形式。 具体使用时，子类T需要继承于SingleTon&lt;T&gt;类，并设置SingleTon&lt;T&gt;为友元 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:04--原型模式","slug":"designPatter/设计模式-04-原型模式","date":"2022-10-15T14:14:15.000Z","updated":"2022-10-16T09:00:04.256Z","comments":true,"path":"2022/10/15/designPatter/设计模式-04-原型模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-04-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念通过复制，生成实例。 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:03--建造者模式","slug":"designPatter/设计模式-03-建造者模式","date":"2022-10-15T14:13:17.000Z","updated":"2022-10-16T07:29:05.593Z","comments":true,"path":"2022/10/15/designPatter/设计模式-03-建造者模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-03-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:02--抽象工厂模式","slug":"designPatter/设计模式-02-抽象工厂模式","date":"2022-10-15T14:11:56.000Z","updated":"2022-10-16T08:57:53.788Z","comments":true,"path":"2022/10/15/designPatter/设计模式-02-抽象工厂模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-02-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念抽象工厂的工作是将“抽象零件” 组装成 “抽象产品” 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式:01--工厂方法模式","slug":"designPatter/设计模式-01-工厂方法模式","date":"2022-10-15T14:11:40.000Z","updated":"2022-10-16T08:57:18.744Z","comments":true,"path":"2022/10/15/designPatter/设计模式-01-工厂方法模式/","link":"","permalink":"http://example.com/2022/10/15/designPatter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-01-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、概念及UML图1、概念父类决定实例的生成方式，但并不决定所要生成具体的类，具体处理全部交给子类处理。 将生成实例的框架与具体的实例类解耦。 2、UML 二、案例1、案例12、案例2","categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++:06--function与bind及Lamda实现回调函数","slug":"C++/C-06-function与bind及Lamda实现回调函数","date":"2022-10-15T01:59:13.000Z","updated":"2022-10-16T01:41:46.766Z","comments":true,"path":"2022/10/15/C++/C-06-function与bind及Lamda实现回调函数/","link":"","permalink":"http://example.com/2022/10/15/C++/C-06-function%E4%B8%8Ebind%E5%8F%8ALamda%E5%AE%9E%E7%8E%B0%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","excerpt":"","text":"一、使用std::function作为函数入参1、基于传值的方式传递参数12#include &lt;functional&gt;void registerCallBack(std::function&lt;void()&gt;); 上面的代码实现了一个注册回调函数的机制，入参std::function&lt;void()&gt;是一个模板类对象， 它可以用一个函数签名为void()的可调用对象来进行初始化。 1234// 方法（A）registerCallBack([=]&#123; .... // 回调函数的实现部分&#125;) 这里使用了lambda表达式作为函数的入参，lambda表达式会生成一个匿名的闭包， 基于这个闭包构造了一个std::function&lt;void()&gt;的对象， 然后通过传值调用的方式把这个对象传递registerCallBack函数中使用。 2、基于引用的方式传递参数当然还可以如下实现这个注册函数，入参通过const引用的方式传递，这里的引用必须是const的， 这是因为调用registerCallBack函数的地方生成了一个临时的std::function()对象， 是一个右值，否则编译会报错。 123//方法(B)#include &lt;functional&gt;void registerCallBack(std::function&lt;void()&gt; const&amp;); 这传值和引用区别就在于，在registerCallBack函数内部怎么使用这个入参， 1) 如果只是简单的调用一下std::func()类，那么两种都没有问题，可能使用引用的效率更高； 2) 如果register函数内部需要保存这个std::func()，并用于以后使用，那么方法A直接保存没有问题， 方法B就必须做一次拷贝，否则方法B中，当临时的对象销毁时，有可能出现引用悬空的问题。 3、传值方式下的std::function对象保存如果要在registerCallBack函数内部保存传入的function对象，可以使用std::move，效率更高。 123456789class CallBackHolder &#123;public:void registerCallBack(std::function&lt;void()&gt; func) &#123; callback = std::move(func);&#125; private: std::function&lt;void()&gt; callback; &#125; 二、类的成员函数作为函数入参类的成员函数都会默认有个隐藏的this指针，所以不像普通的函数直接作为入参就可以了。 1、使用bind和function来实现1234567891011121314151617class classA &#123;typedef std::function&lt;void(int i)&gt; callback_t;... void registCb(callback_t func) &#123; cbHandle = std::move(func); &#125;private: callback_t cbHandle;&#125;;class classB &#123;public: classB(classA&amp; cA) &#123; cA.registCb(bind(&amp;classB::handle, this, placeholders::_1)); &#125;&#125;; 2、使用lambda表达式实现123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;class classA &#123;typedef std::function&lt;void(int i)&gt; callback_t;public: classA() &#123;&#125; ~classA() &#123;&#125; void handle(int i) &#123; std::cout &lt;&lt; &quot;classA::handle&quot; &lt;&lt; std::endl; cbHandle(i); &#125; void registCb(callback_t func) &#123;cbHandle = std::move(func);&#125;private: callback_t cbHandle;&#125;;class classB &#123;public: classB(classA&amp; cA) &#123; cA.registCb([this](int i)&#123;classB::handle(i);&#125;); &#125; ~classB() &#123;&#125; void handle(int i)&#123; std::cout &lt;&lt; &quot;classB, handle message&quot; &lt;&lt; i &lt;&lt; std::endl; &#125;&#125;;int main()&#123; classA testa; classB testb(testa); testa.handle(10);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:05--Lamda表达式使用场景","slug":"C++/C-05-Lamda表达式使用场景","date":"2022-10-14T06:54:13.000Z","updated":"2022-10-16T01:41:40.274Z","comments":true,"path":"2022/10/14/C++/C-05-Lamda表达式使用场景/","link":"","permalink":"http://example.com/2022/10/14/C++/C-05-Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"一、lamda表达式变量截取方式1、定义 1) 变量截取方式 2) Lambda表达式的参数列表 3) Mutable 标识 4) 异常标识 5) 返回值 6) “函数”体，也就是lambda表达式需要进行的实际操作 2、变量截取方式[] 不截取任何变量 [&amp;] 截取外部作用域中所有变量，并作为引用在函数体中使用 [&#x3D;] 截取外部作用域中所有变量，并拷贝一份在函数体中使用 [&#x3D;, &amp;foo]截取外部作用域中所有变量，并拷贝一份在函数体中使用，但是对foo使用引用 [bar] 截取bar变量并且拷贝一份在函数体重使用，同时不截取其他变量 [this] 截取当前类中的this指针。如果已经使用了&amp;或者&#x3D;就默认添加此选项 二、lamda表达式使用场景1、场景1简化写法。 //1.1vector数组求和 123456789101112int main()&#123; std::vector&lt;int&gt; some_list; int total = 0; for (int i = 0; i &lt; 5; ++i) some_list.push_back(i); for_each(begin(some_list), end(some_list), [&amp;total](int x) &#123; total += x;&#125;); return 0;&#125; //1.2vector数组排序 123456789101112int main(void)&#123; int data[6] = &#123; 3, 4, 12, 2, 1, 6 &#125;; vector&lt;int&gt; testdata; testdata.insert(testdata.begin(), data, data + 6); // 排序算法 sort(testdata.begin(), testdata.end(), [](int a, int b) &#123; return a &gt; b; &#125;); return 0;&#125; 2、场景2以前类中开启线程都需要通过静态成员函数，现在通过Lambda表达式， 在中括号[this]中可以直接访问到类中的成员变量。 123456789101112131415161718192021222324class A&#123;public: A(); ~A();//析构private: std::unique_ptr&lt;std::thread&gt; monitorThread; int a;&#125;;A::A()&#123; monitorThread = make_unique&lt;thread&gt;([this] &#123; while (true) &#123; cout &lt;&lt; &quot;i can access a &quot; &lt;&lt; a++ &lt;&lt; endl; Sleep(100); &#125; &#125;);&#125;A::~A()&#123;&#125; 3、场景3回调函数实现 123456789101112131415161718192021222324252627class MathCallBack &#123; int ops1,ops2; int result;public: void Add(int a,int b, function&lt;void (int)&gt; func) &#123; ops1 = abs(a); ops2 = abs(b); result = ops1+ops2; func(result); &#125;&#125;;int main()&#123; MathCallBack math; int c1 = 0; math.Add(1, 3, [&amp;c1](int result) -&gt; void &#123; printf(&quot;result = %d\\n&quot;, result); c1 = result; &#125;); printf(&quot;c1 = %d\\n&quot;, c1); return 0;&#125; lambda表达式可以以引用方式捕获上下文中的变量，达到回调的效果。 4、更多参考例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364vector&lt; int&gt; vec;/* 1. simple lambda */ auto it = std::find_if(vec.begin(), vec.end(), [](int i) &#123; return i &gt; 50; &#125;); class A &#123; public: bool operator(int i) const &#123; return i &gt; 50; &#125; &#125;;auto it = std::find_if(vec.begin(), vec.end(), A()); /* 2. lambda return syntax */ function&lt;int(int)&gt; square = [](int i) -&gt; int &#123;return i * i;&#125; /* 3. lambda expr: capture of local variable */ &#123; int min_val = 10; int max_val = 1000; auto it = find_if(vec.begin(), vec.end(), [=](int i) &#123;return i &gt; min_val &amp;&amp; i &lt; max_val;&#125;); auto it = find_if(vec.begin(), vec.end(), [&amp;](int i) &#123;return i &gt; min_val &amp;&amp; i &lt; max_val;&#125;); auto it = find_if(vec.begin(), vec.end(), [=, &amp;max_value](int i) &#123;return i &gt; min_val &amp;&amp; i &lt; max_val;&#125;); &#125; /* 4. lambda expr: capture of class member */ class A &#123; public: void DoSomething(); private: std::vector&lt;int&gt; m_vec; int m_min_val; int m_max_va; &#125;; /* 4.1 capture member by this */ void A::DoSomething() &#123; auto it = find_if(m_vec.begin(), m_vec.end(), [this](int i)&#123; return i &gt; m_min_val &amp;&amp; i &lt; m_max_val;&#125;); &#125; /* 4.2 capture member by default pass-by-value */ void A::DoSomething() &#123; auto it = find_if(m_vec.begin(), m_vec.end(), [=](int i)&#123; return i &gt; m_min_val &amp;&amp; i &lt; m_max_val; &#125;); &#125; /* 4.3 capture member by default pass-by-reference */ void A::DoSomething() &#123; auto it = find_if(m_vec.begin(), m_vec.end(), [&amp;](int i)&#123; return i &gt; m_min_val &amp;&amp; i &lt; m_max_val;&#125;); &#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:04--std::function和std::bind的用法","slug":"C++/C-04-std-function和std-bind的用法","date":"2022-10-14T06:26:43.000Z","updated":"2022-10-16T01:41:35.186Z","comments":true,"path":"2022/10/14/C++/C-04-std-function和std-bind的用法/","link":"","permalink":"http://example.com/2022/10/14/C++/C-04-std-function%E5%92%8Cstd-bind%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"一、std::function的用法1、保存自由函数123456789void printA(int a)&#123; cout &lt;&lt; a &lt;&lt; endl;&#125;std::function&lt;void(int a)&gt; func;func = printA;func(2); 2、保存lamda表达式12std::function&lt;void()&gt; func_1 = []()&#123;cout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl;&#125;;func_1(); 3、保存函数对象12345678910class CStudent&#123;public: void operator() (string strName, int nAge) &#123; cout &lt;&lt; strName &lt;&lt; &quot; : &quot; &lt;&lt; nAge &lt;&lt; endl; &#125;&#125;;CStudent stu;function&lt;void (string, int)&gt; f = stu;f(&quot;Mike&quot;, 12); 4、保存成员函数1234567891011121314struct Foo &#123; Foo(int num) : num_(num) &#123;&#125; void print_add(int i) const &#123; cout &lt;&lt; num_+i &lt;&lt; &#x27;\\n&#x27;; &#125; int num_;&#125;;int main()&#123; std::function&lt;void(const Foo&amp;, int)&gt; f_add_display = &amp;Foo::print_add; Foo foo(2); f_add_display(foo, 1); return 0;&#125; 在实际使用中都用 auto 关键字来代替std::function… 这一长串了 一、std::bind的用法1、用法案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859using namespace std;class A &#123;public: void fun_3(int k, int m) &#123; cout&lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; endl; &#125;&#125;;void fun(int x, int y, int z)&#123; cout&lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; z &lt;&lt; endl;&#125;void fun_2(int &amp;a, int &amp;b)&#123; a++; b++; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;&#125;int main(int argc, const char * argv[])&#123; /* 表示绑定函数fun的第一，二，三个参数值为： 1 2 3 */ auto f1 = std::bind(fun,1,2,3); f1(); //print:1 2 3 /* 前两个形参为占位符，调用时确定，第三个为3 */ auto f2 = std::bind(fun, placeholders::_1, placeholders::_2, 3); f2(1, 2); //print:1 2 3 /* 前两个形参为占位符，调用时确定，第三个为3 */ auto f3 = std::bind(fun, placeholders::_2, placeholders::_1, 3); /* 注意： f2和f3的区别 */ f3(1, 2); //print:2 1 3 int n = 2; int m = 3; auto f4 = std::bind(fun_2, n, placeholders::_1); f4(m); //print: 3 4 /* 打印4，说明bind通过std::placeholders传递的参数是通过引用传递的 */ cout &lt;&lt; m &lt;&lt; endl; /* 打印2，说明：bind对于预先绑定的函数参数是通过值传递的 */ cout &lt;&lt; n &lt;&lt; endl; A a; auto f5 = std::bind(&amp;A::fun_3, a, placeholders::_1, placeholders::_2); f5(10, 20); //print:10 20 std::function&lt;void(int,int)&gt; fc = bind(&amp;A::fun_3, a, placeholders::_1, placeholders::_2); fc(10,20); //print:10 20 return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:03--多级混合继承、虚基类","slug":"C++/C-03-多级混合继承、虚基类","date":"2022-10-13T10:26:35.000Z","updated":"2022-10-16T01:41:28.862Z","comments":true,"path":"2022/10/13/C++/C-03-多级混合继承、虚基类/","link":"","permalink":"http://example.com/2022/10/13/C++/C-03-%E5%A4%9A%E7%BA%A7%E6%B7%B7%E5%90%88%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%9F%BA%E7%B1%BB/","excerpt":"","text":"一、多级混合继承1、例子1234567891011121314151617181920212223242526272829303132//菱形继承class A &#123;public: int data;&#125;;class B : public A &#123;public: int data;&#125;;class C : public A &#123;public: int data;&#125;;class D : public B, public C &#123;public: int data;&#125;;int main()&#123; D c; D.data=1; D.B::data=2;//访问B中的 D.C.::data=3;//访问C中的 D.B::A::data=4;//访问B继承的A D.C::A::data=5;//访问C继承的A D.A::data=4;//错误，产生二义性，不知道是B、C中哪一个&#125; 2、内存大小 3、内存图解 一、虚基类1、概念1) 也称虚继承、菱形继承。用于多级混合继承时，保留一个虚基类。 2) 构造顺序 先构造虚基类，如果有多个虚基类，按声明（从左至右）依次构造; 再构造基类，如果有多个基类，按声明（从左至右）依次构造; 如果有子对象，再构造子对像，如果有多个子对象，按声明的顺序（从上至下）依次构造; 最后构造自己。 2、例子1234567891011121314151617181920212223242526272829303132class A &#123;public: A(int data)&#123;&#125;//1 int data;&#125;;class B : virtual public A &#123;public: B():A(1)&#123;&#125;//2 int data;&#125;;class C : virtual public A &#123;public: C() : A(2)&#123;&#125;//3 int data;&#125;;class D : public B, public C &#123;public: D() : A(3)&#123;&#125;//4 int data;&#125;;int main() &#123; D d; d.data=1; d.B::data=2; d.C::data=3; d.B::A.data=4; d.C::A::data=5;&#125; 1) 构造顺序为：1-2-3-4 2) 构造顺序解释：构造类D对象d的时候，发现继承于B，于是去构造B， 构造B的时候，发现继承于虚基类A，于是构造虚基类A，接着构造B。 再接着构造C，发现C继承于虚基类A，但发现虚基类A已经被B构造过了， 所以不再构造A，直接构造C。最后构造D。 3) 如果虚基类构造函数为带参构造，则其子类，以及子类拓展出来的子类， 都要在成员初始化列表对其进行构造函数的初始化。 4) d的data赋值为1，继承于B、C，分别赋值为2,3，顺序为从左至右。 A的值本来为4，后来执行到最后一行的时候被赋值为5 3、内存大小 4、内存图解","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:02--成员变量初始化方式","slug":"C++/C-02-成员变量初始化方式","date":"2022-10-13T08:58:08.000Z","updated":"2022-10-16T01:41:22.430Z","comments":true,"path":"2022/10/13/C++/C-02-成员变量初始化方式/","link":"","permalink":"http://example.com/2022/10/13/C++/C-02-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/","excerpt":"","text":"一、成员变量3种初始化方式1) 在构造函数体内赋值初始化 2) 在自定义的公有函数体中赋值初始化（一般用于成员变量的初始化） 3) 在构造函数的成员初始化列表初始化 二、构造函数体内初始化1、说明在构造函数体内的初始化方式，本质是是为成员变量赋值，而不是真正意义上的初始化。 2、案例1234567891011class Cperson &#123;public: Cperson(int age, float height) &#123; m_age = age; m_height = height; &#125;private: int m_age; float m_height;&#125; 三、自定义的公有函数体中赋值初始化1、说明与构造函数体内初始化方式一样，此种方式本质上也是赋值，而不是初始化。 2、案例1234567891011class Cperson &#123;public: void setPerson(int age, float height) &#123; m_age = age; m_height = height; &#125;private: int m_age; float m_height;&#125; 四、成员初始化列表初始化1、说明1) 写在构造函数的后面，随着构造函数的执行而执行。 2) 初始化列表初始化优先于构造函数内的代码执行顺序。 3) 一般只对无动态内存的成员、const成员、引用初始化, 其中const成员、引用成员必须在初始化列表初始化。 4) 成员初始化列表初始化效率更高。 5) 有动态内存的成员必须在构造函数内部进行初始化。 2、案例1 (const成员、引用成员必须在初始化列表初始化)123456789101112131415class Person &#123;public: Person(int i);private: const int id; int&amp; m_id;&#125;;Person::Person(int i)&#123; id = i; //错误，const成员变量必须在成员初始化列表初始化 m_id = id; //错误，引用也必须在成员初始化列表初始化&#125; 3、案例2 (成员初始化列表初始化效率更高)1234567891011class Word&#123;public: Word()&#123; _name=0; //先创建一个临时string对象，赋值为0，然后拷贝给_name _cnt=0; //构造函数结束之后，临时对象析构释放 &#125;private: string _name; int _cnt;&#125;; 但是如果使用下面的成员初始化列表初始化，那么就省去了创建临时对象再拷贝的过程 12345678 class Word&#123; public: Word() :_name(0),_cnt(0)&#123;&#125; //直接初始化_name，不创建临时对象 private: string _name; int _cnt;&#125;; 五、总结1) 成员初始化列表初始化成员才是真正意义上的初始化，其他两种方式都是为赋值。 2) 初始化是直接初始化。而赋值是先初始化一个临时变量，再赋值。前者效率高。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++:01--this指针","slug":"C++/C-01-this指针","date":"2022-10-13T08:09:26.000Z","updated":"2022-10-16T01:41:16.814Z","comments":true,"path":"2022/10/13/C++/C-01-this指针/","link":"","permalink":"http://example.com/2022/10/13/C++/C-01-this%E6%8C%87%E9%92%88/","excerpt":"","text":"一、this指针应用1、剖析1) 对于类成员函数而言，并不是一个对象对应一个单独的成员函数体，而是此类的所有对象共用这个成员函数体。 当程序被编译之后，此成员函数地址已经确定。 1) 调用类的成员函数时，会将当前对象的this指针传递给成员函数，然后在函数体内对类的数据成员访问时， 就会被转换为“this-&gt;数据成员”的形式。 1) 如果成员函数内部没有访问对象的任何数据成员，那么传进来的this指针实际没有任何用处， 这样的函数与全局函数并没有太大区别。 &amp;nbsp; 2、案例11234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class MyClass &#123;public: int data; MyClass(int data) &#123; this-&gt;data = data; &#125; void print() &#123; //cout&lt;&lt; data &lt;&lt; endl; cout &lt;&lt; &quot;hello!&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; MyClass *pMyClass; pMyClass = new MyClass(1); pMyClass-&gt;print(); pMyClass[0].print(); pMyClass[1].print(); pMyClass[10000000].print(); return 0;&#125; 程序输出如下： 结果分析： 1) 此处我们创建了一个对象，但是访问后面越界之后仍然可以访问成功。 2) 如果一个成员函数没有操作任何类的数据成员，因此这个成员函数与全局函数类型，调用之后都会打印“hello!”。 &amp;nbsp; 3、案例21234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class MyClass &#123;public: int data; MyClass(int data) &#123; this-&gt;data = data; &#125; void print() &#123; cout&lt;&lt; data &lt;&lt; endl; cout &lt;&lt; &quot;hello!&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; MyClass *pMyClass; pMyClass = new MyClass(1); pMyClass-&gt;print(); pMyClass[0].print(); pMyClass[1].print(); pMyClass[10000000].print(); return 0;&#125; 程序输出如下： 结果分析： 1) 此处我们的成员函数访问了类的数据成员，那么每次打印数据时都会通过this指针调用。 2) 但是此处我们只创建了一个对象，所以当调用pMyClass[1]和pMyClass[10000000]越界了，找不到对象，从而报错。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ubuntu搭建Qt4Android的开发环境","slug":"ubuntu/ubuntu搭建Qt4Android的开发环境","date":"2022-09-29T05:45:30.000Z","updated":"2022-10-16T03:33:57.869Z","comments":true,"path":"2022/09/29/ubuntu/ubuntu搭建Qt4Android的开发环境/","link":"","permalink":"http://example.com/2022/09/29/ubuntu/ubuntu%E6%90%AD%E5%BB%BAQt4Android%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"一、软件版本选择1234android-studio: android-studio-2020.3.1.26-linux.tar.gzandroid-sdk: android-sdk_r24.4.1-linux.tgzandroid-ndk: android-ndk-r19c-linux-x86_64.zipQt: 5.12.8 二、安装软件1、安装jdk123456sudo apt install -y openjdk-8-jdkvi /etc/profileexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64export PATH=$PATH:$&#123;JAVA_HOME&#125;/binsource /etc/profile 2、安装sdk解压并运行android-studio, 将sdk、tool等下载到一个空的文件夹android-sdk下 解压android-sdk_r24.4.1-linux.tgz并赋值其目录下的tools到android-sdk下 3、解压ndk解压 android-ndk-r19c-linux-x86_64.zip 4、设置交叉编译","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"ubuntu安装VNC-无需显示屏","slug":"ubuntu/ubuntu安装VNC-无需显示屏","date":"2022-09-28T06:35:13.000Z","updated":"2022-10-16T03:33:52.097Z","comments":true,"path":"2022/09/28/ubuntu/ubuntu安装VNC-无需显示屏/","link":"","permalink":"http://example.com/2022/09/28/ubuntu/ubuntu%E5%AE%89%E8%A3%85VNC-%E6%97%A0%E9%9C%80%E6%98%BE%E7%A4%BA%E5%B1%8F/","excerpt":"","text":"一、安装1、安装VNC1234sudo apt-get install x11vnc –y/* generate password */sudo x11vnc -storepasswd /etc/x11vnc.pass 2、启动VNC1sudo x11vnc -display :0 -auth /var/run/lightdm/root/:0 -forever -bg -o /var/log/x11vnc.log -rfbauth /etc/x11vnc.pass -rfbport 5901 一、配置无显示器访问1、生成配置文件1234sudo Xorg :1 –configure/* 此时会在root路径下生成xorg.conf.new文件 */cp /root/xorg.conf.new /usr/share/X11/xorg.conf.d/xorg.conf 2、安装虚拟显卡驱动1sudo apt install xserver-xorg-video-dummy 3、添加虚拟显卡配置1234567891011121314151617181920212223242526272829sudo vi /usr/share/X11/xorg.conf.d/xorg.conf/* 在文件最后添加以下内容 */Section &quot;Monitor&quot; Identifier &quot;Monitor1&quot; HorizSync 1.0 - 2000.0 VertRefresh 1.0 - 200.0 # Add 16:9 modes, others are automatically detected. Modeline &quot;1280x720&quot; 74.48 1280 1336 1472 1664 720 721 724 746 Modeline &quot;1920x1080&quot; 172.80 1920 2040 2248 2576 1080 1081 1084 1118EndSectionSection &quot;Device&quot; Identifier &quot;Card1&quot; Driver &quot;dummy&quot; VideoRam 256000EndSection Section &quot;Screen&quot; DefaultDepth 24 Identifier &quot;Screen1&quot; Device &quot;Card1&quot; Monitor &quot;Monitor1&quot; SubSection &quot;Display&quot; Depth 24 Modes &quot;1920x1080&quot; EndSubSectionEndSection 4、虚拟与真实显示器同时工作配置修改步骤3中的配置文件最上面的ServerLayout: 12345Section &quot;ServerLayout&quot; Identifier &quot;X.org Configured&quot; Screen 0 &quot;Screen0&quot; 0 0 Screen 1 &quot;Screen1&quot; 0 0EndSection","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]},{"title":"树莓派3B+xenomai+igh","slug":"servoCtrl/树莓派3B-xenomai-igh","date":"2022-09-28T05:42:02.000Z","updated":"2022-10-16T03:34:20.236Z","comments":true,"path":"2022/09/28/servoCtrl/树莓派3B-xenomai-igh/","link":"","permalink":"http://example.com/2022/09/28/servoCtrl/%E6%A0%91%E8%8E%93%E6%B4%BE3B-xenomai-igh/","excerpt":"","text":"一、源码包准备1、安装依赖软件1sudo apt install git bc bison flex libssl-dev make 2、源码版本12345git clone https://github.com/raspberrypi/linux.gitgit checkout rpi-4.1.ygit clone http://git.xenomai.org/xenomai-3.git/git checkout v3.0.2 二、实时内核移植1、打实时补丁12345cd xenomai-3scripts/prepare-kernel.sh --linux=../linux/ --arch=arm --ipipe=./kernel/cobalt/arch/arm/patches/ipipe-core-4.1.18-arm-4.patchcd ../linuxcat ../patch-xenomai-3-on-bcm-2709.patch | patch -p1 2、配置内核123456789101112131415161718make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfigmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig/* config linux kernel with the following options */CPU Power Management ---&gt;CPU Frequency scaling ---&gt; [ ] CPU Frequency scalingCPU idle ---&gt; [ ] CPU idle PM supportKernel Features ---&gt; [ ] Contiguous Memory Allocator [ ] Allow for memory compactionKernel Hacking ---&gt; [ ] KGDB: kernel debuggerBoot options ---&gt; Kernel command line type ---&gt; [X] Extend bootloader kernel arguments 3、编译内核及模块1234make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs -j20mkdir modulesmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- INSTALL_MOD_PATH=modules modules_install 4、安装到系统123456cp arch/arm/boot/zImage /media/$&#123;USER&#125;/bootcp arch/arm/boot/dts/bcm2710-rpi-3-b.dtb /media/$&#123;USER&#125;/bootrm -rf /media/$&#123;USER&#125;/boot/overlays/*cp arch/arm/boot/dts/overlays/*.dtb* /media/$&#123;USER&#125;/boot/overlays/sudo cp -r linux/dist/lib/modules/* /media/$&#123;USER&#125;/$&#123;ROOTFS&#125;/lib/modules 5、修改系统启动项12kernel=$&#123;zImage name&#125;device_tree=bcm2710-rpi-3-b.dtb 三、安装xenomai1、配置123cd xenomai-3./scripts/bootstrap --with-core=cobalt –enable-debug=partial./configure CFLAGS=&quot;-march=armv7-a -mtune=cortex-a8 -mfloat-abi=hard -mfpu=neon -ffast-math&quot; --host=arm-linux-gnueabihf --target=arm-linux-gnueabihf --enable-smp 2、编译12mkdir targetmake DESTDIR=$&#123;PWD&#125;/target install 3、安装到系统1sudo cp -a target/* /media/$&#123;USER&#125;/$&#123;ROOTFS&#125;/ 三、安装IGH1、源码包123git clone https://gitlab.com/etherlab.org/ethercat.gitcd ethercatgit checkout stable-1.5 2、配置123mkdir etherlab./bootstrap./configure --prefix=$&#123;PWD&#125;/etherlab --with-linux-dir=$&#123;PWD&#125;/../linux --enable-8139too=no --enable-generic=yes CC=arm-linux-gnueabihf-gcc --host=arm-linux-gnueabihf 3、编译12make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- all modules -j20make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- install -j20 4、可能出现的问题及解决123issue: /usr/bin/ld: error: ethercat use VFP register arguments, ../master/soe_errors.o does notsolve: touch ~/ethercat/master/soe_errors.c 5、安装到系统123456789101112131415161718mkdir -p $&#123;PWD&#125;/etherlab/modulescp devices/ec_generic.ko etherlab/modules/cp master/ec_master.ko etherlab/modules/sudo cp -r etherlab/ /opt sudo ln -fs /opt/etherlab/etc/init.d/ethercat /etc/init.d/sudo ln -fs /opt/etherlab/bin/ethercat /usr/local/bin/sudo mkdir /etc/sysconfigsudo ln -fs /opt/etherlab/etc/sysconfig/ethercat /etc/sysconfig/sudo susudo echo KERNEL==\\&quot;EtherCAT[0-9]*\\&quot;, MODE=\\&quot;0664\\&quot; &gt; /etc/udev/rules.d/99-EtherCAT.rulesexitsudo cp /opt/etherlab/modules/ec_master.ko /lib/modules/4.14.91-rt49-v7+sudo depmodvi ~/.bashrcPATH=$PATH:/opt/etherlab/binsource ~/.bashrc 6、配置网卡123vi /etc/sysconfig/ethercatMASTER0_DEVICE=”b8:27:eb:7d:26:a2” //填写实际的MACDEVICE_MODULES=”generic” 7、启动igh1sudo /etc/init.d/ethercat start 6、测试经过测试发现igh1.5.2可以在pi3上运行，但是效果很差，代码运行后不能识别对应的pdo，原因待查找","categories":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]},{"title":"x86工控机安装igh","slug":"servoCtrl/x86工控机安装igh","date":"2022-09-27T13:51:31.000Z","updated":"2022-10-16T03:34:08.809Z","comments":true,"path":"2022/09/27/servoCtrl/x86工控机安装igh/","link":"","permalink":"http://example.com/2022/09/27/servoCtrl/x86%E5%B7%A5%E6%8E%A7%E6%9C%BA%E5%AE%89%E8%A3%85igh/","excerpt":"","text":"一、网卡驱动类型1、通用型优点: generic通用型的网卡驱动对物理网卡没有太多要求，只需要Linux系统支持其驱动， 就能在IGH的配置中将其选作网卡驱动。 缺点: 实时性较差，尤其是进行dc同步控制时表现更为明显。 2、本地型优点: native本地型网卡驱动是官方专门适配的几款Intel网卡，实时性方面有良好的保证 缺点: 只支持几款网卡，并且还需专门的内核版本支持。 二、安装通用型网卡驱动1、下载源码包https://sourceforge.net/p/etherlabmaster/code/ci/stable-1.5/tree/ 2、配置1234cd path/to/ethercatMaster./bootstrapmkdir etherlab./configure --prefix=/home/lufahai/xenohegongda/etherlabmaster/etherlab --with-linux-dir=/home/lufahai/xenohegongda/linux-4.9.51 --enable-cycles --enable-hrtimer --enable-8139too=no --enable-generic=yes configure中的路径需要根据本地实际路径修改 3、编译及安装1234make -j16make modules -j16sudo make installsudo make modules_install 4、创建软连接12345678910111213mkdir -p ~/ethercat/etherlab/modulescp devices/ec_generic.ko etherlab/modules/cp master/ec_master.ko etherlab/modules/sudo cp -r etherlab/ /opt sudo ln -fs /opt/etherlab/etc/init.d/ethercat /etc/init.d/sudo ln -fs /opt/etherlab/bin/ethercat /usr/local/bin/sudo mkdir /etc/sysconfigsudo ln -fs /opt/etherlab/etc/sysconfig/ethercat /etc/sysconfig/sudo suecho KERNEL==\\&quot;EtherCAT[0-9]*\\&quot;, MODE=\\&quot;0664\\&quot; &gt; /etc/udev/rules.d/99-EtherCAT.rulesexitsudo cp /opt/etherlab/modules/ec_master.ko /lib/modules/4.9.51-xenomai3.1+sudo depmod 此步骤中的路径需要根据本地实际路径修改 5、配置网卡ifconfig 找出网卡的MAC地址 123sudo vi /etc/sysconfig/ethercatMASTER0_DEVICE=”b8:27:eb:7d:26:a2” //填写实际MACDEVICE_MODULES=”generic” 6、增加系统路径在~/.bashrc 末尾增加下面内容并source 12PATH=$PATH:/opt/etherlab/binsource ~/.bashrc 7、添加库文件供程序链接如果没有将xenomai的库添加到系统路径中，程序在链接的时候就会出现 error: while loading shared libraries... 解决： 123sudo vi /etc/ld.so.conf/usr/xenomai/lib //文件中增加这一行sudo ldconfig -v //使其生效 三、安装native型网卡驱动1、内核及igh源码版本的下载地址安装native型网卡驱动需要内核支持此网卡驱动， 最好的内核无疑是igh官方经过优化后的，下载地址如下 内核：https://source.denx.de/Xenomai/linux-dovetail branch选择 v5.10.y-dovetail igh源码： https://gitlab.com/etherlab.org/ethercat/-/tree/e1000e-5.10 branch选择 e1000e-5.10 xenomai选择3.2.1版本 2、Linux内核配置由于使用官方提供的内核，所以打补丁与另一篇搭建实时系统博客中的方法略有不同 12cd path/to/kernel../xenomai-v3.2.1/scripts/prepare-kernel.sh --arch=x86_64 Linux5.10的内核配置可以参考下面的附录，编译及安装过程与4.x内核移植 3、native型网卡配置12345cd path/to/ighsourceTree./scrip/bootstrapmkdir etherlab./configure --prefix=/home/huger/rtlinux/ethercat-e1000e-5.10/etherlab -enable-8139too=no -enable-e1000e=yes 4、编译及安装123make all modules -j16sudo make modules_install install -j16sudo depmod 5、创建软链接与通用型相同 6、配置网卡sudo vi /etc/sysconfig/ethercat MASTER0_DEVICE=”b8:27:eb:7d:26:a2” //填写实际MAC DEVICE_MODULES=”e1000e” 三、Linux5.10内核配置附录1234567891011121314151617181920212223242526272829303132333435363738394041424344Recommended options:* General setup --&gt; Local version - append to kernel release: -xenomai-3.0.5 --&gt; Timers subsystem --&gt; High Resolution Timer Support (Enable)* Xenomai/cobalt --&gt; Sizes and static limits --&gt; Number of registry slots (512 --&gt; 4096) --&gt; Size of system heap (Kb) (512 --&gt; 4096) --&gt; Size of private heap (Kb) (64 --&gt; 256) --&gt; Size of shared heap (Kb) (64 --&gt; 256) --&gt; Maximum number of POSIX timers per process (128 --&gt; 512) --&gt; Drivers --&gt; RTnet --&gt; RTnet, TCP/IP socket interface (Enable) --&gt; Drivers --&gt; New intel(R) PRO/1000 PCIe (Enable) --&gt; Realtek 8169 (Enable) --&gt; Loopback (Enable) --&gt; Add-Ons --&gt; Real-Time Capturing Support (Enable)* Power management and ACPI options --&gt; CPU Frequency scaling --&gt; CPU Frequency scaling (Disable) --&gt; ACPI (Advanced Configuration and Power Interface) Support --&gt; Processor (Disable) --&gt; CPU Idle --&gt; CPU idle PM support (Disable)* Pocessor type and features --&gt; Enable maximum number of SMP processors and NUMA nodes (Disable) // Ref : http://xenomai.org/pipermail/xenomai/2017-September/037718.html --&gt; Processor family --&gt; Core 2/newer Xeon (if &quot;cat /proc/cpuinfo | grep family&quot; returns 6, set as Generic otherwise) // Xenomai will issue a warning about CONFIG_MIGRATION, disable those in this order --&gt; Transparent Hugepage Support (Disable) --&gt; Allow for memory compaction (Disable) --&gt; Contiguous Memory Allocation (Disable) --&gt; Allow for memory compaction --&gt; Page Migration (Disable)* Device Drivers --&gt; Staging drivers --&gt; Unisys SPAR driver support --&gt; Unisys visorbus driver (Disable) ​","categories":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]},{"title":"x86工控机搭建ubuntu18+xenomai实时系统","slug":"servoCtrl/x86工控机搭建ubuntu18-xenomai实时系统","date":"2022-09-27T08:37:14.000Z","updated":"2022-10-16T03:34:15.764Z","comments":true,"path":"2022/09/27/servoCtrl/x86工控机搭建ubuntu18-xenomai实时系统/","link":"","permalink":"http://example.com/2022/09/27/servoCtrl/x86%E5%B7%A5%E6%8E%A7%E6%9C%BA%E6%90%AD%E5%BB%BAubuntu18-xenomai%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"一、安装系统及软件依赖1、系统选择选择安装 ubuntu18.04.6 LTS 2、软件依赖1sudo apt install libc6-dev libncurses5-dev libssl-dev build-essential bison flex lib32stdc++6 lib32z1 autoconf automake libtool pkg-config libelf-dev 3、软件版本及下载kernel: 4.9.38: https://mirrors.edge.kernel.org/pub/linux/kernel/ xenomai3.1及补丁: https://xenomai.org/downloads/ 二、配置内核1、打补丁123cd linux-4.9.38../xenomai-3.1/scripts/prepare-kernel.sh --arch=x86_64 --ipipe=ipipe-core-4.9.38-x86-3.patch 2、安装内核管理包1sudo apt install kernel-package 在弹出的界面中选择 “keep the local version…….” 3、配置kernel1make menuconfig 安装附录中的选项配置内核，去除xenomai相关的警告 4、去除编译错误1vi .config 找到SYSTEM_TRUSTED_KEYS将其赋值为空，使用#注释掉CONFIG_DEBUG_INFO_BTF 12SYSTEM_TRUSTED_KEYS=&quot;&quot;#CONFIG_DEBUG_INFO_BTF 5、编译内核1CONCURRENCY_LEVEL=$(nproc) make-kpkg --rootcmd fakeroot --initrd kernel_image kernel_headers 6、参考文档https://blog.csdn.net/qq_28882933/article/details/123626659?spm=1001.2014.3001.5502 三、安装新内核并修改grub1、安装内核编译完成后会在上一层目录生成对应的deb安装包 12cd ..sudo dpkg -i *.deb 2、增加非root用户123sudo addgroup xenomai --gid 1234sudo addgroup root xenomaisudo usermod -a -G xenomai $USER 3、查看当前系统下的所有可用内核1cat /boot/grub/grub.cfg | grep menuentry 记住刚才安装的实时内核下标号 4、修改grub启动项1sudo vi /etc/default/grub 倒数第二个选项，要在后面加命令行“xenomai.allowed_group=1234”即上步骤新增的组，具体修改如下: 5、更新grub12sudo update-grubsudo reboot 四、安装xenomai1、编译源文件1234567cd xenomai-3.1./configure --with-pic --with-core=cobalt --enable-smp --disable-tls --enable-dlopen-libs --disable-clock-monotonic-rawmake -j`nproc`sudo make install 2、配置系统路径12345678910111213echo &#x27;### Xenomaiexport XENOMAI_ROOT_DIR=/usr/xenomaiexport XENOMAI_PATH=/usr/xenomaiexport PATH=$PATH:$XENOMAI_PATH/bin:$XENOMAI_PATH/sbinexport PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$XENOMAI_PATH/lib/pkgconfigexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$XENOMAI_PATH/libexport OROCOS_TARGET=xenomai&#x27; &gt;&gt; ~/.xenomai_rcecho &#x27;source ~/.xenomai_rc&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc 3、实时性测试123sudo chmod -R 777 /dev/rtdm/memdev-privatesudo chmod -R 777 /dev/rtdm/memdev-sharedxeno latency 4、修改 lat best为负的方法123sudo suecho 0 &gt; /proc/xenomai/latencyxeno latency 运行一小段时间待其稳定后查看此时lat best 的数值, 将此数值乘1000 后重新echo 1echo value*1000 &gt; /proc/xenomai/latency 五、添加库文件供程序链接如果没有将xenomai的库添加到系统路径中，程序在链接的时候就会出现 error: while loading shared libraries... 解决： 123sudo vi /etc/ld.so.conf/usr/xenomai/lib //文件中增加这一行sudo ldconfig -v //使其生效 六、内核配置附录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 #进入menuconfig界面，会看影响xenomai实时性的警告信息：#*** WARNING! Page migration (CONFIG_MIGRATION) may increase ***#*** latency. ***#*** WARNING! At least one of APM, CPU frequency scaling, ACPI ‘processor‘ ***#*** or CPU idle features is enabled. Any of these options may ***#*** cause troubles with Xenomai. You should disable them. ***#具体配置如下所示： * General setup --&gt; Local version - append to kernel release: -xenomai-3.1 --&gt; Timers subsystem --&gt; High Resolution Timer Support (Enable) * Xenomai/cobalt --&gt; Sizes and static limits --&gt; Number of registry slots (512 --&gt; 4096) --&gt; Size of system heap (Kb) (512 --&gt; 4096) --&gt; Size of private heap (Kb) (64 --&gt; 256) --&gt; Size of shared heap (Kb) (64 --&gt; 256) --&gt; Maximum number of POSIX timers per process (128 --&gt; 512) --&gt; Drivers --&gt; RTnet --&gt; RTnet, TCP/IP socket interface (Enable) --&gt; Drivers --&gt; New intel(R) PRO/1000 PCIe (Enable) --&gt; Realtek 8169 (Enable) --&gt; Loopback (Enable) --&gt; Add-Ons --&gt; Real-Time Capturing Support (Enable) * Power management and ACPI options --&gt; CPU Frequency scaling --&gt; CPU Frequency scaling (Disable) --&gt; ACPI (Advanced Configuration and Power Interface) Support --&gt; Processor (Disable) --&gt; CPU Idle --&gt; CPU idle PM support (Disable) * Pocessor type and features --&gt; Enable maximum number of SMP processors and NUMA nodes (Disable) // Ref : http://xenomai.org/pipermail/xenomai/2017-September/037718.html --&gt; Processor family --&gt; Core 2/newer Xeon (if &quot;cat /proc/cpuinfo | grep family&quot; returns 6, set as Generic otherwise) // Xenomai will issue a warning about CONFIG_MIGRATION, disable those in this orde --&gt; Transparent Hugepage Support (Disable) --&gt; Allow for memory compaction (Disable) --&gt; Contiguous Memory Allocation (Disable) --&gt; Allow for memory compaction --&gt; Page Migration (Disable) * Device Drivers --&gt; Staging drivers --&gt; Unisys SPAR driver support --&gt; Unisys visorbus driver (Disable)","categories":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]},{"title":"ubuntu安装hexo踩坑","slug":"ubuntu/ubuntu安装hexo踩坑","date":"2022-09-27T07:04:27.000Z","updated":"2022-10-16T03:33:43.945Z","comments":true,"path":"2022/09/27/ubuntu/ubuntu安装hexo踩坑/","link":"","permalink":"http://example.com/2022/09/27/ubuntu/ubuntu%E5%AE%89%E8%A3%85hexo%E8%B8%A9%E5%9D%91/","excerpt":"","text":"软件问题导致无法安装HEXO现象及原因如果默认使用 1sudo apt install nodejs npm 系统会默认安装低版本的软件，然而在执行 1npm install -g hexo 会提示版本太低 解决123sudo apt install curlcurl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -sudo apt-get install -y nodejs 这就安装了高版本的软件，可以直接安装hexo. 部署到github上后网页乱码解决打开网址 http://ipaddress.com/ 右上角进行查找 assets-cdn.github.com，得到相应的IP 然后在 /etc/hosts中增加 185.199.109.153 assets-cdn.github.com 以实ip为准，如果一个ip无效，那么就多试其他ip","categories":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"}]}],"categories":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/categories/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"},{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/categories/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"模式设计","slug":"模式设计","permalink":"http://example.com/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"ubuntu系统","slug":"ubuntu系统","permalink":"http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"},{"name":"伺服控制","slug":"伺服控制","permalink":"http://example.com/tags/%E4%BC%BA%E6%9C%8D%E6%8E%A7%E5%88%B6/"}]}