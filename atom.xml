<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StephenLu`s Blog</title>
  
  <subtitle>Embedded Software Engineering</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-08-20T06:13:29.958Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Stephen Lu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用vtune分析程序对CPU的占用</title>
    <link href="http://example.com/2025/08/20/ubuntu/%E4%BD%BF%E7%94%A8vtune%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%AF%B9CPU%E7%9A%84%E5%8D%A0%E7%94%A8/"/>
    <id>http://example.com/2025/08/20/ubuntu/%E4%BD%BF%E7%94%A8vtune%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%AF%B9CPU%E7%9A%84%E5%8D%A0%E7%94%A8/</id>
    <published>2025-08-20T05:54:31.000Z</published>
    <updated>2025-08-20T06:13:29.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>之前有使用过pref分析应用程序的瓶颈并生成火焰图，但pref存在一些局限性，有时候不能看到完整函数名称，分析的结果也不够直观。<br>偶然发现intel提供了一个更强大的性能分析工具： vtune</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wget https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB</span><br><span class="line"></span><br><span class="line">sudo apt-key add GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://apt.repos.intel.com/oneapi all main&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/oneAPI.list</span><br><span class="line"></span><br><span class="line">sudo add-apt-repository <span class="string">&quot;deb https://apt.repos.intel.com/oneapi all main&quot;</span></span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt install intel-oneapi-vtune</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>软件会安装在&#x2F;opt目录下，将环境脚本加到~&#x2F;.bashrc里边：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nano ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> /opt/intel/oneapi/vtune/2025.5/env/vars.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h1 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h1><p>写一个C语言程序 matrix_multiply.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> A[N][N], B[N][N], C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">matrix_multiply</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            C[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; N; k++) &#123;</span><br><span class="line">                C[i][j] += A[i][k] * B[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Initialize matrices A and B</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            A[i][j] = i + j;</span><br><span class="line">            B[i][j] = i - j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    matrix_multiply();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并使用vtune分析：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -O2 -g -o matrix_multiply matrix_multiply.c</span><br><span class="line"></span><br><span class="line">vtune -collect hotspots -- ./matrix_multiply</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vtune: Executing actions 75 % Generating a report                              Elapsed Time: 3.750s</span><br><span class="line">    CPU Time: 3.740s</span><br><span class="line">        Effective Time: 3.740s</span><br><span class="line">        Spin Time: 0s</span><br><span class="line">        Overhead Time: 0s</span><br><span class="line">    Total Thread Count: 1</span><br><span class="line">    Paused Time: 0s</span><br><span class="line"></span><br><span class="line">Top Hotspots</span><br><span class="line">Function         Module           CPU Time  % of CPU Time(%)</span><br><span class="line">---------------  ---------------  --------  ----------------</span><br><span class="line">matrix_multiply  matrix_multiply    3.640s             97.3%</span><br><span class="line">main             matrix_multiply    0.100s              2.7%</span><br><span class="line">Collection and Platform Info</span><br><span class="line">    Application Command Line: ./matrix_multiply</span><br><span class="line">    Operating System: 6.8.0-64-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=22.04 DISTRIB_CODENAME=jammy DISTRIB_DESCRIPTION=<span class="string">&quot;Ubuntu 22.04.5 LTS&quot;</span></span><br><span class="line">    Computer Name: vm22</span><br><span class="line">    Result Size: 3.7 MB</span><br><span class="line">    Collection start time: 05:49:13 20/08/2025 UTC</span><br><span class="line">    Collection stop time: 05:49:17 20/08/2025 UTC</span><br><span class="line">    Collector Type: User-mode sampling and tracing</span><br><span class="line">    CPU</span><br><span class="line">        Name: Unknown</span><br><span class="line">        Frequency: 2.304 GHz</span><br><span class="line">        Logical CPU Count: 4</span><br><span class="line">        Cache Allocation Technology</span><br><span class="line">            Level 2 capability: not detected</span><br><span class="line">            Level 3 capability: not detected</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到绝大多数的CPU占用都是在matrix_multiply这个函数中。</p><h1 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h1><p>第一次运行vtune的时候出现</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnnnot start data collection because the scope of ptrace system call application is limited.</span><br><span class="line">To <span class="built_in">enable</span> profiling,please <span class="built_in">set</span> /proc/sys/kernel/yama/ptrace_scope to 0. See the Release Notes <span class="keyword">for</span> </span><br><span class="line">instructions on enabling it permanently</span><br></pre></td></tr></table></figure><p>查看 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;yama&#x2F;ptrace_scope 显示的值为1<br>打开如下文件，把1改为0并保存退出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/sysctl.d/10-ptrace.conf</span><br></pre></td></tr></table></figure><p>重新启用新值：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl --system -a -p</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;之前有使用过pref分析应用程序的瓶颈并生成火焰图，但pref存在一些局限性，有时候不能看到完整函数名称，分析的结果也不够直观。&lt;b</summary>
      
    
    
    
    <category term="ubuntu系统" scheme="http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="ubuntu系统" scheme="http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>openGL使用FBO渲染纹理尺寸的调整</title>
    <link href="http://example.com/2025/08/13/OpenGl/openGL%E4%BD%BF%E7%94%A8FBO%E6%B8%B2%E6%9F%93%E7%BA%B9%E7%90%86%E5%B0%BA%E5%AF%B8%E7%9A%84%E8%B0%83%E6%95%B4/"/>
    <id>http://example.com/2025/08/13/OpenGl/openGL%E4%BD%BF%E7%94%A8FBO%E6%B8%B2%E6%9F%93%E7%BA%B9%E7%90%86%E5%B0%BA%E5%AF%B8%E7%9A%84%E8%B0%83%E6%95%B4/</id>
    <published>2025-08-13T00:58:25.000Z</published>
    <updated>2025-08-18T02:11:04.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h1><p>在之前的测试中可以使用FBO的MRT方式，一次可以输出多张纹理。但这种方法存在一点缺陷，即经过FBO渲染的纹理无法自动适配屏幕分辨率。例子如下，<br>1、假如创建纹理的尺寸与输入图像尺寸一致，如果不使用FBO，而是直接将纹理渲染于显示器，那么无论显示屏分辨率与图像分辨率是否相同，纹理都能做相应的缩放以适应显示屏分辨率。<br>2、但如果先使用FBO渲染出一个1080P的纹理，然后将其渲染到一个2560x1440分辨率的显示器上，此时纹理显示不全，无法自动适配显示器分辨率。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>为了解决这个问题，需要显式地将FBO输出纹理缩放到目标分辨率的纹理上。<br>glBlitFramebuffer 提供了这个功能，它将FBO1的纹理拷贝到FBO2的纹理上。性能上比重新draw一次要快。</p><p>具体方法如下：<br>例如输入图像尺寸是800x480, 屏幕分辨率为1280x720</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mWidth = <span class="number">800</span>;</span><br><span class="line"><span class="type">int</span> mHeight = <span class="number">480</span>;</span><br><span class="line"><span class="type">int</span> mScrnWidth = <span class="number">1280</span>;</span><br><span class="line"><span class="type">int</span> mScrnHeight = <span class="number">720</span>;</span><br></pre></td></tr></table></figure><p>创建FBO1及其纹理，此FBO1将图像渲染到 ATTACHMENT0的纹理上，纹理大小和图像尺寸一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">glGenFramebuffers(<span class="number">1</span>, &amp;FBO1);</span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, FBO1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fbo render to this texture */</span></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;mFBOTexture0);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, mFBOTexture0);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, mWidth, mHeight, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line">glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, mFBOTexture0, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fbo not complete\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>创建另一个FBO2及屏幕显示的纹理。注意，这个纹理尺寸需要与屏幕分辨率一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">glGenFramebuffers(<span class="number">1</span>, &amp;mScrnFBO);</span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, mScrnFBO);</span><br><span class="line"></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;mScrnTexture);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, mScrnTexture);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, mScrnWidth, mScrnHeight, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line">glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, mScrnTexture, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;screen fbo not complete\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>纹理拷贝，如果分辨率不同，那么使用GL_LINEAR插值，图像平滑；如果分辨率相同，那么使用GL_NEARST,<br>可以避免插值，效率更高。 这样copy之后，渲染后的纹理就缩放到 与显示器分辨率相对应的纹理上。<br>注意FBO离屏渲染的时候一定要设置viewPort为图像尺寸。<br>然后显示器显示的时候，把viewPort为屏幕分辨率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* FBO render to texture */</span></span><br><span class="line">.....</span><br><span class="line"><span class="comment">/* FBO viewPort */</span></span><br><span class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, mWidth, mHeight);</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">glDrawArrays(GL_TRIANGLE_FAN, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* copy texture */</span></span><br><span class="line">glBindFramebuffer(GL_READ_FRAMEBUFFER, FBO);</span><br><span class="line">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, mScrnFBO);</span><br><span class="line">glBlitFramebuffer(<span class="number">0</span>, <span class="number">0</span>, mWidth, mHeight, <span class="number">0</span>, <span class="number">0</span>, mScrnWidth, mScrnHeight, GL_COLOR_BUFFER_BIT, GL_LINEAR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* render to screen */</span></span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Screen viewPort */</span></span><br><span class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, mScrnWidth, mScrnHeight);</span><br><span class="line">glUseProgram(mScrnProgram);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, mScrnTexture);</span><br><span class="line">glDrawArrays(GL_TRIANGLE_FAN, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">eglSwapBuffers(mEglDisplay, mEglSurface);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题由来&quot;&gt;&lt;a href=&quot;#问题由来&quot; class=&quot;headerlink&quot; title=&quot;问题由来&quot;&gt;&lt;/a&gt;问题由来&lt;/h1&gt;&lt;p&gt;在之前的测试中可以使用FBO的MRT方式，一次可以输出多张纹理。但这种方法存在一点缺陷，即经过FBO渲染的纹理无法自动适配屏</summary>
      
    
    
    
    <category term="OpenGL" scheme="http://example.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://example.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Linux自动挂载U盘</title>
    <link href="http://example.com/2025/07/25/ubuntu/Linux%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDU%E7%9B%98/"/>
    <id>http://example.com/2025/07/25/ubuntu/Linux%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDU%E7%9B%98/</id>
    <published>2025-07-25T03:18:07.000Z</published>
    <updated>2025-07-25T03:25:49.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>使用udiskie 可以自动将U盘挂载到&#x2F;media&#x2F;${USER}目录下，使用方法也很简单，就是在用户的.xinitrc启动脚本下开启后台即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udiskie &amp; </span><br></pre></td></tr></table></figure><h1 id="瑕疵"><a href="#瑕疵" class="headerlink" title="瑕疵"></a>瑕疵</h1><p>无法指定挂载目录，暂时找不到修改U盘挂载点的方法。<br>尤其是将系统做成只读文件系统，在这种情况下&#x2F;media也是只读，无法挂载。<br>解决方法是单独划分一个小分区，让&#x2F;media单独挂载到这个小分区上。 这样根文件系统是只读的情况下，不影响U盘的挂载。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h1&gt;&lt;p&gt;使用udiskie 可以自动将U盘挂载到&amp;#x2F;media&amp;#x2F;${USER}目录下，使用方法也很简单，就是在用户的.xinitr</summary>
      
    
    
    
    <category term="ubuntu系统" scheme="http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="ubuntu系统" scheme="http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>openGL使用QT和openCV加载图片和文字</title>
    <link href="http://example.com/2025/07/18/OpenGl/openGL%E4%BD%BF%E7%94%A8QT%E5%92%8CopenCV%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E5%92%8C%E6%96%87%E5%AD%97/"/>
    <id>http://example.com/2025/07/18/OpenGl/openGL%E4%BD%BF%E7%94%A8QT%E5%92%8CopenCV%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E5%92%8C%E6%96%87%E5%AD%97/</id>
    <published>2025-07-18T02:46:58.000Z</published>
    <updated>2025-07-18T03:01:34.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>openGL渲染避免不了需要加载本地图片或者自定义文字作为OSD渲染信息。如果是使用Qt封装的openGL可以直接QOpenGLTexture使用setData把一个QImage加载进去。但如果使用的openGL或者EGL原生API，那么就要使用glTexImage去更新纹理。<br>可惜openGL并没有提供加载图片的相关接口，需要依赖于stb_image等第三方库。由于项目都是在QT环境下开发的，可以直接使用QImage作为glTexImage的参数，较少第三方库的依赖。</p><h1 id="二、加载图片"><a href="#二、加载图片" class="headerlink" title="二、加载图片"></a>二、加载图片</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QImage <span class="title">img</span><span class="params">(<span class="string">&quot;:/images/mytexture.png&quot;</span>)</span></span>;</span><br><span class="line">img.<span class="built_in">convertToFormat</span>(QImage::Format_RGBA8888);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, img.<span class="built_in">width</span>(), img.<span class="built_in">height</span>(), <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, img.<span class="built_in">bits</span>());</span><br></pre></td></tr></table></figure><h1 id="三、加载文字"><a href="#三、加载文字" class="headerlink" title="三、加载文字"></a>三、加载文字</h1><p>文字的渲染需要依赖于FreeType2，编译openCV的时候可以加入相关的选项。<br>先将文字取模到cv::mat, 然后cvMat转换成QIMAGE, 再更新。  其实应该也可以不用转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Size <span class="title">cvTxtSize</span><span class="params">(txtW, txtH)</span></span>;</span><br><span class="line">cv::Mat textMat = cv::Mat::<span class="built_in">zeros</span>(cvTxtSize, CV_8UC4);</span><br><span class="line">textMat.<span class="built_in">setTo</span>(cv::Scalar::<span class="built_in">all</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">cv::Ptr&lt;cv::freetype::FreeType2&gt; mFt2;</span><br><span class="line"><span class="comment">//init mFt2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> line = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> txt : txtList) &#123;</span><br><span class="line">    mFt2-&gt;<span class="built_in">putText</span>(textMat, txt.<span class="built_in">toStdString</span>(), cv::<span class="built_in">Point</span>(<span class="number">0</span>, (fontSize+<span class="number">5</span>) * line), fontSize,</span><br><span class="line">            cv::<span class="built_in">Scalar</span>(textOsd.r, textOsd.g, textOsd.b, textOsd.a), <span class="number">-1</span>, cv::LINE_AA, <span class="literal">true</span>);</span><br><span class="line">    line += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QImage <span class="title">txtImg</span><span class="params">((<span class="type">const</span> uchar*)textMat.data, textMat.cols,</span></span></span><br><span class="line"><span class="params"><span class="function">              textMat.rows, textMat.step, QImage::Format_RGBA8888)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, txtImg.<span class="built_in">width</span>(), txtImg.<span class="built_in">height</span>(), <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, txtImg.<span class="built_in">bits</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;openGL渲染避免不了需要加载本地图片或者自定义文字作为OSD渲染信息。如果是使用Qt封装的openGL可以直接QOpen</summary>
      
    
    
    
    <category term="OpenGL" scheme="http://example.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://example.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>openGL获取原数据并转换</title>
    <link href="http://example.com/2025/07/13/OpenGl/openGL%E8%8E%B7%E5%8F%96%E5%9B%BE%E5%83%8F%E5%8E%9F%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>http://example.com/2025/07/13/OpenGl/openGL%E8%8E%B7%E5%8F%96%E5%9B%BE%E5%83%8F%E5%8E%9F%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%BD%AC%E6%8D%A2/</id>
    <published>2025-07-13T07:56:18.000Z</published>
    <updated>2025-07-23T02:14:36.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、问题来源"><a href="#一、问题来源" class="headerlink" title="一、问题来源"></a>一、问题来源</h1><p>为了在多个进程间共享图像数据，之前项目中的做法是创建共享cuda内存指针，不过要进行两次D2D的拷贝，A –&gt; Shm –&gt; B；并且<br>多一个进程就要多两次拷贝，更要命的是还有一些PIP数据的输入，需要共享出去，拷贝的次数更多。当然，使用FBO可以解决PIP这些额外数据的拷贝，<br>即由FBO渲染后，直接将渲染结果拷贝给对方。但是多一个进程就多两次拷贝的本质不变，性能得不到改善。</p><h1 id="二、解决"><a href="#二、解决" class="headerlink" title="二、解决"></a>二、解决</h1><p>在之前的探究中，EGL可以将一个Texture转换成EGLImage,并且可以将这个EGLImage的基本属性共享出去，另一个进程只需要获取一次这些基本数据，就能再转换成EGLimage, 并且这个纹理内容是实时被共享方更新的。这样就避免了两个进程间的任何拷贝，A直接更新，B直接渲染。<br>值得说明的是，A可以将这个纹理与cudaArray进行互操作绑定，可以直接在kernel中就更新这个纹理。</p><h1 id="三、缺陷"><a href="#三、缺陷" class="headerlink" title="三、缺陷"></a>三、缺陷</h1><p>上述步骤只支持一些常见的数据格式，例如RGBA8，但是不支持RGB10A2。为了获得更细腻的视觉体验，10bit图像渲染必不可少。<br>有一个思路是，创建的时候按照RGBA8格式去创建纹理，并且共享出去，但在cuda内核中实际按照将RGB的高2位依次写入Alpha通道，<br>然后再GLSL的fragment着色器中将它还原成10bit数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">gRGB10A2ToRGBA</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *pSrc, cudaSurfaceObject_t dstSurfObj, <span class="type">int</span> iWidth, <span class="type">int</span> iHeight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dx = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dy = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class="line">    <span class="keyword">if</span> (dx &gt;= iWidth || dy &gt;= iHeight) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idxSrc = dy * iWidth + dx;</span><br><span class="line">    uchar4 pixel;</span><br><span class="line"></span><br><span class="line">    uint v = pSrc[idxSrc];</span><br><span class="line"></span><br><span class="line">    uint R = (v &gt;&gt; <span class="number">2</span>) &amp; <span class="number">1023</span>;</span><br><span class="line">    uint G = (v &gt;&gt; <span class="number">12</span>) &amp; <span class="number">1023</span>;</span><br><span class="line">    uint B = (v &gt;&gt; <span class="number">22</span>) &amp; <span class="number">1023</span>;</span><br><span class="line"></span><br><span class="line">    uint L8R = R &amp; <span class="number">255</span>;</span><br><span class="line">    uint L8G = G &amp; <span class="number">255</span>;</span><br><span class="line">    uint L8B = B &amp; <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    uint H2R = (R &gt;&gt; <span class="number">8</span>) &amp; <span class="number">3</span>;</span><br><span class="line">    uint H2G = (G &gt;&gt; <span class="number">8</span>) &amp; <span class="number">3</span>;</span><br><span class="line">    uint H2B = (B &gt;&gt; <span class="number">8</span>) &amp; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    pixel.x = L8R;</span><br><span class="line">    pixel.y = L8G;</span><br><span class="line">    pixel.z = L8B;</span><br><span class="line">    pixel.w = ((H2R &lt;&lt; <span class="number">4</span>) | (H2G &lt;&lt; <span class="number">2</span>) | H2B);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">surf2Dwrite</span>(pixel, dstSurfObj, dx * <span class="number">4</span>, dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RGB10A2ToRGBA</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *pSrc, cudaSurfaceObject_t dstSurfObj, <span class="type">int</span> iWidth, <span class="type">int</span> iHeight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">dim3 <span class="title">numThreads</span><span class="params">(NUM_THREAD_X, NUM_THREAD_Y, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">dim3 <span class="title">numBlocks</span><span class="params">(DivUp(iWidth, numThreads.x), DivUp(iHeight, numThreads.y))</span></span>;</span><br><span class="line">    gRGB10A2ToRGBA&lt;&lt;&lt;numBlocks, numThreads&gt;&gt;&gt;(pSrc, dstSurfObj, iWidth, iHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GLSL的Fragment着色器中还原成10bit，<br>需要说明的是，texture要定义成int类型的isampler2D，<br>并且不能通过之前的 texture2D(tex_y, TexCoord)来获取像素值，<br>因为这是经过重采样归一化后的值，无法精确获取原像素值。<br>需要 texelFetch获取当前pos的像素值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out ivec4 FragColor;</span><br><span class="line">in vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">uniform isampler2D ourTexture;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ivec2 pos = <span class="built_in">ivec2</span>(<span class="built_in">int</span>(TexCoord.x * <span class="number">800</span>), <span class="built_in">int</span>(TexCoord.y * <span class="number">480</span>));</span><br><span class="line"></span><br><span class="line">    ivec4 color = <span class="built_in">texelFetch</span>(ourTexture, pos, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r = (((color.w &gt;&gt; <span class="number">4</span>) &amp; <span class="number">3</span>) &lt;&lt; <span class="number">8</span>) | color.x;</span><br><span class="line">    <span class="type">int</span> g = (((color.w &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>) &lt;&lt; <span class="number">8</span>) | color.y;</span><br><span class="line">    <span class="type">int</span> b = ((color.w  &amp; <span class="number">3</span>) &lt;&lt; <span class="number">8</span>) | color.z;</span><br><span class="line"></span><br><span class="line">    FragColor = <span class="built_in">ivec4</span>(r, g, b, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、问题来源&quot;&gt;&lt;a href=&quot;#一、问题来源&quot; class=&quot;headerlink&quot; title=&quot;一、问题来源&quot;&gt;&lt;/a&gt;一、问题来源&lt;/h1&gt;&lt;p&gt;为了在多个进程间共享图像数据，之前项目中的做法是创建共享cuda内存指针，不过要进行两次D2D的拷贝，A –</summary>
      
    
    
    
    <category term="OpenGL" scheme="http://example.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://example.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>openGL回读字节类型不同导致的性能问题</title>
    <link href="http://example.com/2025/07/04/OpenGl/openGL%E5%9B%9E%E8%AF%BB%E5%AD%97%E8%8A%82%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2025/07/04/OpenGl/openGL%E5%9B%9E%E8%AF%BB%E5%AD%97%E8%8A%82%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</id>
    <published>2025-07-04T01:49:48.000Z</published>
    <updated>2025-07-17T09:19:13.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><p>前提：Xorg.conf中将X窗口配置成depth&#x3D;10。<br>然后使用cuda-OGL互操作方式，将OGL渲染结果回读到PBO。<br>最开始设置的字节是GL_UNSIGNED_INT_2_10_10_10_REV，性能没问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_PIXEL_PACK_BUFFER, mPboId);</span><br><span class="line">glReadPixels(<span class="number">0</span>, <span class="number">0</span>, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_INT_2_10_10_10_REV, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>后面由于更改需求，需要动态缩放openGL渲染结果，并且为了和其他部分代码统一，考虑使用nppiResize.<br>为了减少改动，直接将回读方式改为GL_UNSIGNED_BYTE, 事实上也得到正确的渲染结果。<br>但是测试后发现这样回导致openGL渲染线程的cpu占用率剧增，甚至导致严重掉帧。初步怀疑openGL内部做了某些字节类型的转换，但还未进一步排查。</p><p>经过测试发现，GL_UNSIGNED_INT_2_10_10_10_REV格式的渲染结果和gstreamer中的RGB10A2_LE格式一致。<br>也就是只需要将gstreamer中的appsrc caps设置为”video&#x2F;x-raw(memory:CUDAMemory),format&#x3D;RGB10A2_LE”，<br>就可以直接录制通过GL_UNSIGNED_INT_2_10_10_10_REV抓取到的渲染结果。</p><p>但是好巧不巧，只有nvh265enc支持RGB10A2_LE，nvh264enc不支持，项目上需要支持h264。</p><p>基于上述原因，考虑到nppiResize 和 nvh264enc都不支持RGB10A2，为了代码的统一，只能考虑使用cuda将RGB10A2_LE<br>转为RGBA, 接着nppiResize后再录制。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>之前一直没搞懂GL_UNSIGNED_INT_2_10_10_10_REV后缀REV代表什么意思，直到它和gstreamer中的RGB10A2_LE格式一致，才有了思路。<br>小端格式是RGB10A2LE，实际内存分布为：32bit地址中，低10为为R,高2为Alpha   (A)2_(B)10_(G)10_(R)10</p><p>根据这个思路，不难写出GL_UNSIGNED_INT_2_10_10_10_REV方式抓取的OGL渲染结果转换成RGBA8的cuda代码：<br>需要注意的是，10Bit 转换成8 Bit 不是直接将Bit &amp; 255，取低8位，这样会导致颜色变浅。<br>正确做法应该是先右移2位，再与， (10Bit &gt;&gt; 2) &amp; 255， 因此下面是省略了一步，正确理解应该是<br>RGB三个通道依次先右移 0位、10位、20位，得到R10、G10、B10, 接着三个通道再各自右移2位，得到RGBA8.<br>结合起来就是依次右移 2位、12位、22位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">cuVerticalFlip_RGB10A2_To_RGBA8</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *pSrc, <span class="type">unsigned</span> <span class="type">char</span> *pDst, <span class="type">int</span> iWidth, <span class="type">int</span> iHeight, <span class="type">int</span> iSrcStride, <span class="type">int</span> iDstStride)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dx = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dy = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class="line">    <span class="keyword">if</span> (dx &gt;= iWidth || dy &gt;= iHeight) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idxSrc = dy * iSrcStride + dx;</span><br><span class="line">    <span class="type">int</span> idxDst = (iHeight - dy - <span class="number">1</span>) * iDstStride + dx * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    uint v = pSrc[idxSrc];</span><br><span class="line">    pDst[idxDst]     = ((v &gt;&gt; <span class="number">2</span>)) &amp; <span class="number">255</span>;</span><br><span class="line">    pDst[idxDst + <span class="number">1</span>] = ((v &gt;&gt; <span class="number">12</span>)) &amp; <span class="number">255</span>;</span><br><span class="line">    pDst[idxDst + <span class="number">2</span>] = ((v &gt;&gt; <span class="number">22</span>)) &amp; <span class="number">255</span>;</span><br><span class="line">    pDst[idxDst + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">verticalFlip_RGB10A2_To_RGBA8</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *pSrc, <span class="type">unsigned</span> <span class="type">char</span> *pDst, <span class="type">int</span> iWidth, <span class="type">int</span> iHeight, <span class="type">int</span> iSrcStride, <span class="type">int</span> iDstStride)</span></span><br><span class="line">&#123;</span><br><span class="line">    dim3 <span class="title function_">numThreads</span><span class="params">(NUM_THREAD_X, NUM_THREAD_Y, <span class="number">1</span>)</span>;</span><br><span class="line">    dim3 <span class="title function_">numBlocks</span><span class="params">(DivUp(iWidth, numThreads.x), DivUp(iHeight, numThreads.y))</span>;</span><br><span class="line">    cuVerticalFlip_RGB10A2_To_RGBA8&lt;&lt;&lt;numBlocks, numThreads&gt;&gt;&gt;(pSrc, pDst, iWidth, iHeight, iSrcStride, iDstStride);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="后续补充"><a href="#后续补充" class="headerlink" title="后续补充"></a>后续补充</h1><p>经过测试发现，xorg不同的深度配置需要以不同的字节类型去读取OGL渲染结果。<br>10bit： GL_UNSIGNED_INT_2_10_10_10_REV<br>8bit: GL_UNSIGNED_BYTE 或者 GL_UNSIGNED_INT_8_8_8_8_REV， 他俩等价，并且读出都是正常的RGBA</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题来源&quot;&gt;&lt;a href=&quot;#问题来源&quot; class=&quot;headerlink&quot; title=&quot;问题来源&quot;&gt;&lt;/a&gt;问题来源&lt;/h1&gt;&lt;p&gt;前提：Xorg.conf中将X窗口配置成depth&amp;#x3D;10。&lt;br&gt;然后使用cuda-OGL互操作方式，将OGL渲染</summary>
      
    
    
    
    <category term="OpenGL" scheme="http://example.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://example.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Linux批量处理动态链接库脚本</title>
    <link href="http://example.com/2025/06/23/ubuntu/Linux%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E8%84%9A%E6%9C%AC/"/>
    <id>http://example.com/2025/06/23/ubuntu/Linux%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E8%84%9A%E6%9C%AC/</id>
    <published>2025-06-23T07:40:34.000Z</published>
    <updated>2025-06-23T07:46:46.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>加入一个新的功能需要依赖编译出的第三方库，对于在外已售的设备不方便直接升级母盘。因此想着直接将动态链接库放到 编辑及安装脚本中。根据实际情况调整路径即可。</p><p>对于 libdcmdata.so.19.3.6.9<br>其major链接文件名为 libdcmdata.so.19，主要是在程序运行的时候链接<br>其plain链接文件名为 libdcmdata.so，主要是编译程序的时候使用。</p><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$#</span> -ne 1 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;usage: <span class="variable">$0</span> [major|plain]&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">OTS_PATH=.</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$OTS_PATH</span>/dcmtkDeps/lib</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> lib*.so.*.*.*.*; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$file</span> =~ ^(lib.*\.so)\.([0-9]+)\..* ]]; <span class="keyword">then</span></span><br><span class="line">        libname=<span class="string">&quot;<span class="variable">$&#123;BASH_REMATCH[1]&#125;</span>&quot;</span></span><br><span class="line">        major=<span class="string">&quot;<span class="variable">$&#123;BASH_REMATCH[2]&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">if</span> [[ <span class="variable">$1</span> == <span class="string">&quot;major&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">            linkname=<span class="string">&quot;<span class="variable">$&#123;OTS_PATH&#125;</span>/<span class="variable">$&#123;libname&#125;</span>.<span class="variable">$&#123;major&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> [[ <span class="variable">$1</span> == <span class="string">&quot;plain&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">            linkname=<span class="string">&quot;<span class="variable">$&#123;libname&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;error: unknown param&quot;</span></span><br><span class="line">            <span class="built_in">exit</span> 2</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        <span class="built_in">ln</span> -sf <span class="string">&quot;<span class="variable">$file</span>&quot;</span> <span class="string">&quot;<span class="variable">$linkname</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;ln -sf <span class="variable">$file</span> <span class="variable">$linkname</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;加入一个新的功能需要依赖编译出的第三方库，对于在外已售的设备不方便直接升级母盘。因此想着直接将动态链接库放到 编辑及安装脚本中。根据实际情况</summary>
      
    
    
    
    <category term="ubuntu系统" scheme="http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="ubuntu系统" scheme="http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>gstreamer使用USB麦克风录制踩坑</title>
    <link href="http://example.com/2025/06/23/gstreamer/gstreamer%E4%BD%BF%E7%94%A8USB%E9%BA%A6%E5%85%8B%E9%A3%8E%E5%BD%95%E5%88%B6%E8%B8%A9%E5%9D%91/"/>
    <id>http://example.com/2025/06/23/gstreamer/gstreamer%E4%BD%BF%E7%94%A8USB%E9%BA%A6%E5%85%8B%E9%A3%8E%E5%BD%95%E5%88%B6%E8%B8%A9%E5%9D%91/</id>
    <published>2025-06-23T07:19:01.000Z</published>
    <updated>2025-06-23T07:39:31.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h1><p>项目中使用USB麦克风录制包含音频的MP4视频文件，一开始测试视频没啥问题。后面换了另一款型号的USB麦克风，发现录制视频失败。debug过程没发现明显的问题，甚至每个音频的gstBuf包都发送成功。<br>最后进一步研究才解决了问题。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>最开始的pipeline是这么写的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alsasrc device=hw:2,0 ! audioconvert ! audio/x-raw,format=S16LE,rate=44100,channels=2,layout=interleaved ! appsink emit-signals=<span class="literal">true</span> name=appsink  </span><br></pre></td></tr></table></figure><p>原以为不管USB麦克风支持哪种采样率，audioconvert会自动根据后面指定的rate参数进行转化，但实际上并没有。<br>哪怕 appsink也会有gstBuf输出。</p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>使用下面的指令dump最初USB麦克风的参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arecord -D hw:2,0 --dump-hw-params</span><br></pre></td></tr></table></figure><p>输出如下，可以看到RATE支持 44100 和 48000</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ACCESS:  MMAP_INTERLEAVED RW_INTERLEAVED</span><br><span class="line">FORMAT:  S16_LE</span><br><span class="line">SUBFORMAT:  STD</span><br><span class="line">SAMPLE_BITS: 16</span><br><span class="line">FRAME_BITS: 16</span><br><span class="line">CHANNELS: 1</span><br><span class="line">RATE: [44100 48000]</span><br><span class="line">PERIOD_TIME: [1000 1000000]</span><br><span class="line">PERIOD_SIZE: [45 48000]</span><br><span class="line">PERIOD_BYTES: [90 96000]</span><br><span class="line">PERIODS: [2 1024]</span><br><span class="line">BUFFER_TIME: [1875 2000000]</span><br><span class="line">BUFFER_SIZE: [90 96000]</span><br><span class="line">BUFFER_BYTES: [180 192000]</span><br><span class="line">TICK_TIME: ALL</span><br></pre></td></tr></table></figure><p>接入另一款型号的麦克风继续查询，发现输出的RATE只有48000，这就与pipeline中指定的44100冲突。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RATE: 48000</span><br></pre></td></tr></table></figure><p>因此只要查询支持的分辨率即可，代码见附件信息。<br>另外，caps 采样率的最后一个channels&#x3D;2,layout&#x3D;interleaved，不要去掉，否则也会录制失败。<br>虽然channel与实际的查询到的不相符，但不影响。</p><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">QProcess process;</span><br><span class="line">QString cmd = <span class="string">&quot;arecord -D hw:2,0 --dump-hw-params&quot;</span>;</span><br><span class="line">process.<span class="built_in">start</span>(<span class="string">&quot;sh&quot;</span>, <span class="built_in">QStringList</span>() &lt;&lt; <span class="string">&quot;-c&quot;</span> &lt;&lt; cmd);</span><br><span class="line">process.<span class="built_in">waitForFinished</span>();</span><br><span class="line">QString res = process.<span class="built_in">readAllStandardError</span>();</span><br><span class="line">QStringList list = res.<span class="built_in">split</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> param : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (param.<span class="built_in">contains</span>(<span class="string">&quot;RATE&quot;</span>)) &#123;</span><br><span class="line">        param.<span class="built_in">replace</span>(<span class="string">&quot;RATE: &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        param.<span class="built_in">replace</span>(<span class="string">&quot;[&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        param.<span class="built_in">replace</span>(<span class="string">&quot;]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; param.<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>).<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题由来&quot;&gt;&lt;a href=&quot;#问题由来&quot; class=&quot;headerlink&quot; title=&quot;问题由来&quot;&gt;&lt;/a&gt;问题由来&lt;/h1&gt;&lt;p&gt;项目中使用USB麦克风录制包含音频的MP4视频文件，一开始测试视频没啥问题。后面换了另一款型号的USB麦克风，发现录制视频失</summary>
      
    
    
    
    <category term="gstreamer" scheme="http://example.com/categories/gstreamer/"/>
    
    
    <category term="gstreamer" scheme="http://example.com/tags/gstreamer/"/>
    
  </entry>
  
  <entry>
    <title>dicom文件插入私有Tag</title>
    <link href="http://example.com/2025/06/20/dicom/dicom%E6%96%87%E4%BB%B6%E6%8F%92%E5%85%A5%E7%A7%81%E6%9C%89Tag/"/>
    <id>http://example.com/2025/06/20/dicom/dicom%E6%96%87%E4%BB%B6%E6%8F%92%E5%85%A5%E7%A7%81%E6%9C%89Tag/</id>
    <published>2025-06-20T05:39:47.000Z</published>
    <updated>2025-06-20T06:46:17.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><pre><code>dicom有两种类型的tag，一种是dicom自有的tag, 保存在偶数组号中；另一种是自定义的tag，保存在奇数组号中。</code></pre><h2 id="私有数据元素"><a href="#私有数据元素" class="headerlink" title="私有数据元素"></a>私有数据元素</h2><p>实现时可能需要不包含在标准数据元素中的信息通讯。私有数据元素需要包含这些信息。</p><p>　　私有数据元素与指定在7.1部分（即，数据元素标签字段，可选VR字段，长度字段和值字段）中的标准数据元素有相同的结构。使用在私有数据元素的元素标签中的组号码应该是一个奇数号码。私有数据元素应以数据元素标签的递增数字顺序包含在数据集中。私有数据元素的值字段应具有标准6.2部分中指定的VRs中的任意一种。</p><p>　　对于每一个信息对象定义或SOP类定义，按照说明在DICOM标准的第3部分和第4部分中的内容，特定数据元素是必需的。私有数据元素不能代替所需的标准数据元素。</p><h2 id="私有数据元素标签"><a href="#私有数据元素标签" class="headerlink" title="私有数据元素标签"></a>私有数据元素标签</h2><p>多个实现者定义带有相同（奇数）组号码的情况是可能的。为了避免冲突，私有元素将根据下面的规则来分配私有数据元素标签。</p><p>　　1)     编号为（gggg,0010-00FF）（gggg为奇数）的私有创作者数据元素用来存储由私人使用的组号码为gggg的一组元素。系统将给这一系列私有元素中的第一个未使用的（未赋值的）元素插入标识码。私有标识码的VR将成为LO,VM将等于1。</p><p>　　2)     私有创作者数据元素（gggg,0010）是等同于系统存储元素（gggg,1000-10FF）的1类数据元素，私有创作者数据元素（gggg,0011）等同于系统存储元素（gggg,1100-11FF），以此类推，直到私有创作者数据元素（gggg,00FF）等同于系统存储元素　　（gggg,FF00-FFFF）。</p><p>　　3)     私有数据元素的编码器能够动态地将私有数据分配到私有组中的任一可利用块中，并详细说明分配所对应的私有创作者数据元素。私有数据的译码器能够由对应的私有创作者数据元素在私有组中的任何位置使用给定的私有创作者标识码识别存储块。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dcmtk/config/osconfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dcmtk/dcmdata/dctk.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIVATE_CREATOR_NAME <span class="string">&quot;Stephen&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIVATE_CREATOR_TAG  0x0029, 0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIVATE_ELEMENT1_TAG 0x0029, 0x0011</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIVATE_ELEMENT2_TAG 0x0029, 0x0012</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIVATE_ELEMENT3_TAG 0x0029, 0x0013</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIVATE_ELEMENT4_TAG 0x0029, 0x0014</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRV_PrivateCreator   DcmTag(PRIVATE_CREATOR_TAG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRV_PrivateElement1  DcmTag(PRIVATE_ELEMENT1_TAG, PRIVATE_CREATOR_NAME)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRV_PrivateElement2  DcmTag(PRIVATE_ELEMENT2_TAG, PRIVATE_CREATOR_NAME)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRV_PrivateElement3  DcmTag(PRIVATE_ELEMENT3_TAG, PRIVATE_CREATOR_NAME)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRV_PrivateElement4  DcmTag(PRIVATE_ELEMENT4_TAG, PRIVATE_CREATOR_NAME)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">registerPrivateTags</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DcmDataDictionary &amp;dict = dcmDataDict.wrlock();</span><br><span class="line">    dict.addEntry(new DcmDictEntry(PRIVATE_ELEMENT1_TAG, EVR_LO, <span class="string">&quot;PrivateText&quot;</span>,    <span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;private&quot;</span>, OFTrue, PRIVATE_CREATOR_NAME));</span><br><span class="line">    dict.addEntry(new DcmDictEntry(PRIVATE_ELEMENT2_TAG, EVR_US, <span class="string">&quot;PrivateInteger&quot;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;private&quot;</span>, OFTrue, PRIVATE_CREATOR_NAME));</span><br><span class="line">    dict.addEntry(new DcmDictEntry(PRIVATE_ELEMENT3_TAG, EVR_OB, <span class="string">&quot;PrivateBlob&quot;</span>,    <span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;private&quot;</span>, OFTrue, PRIVATE_CREATOR_NAME));</span><br><span class="line">    dict.addEntry(new DcmDictEntry(PRIVATE_ELEMENT4_TAG, EVR_US, <span class="string">&quot;PrivateInteger&quot;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;private&quot;</span>, OFTrue, PRIVATE_CREATOR_NAME));</span><br><span class="line"></span><br><span class="line">    dcmDataDict.wrunlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addPrivateElements</span><span class="params">(DcmItem &amp;item)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!item.tagExists(PRV_PrivateCreator)) &#123;</span><br><span class="line">        item.putAndInsertString(PRV_PrivateCreator, PRIVATE_CREATOR_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!item.tagExists(PRV_PrivateElement1)) &#123;</span><br><span class="line">        item.putAndInsertString(PRV_PrivateElement1, <span class="string">&quot;Some Text&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!item.tagExists(PRV_PrivateElement2)) &#123;</span><br><span class="line">        item.putAndInsertUint16(PRV_PrivateElement2, <span class="number">12345</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!item.tagExists(PRV_PrivateElement3)) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> data[] = &#123;<span class="string">&quot;9527&quot;</span>&#125;;</span><br><span class="line">        item.putAndInsertUint8Array(PRV_PrivateElement3, data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!item.tagExists(PRV_PrivateElement4)) &#123;</span><br><span class="line">        item.putAndInsertUint16(PRV_PrivateElement4, <span class="number">1306</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DcmFileFormat fileformat;</span><br><span class="line">    registerPrivateTags();</span><br><span class="line">    addPrivateElements(*fileformat.getDataset());</span><br><span class="line">    fileformat.saveFile(<span class="string">&quot;test_out.dcm&quot;</span>, EXS_LittleEndianExplicit);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成的dcm文件dump信息如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(0029,0010) LO [Stephen]                                <span class="comment">#   8, 1 PrivateCreator</span></span><br><span class="line">(0029,0011) LO [Some Text]                              <span class="comment">#  10, 1 PrivateCreator</span></span><br><span class="line">(0029,0012) US 12345                                    <span class="comment">#   2, 1 PrivateCreator</span></span><br><span class="line">(0029,0013) OB 39\35\32\37\00\00                        <span class="comment">#   6, 1 PrivateCreator</span></span><br><span class="line">(0029,0014) US 1306                                     <span class="comment">#   2, 1 PrivateCreator</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>url:  <a href="https://www.cnblogs.com/0523jy/p/9338142.html">https://www.cnblogs.com/0523jy/p/9338142.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;dicom有两种类型的tag，一种是dicom自有的tag, 保存在偶数组号中；
另一种是自定义的tag，保存在奇数组号中。</summary>
      
    
    
    
    <category term="dicom" scheme="http://example.com/categories/dicom/"/>
    
    
    <category term="dicom" scheme="http://example.com/tags/dicom/"/>
    
  </entry>
  
  <entry>
    <title>dicom保存h264及h265mp4视频文件</title>
    <link href="http://example.com/2025/06/20/dicom/dicom%E4%BF%9D%E5%AD%98h264%E5%8F%8Ah265mp4%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2025/06/20/dicom/dicom%E4%BF%9D%E5%AD%98h264%E5%8F%8Ah265mp4%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6/</id>
    <published>2025-06-20T03:05:09.000Z</published>
    <updated>2025-08-20T06:03:55.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="h264编码方式的mp4"><a href="#h264编码方式的mp4" class="headerlink" title="h264编码方式的mp4"></a>h264编码方式的mp4</h1><p>h264只支持 high profile的mp4，因此需要注意mp4的profile，以gstreamer为例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gst-launch-1.0 videotestsrc ! video/x-raw,format=RGBA,width=1920,height=1080,framerate=30/1 ! nvh264enc ! h264parse ! video/x-h264, profile=high ! mp4mux ! filesink location=1080p264Hight.mp4 -e</span><br></pre></td></tr></table></figure><p>主要是以下几个接口要指定264</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataset-&gt;putAndInsertOFStringArray(DCM_TransferSyntaxUID, UID_MPEG4HighProfileLevel4_1TransferSyntax);</span><br><span class="line"></span><br><span class="line">pixelData-&gt;putOriginalRepresentation(EXS_MPEG4HighProfileLevel4_1, nullptr, pixelSequence);</span><br><span class="line"></span><br><span class="line">OFCondition status = fileformat.saveFile(<span class="string">&quot;videoTest.dcm&quot;</span>, EXS_MPEG4HighProfileLevel4_1);</span><br></pre></td></tr></table></figure><h1 id="h265编码方式的mp4"><a href="#h265编码方式的mp4" class="headerlink" title="h265编码方式的mp4"></a>h265编码方式的mp4</h1><p>错误的尝试：<br>将上述接口分别改为对应h265的选项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset-&gt;putAndInsertOFStringArray(DCM_TransferSyntaxUID, UID_HEVCMainProfileLevel5_1TransferSyntax);</span><br><span class="line">pixelData-&gt;putOriginalRepresentation(EXS_HEVCMainProfileLevel5_1, nullptr, pixelSequence);</span><br><span class="line">OFCondition status = fileformat.saveFile(<span class="string">&quot;videoTest.dcm&quot;</span>, EXS_HEVCMainProfileLevel5_1);</span><br></pre></td></tr></table></figure><p>感觉应该没啥问题，但是生成的dcm文件只有1kb，也就是只有tag，没有视频信息。</p><p>但是，如果保持h264的参数配置，只是将视频文件从264换成265，即把265视频当成264处理，生成的dcm文件竟然没问题。<br>而且使用第三方工具打开这个dcm文件，可以看到265视频，将该视频导出，格式也是h265。</p><p>暂时还不知道dicom内部是怎么处理的，有点神奇。 那么UID_HEVCMainProfileLevel5_1TransferSyntax的意义在哪？</p><h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><p>dicom有个非常坑，非常隐蔽的问题，在测试将视频写入到dicom的时候，使用下面函数设置mp4文件的大小，但如果size是奇数的时候，生成的dcm文件失败，偶数则没问题。<br>因此如果size为奇数，必须向下取偶数，即只能-1，不能向上+1，生成的dcm文件才成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Uint32 size = file.size() / <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">frame-&gt;createValueFromTempFile(dcmFileStream.newFactory(), size, EBO_LittleEndian);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;h264编码方式的mp4&quot;&gt;&lt;a href=&quot;#h264编码方式的mp4&quot; class=&quot;headerlink&quot; title=&quot;h264编码方式的mp4&quot;&gt;&lt;/a&gt;h264编码方式的mp4&lt;/h1&gt;&lt;p&gt;h264只支持 high profile的mp4，因此需要注</summary>
      
    
    
    
    <category term="dicom" scheme="http://example.com/categories/dicom/"/>
    
    
    <category term="dicom" scheme="http://example.com/tags/dicom/"/>
    
  </entry>
  
  <entry>
    <title>cmake编译dicom</title>
    <link href="http://example.com/2025/06/17/dicom/cmake%E7%BC%96%E8%AF%91dicom/"/>
    <id>http://example.com/2025/06/17/dicom/cmake%E7%BC%96%E8%AF%91dicom/</id>
    <published>2025-06-17T07:22:41.000Z</published>
    <updated>2025-06-20T03:08:27.424Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/usr/local/dcmtk -DBUILD_SHARED_LIBS=ON .. </span><br><span class="line">make -j16</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="dicom" scheme="http://example.com/categories/dicom/"/>
    
    
    <category term="dicom" scheme="http://example.com/tags/dicom/"/>
    
  </entry>
  
  <entry>
    <title>生成dicom文件时需要的tag</title>
    <link href="http://example.com/2025/06/17/dicom/%E7%94%9F%E6%88%90dicom%E6%96%87%E4%BB%B6%E6%97%B6%E9%9C%80%E8%A6%81%E7%9A%84tag/"/>
    <id>http://example.com/2025/06/17/dicom/%E7%94%9F%E6%88%90dicom%E6%96%87%E4%BB%B6%E6%97%B6%E9%9C%80%E8%A6%81%E7%9A%84tag/</id>
    <published>2025-06-17T06:32:10.000Z</published>
    <updated>2025-06-20T03:08:43.873Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">可空 0x0008, 0x0020 DCM_StudyDate</span><br><span class="line">可空 0x0008, 0x0030 DCM_StudyTime</span><br><span class="line">可空 0x0008, 0x0050 DCM_AccessionNumber</span><br><span class="line">可空 0x0008, 0x0070 DCM_Manufacturer</span><br><span class="line">可空 0x0008, 0x0090 DCM_ReferringPhysiciansName</span><br><span class="line">可空 0x0020, 0x0010 DCM_StudyID</span><br><span class="line">可空 0x0008, 0x0023 DCM_ContentDate</span><br><span class="line">可空 0x0008, 0x0033 DCM_ContentTime</span><br><span class="line">可空 0x0008, 0x002a DCM_AcquisitionDatetime</span><br><span class="line">可空 0x0040, 0xa043 DCM_ConceptNameCodeSequence</span><br><span class="line"></span><br><span class="line">非空 0x0008, 0x0005 DCM_SpecificCharacterSet</span><br><span class="line">非空 0x0008, 0x0016 DCM_SOPClassUID</span><br><span class="line">非空 0x0008, 0x0060 DCM_Modality</span><br><span class="line">非空 0x0008, 0x0064 DCM_ConversionType</span><br><span class="line">非空 0x0042, 0x0012 DCM_MIMETypeOfEncapsulatedDocument</span><br><span class="line">非空 0x0020, 0x0011 DCM_SeriesNumber</span><br><span class="line">非空 0x0042, 0x0010 DCM_DocumentTitle</span><br><span class="line">非空 0x0010, 0x0010 DCM_PatientsName</span><br><span class="line">非空 0x0010, 0x0020 DCM_PatientID</span><br><span class="line">非空 0x0010, 0x0030 DCM_PatientsBirthDate</span><br><span class="line">非空 0x0010, 0x0040 DCM_PatientsSex</span><br><span class="line">非空 0x0028, 0x0301 DCM_BurnedInAnnotation</span><br><span class="line">非空 0x0020, 0x0013 DCM_InstanceNumber</span><br><span class="line">非空 0x0020, 0x000d DCM_StudyInstanceUID</span><br><span class="line">非空 0x0020, 0x000e DCM_SeriesInstanceUID</span><br><span class="line">非空 0x0008, 0x0018 DCM_SOPInstanceUID</span><br><span class="line">非空 0x0008, 0x0012 DCM_InstanceCreationDate</span><br><span class="line">非空 0x0008, 0x0013 DCM_InstanceCreationTime</span><br><span class="line"></span><br><span class="line">非空 0x0002, 0x0001 DCM_FileMetaInformationVersion</span><br><span class="line">非空 0x0002, 0x0002 DCM_MediaStorageSOPClassUID</span><br><span class="line">非空 0x0002, 0x0003 DCM_MediaStorageSOPInstanceUID</span><br><span class="line">非空 0x0002, 0x0010 DCM_TransferSyntaxUID</span><br><span class="line">非空 0x0002, 0x0012 DCM_ImplementationClassUID</span><br><span class="line">非空 0x0002, 0x0013 DCM_ImplementationVersionName</span><br><span class="line">非空 0x0028, 0x0004 DCM_PhotometricInterpretation</span><br><span class="line">非空 0x0028, 0x0002 DCM_SamplesPerPixel</span><br><span class="line">非空 0x0028, 0x0100 DCM_BitsAllocated</span><br><span class="line">非空 0x0028, 0x0101 DCM_BitsStored</span><br><span class="line">非空 0x0028, 0x0102 DCM_HighBit</span><br><span class="line">非空 0x0028, 0x0103 DCM_PixelRepresentation</span><br><span class="line">非空 0x0028, 0x0006 DCM_PlanarConfiguration</span><br><span class="line">非空 0x0028, 0x0010 DCM_Rows</span><br><span class="line">非空 0x0028, 0x0011 DCM_Columns</span><br><span class="line">非空 DCM_PixelData</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="dicom" scheme="http://example.com/categories/dicom/"/>
    
    
    <category term="dicom" scheme="http://example.com/tags/dicom/"/>
    
  </entry>
  
  <entry>
    <title>QWaitCondition严谨的使用方法</title>
    <link href="http://example.com/2025/05/19/Qt/QWaitCondition%E4%B8%A5%E8%B0%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2025/05/19/Qt/QWaitCondition%E4%B8%A5%E8%B0%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2025-05-19T07:11:27.000Z</published>
    <updated>2025-05-19T08:05:10.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近需要将QOpenGL的渲染改为EGL渲染，那么就无法使用Qt提供的条件执行函数update();<br>粗糙的实现方式是 EGL在 while (1)循环中先检测数据是否被更新的Flag, 被更新就渲染；没有就msleep一小会。<br>数据可能在msleep的过程中就已经被更新，导致无法及时被处理，即便是减小msleep的参数，也会造成系统频繁挂起与检测。 综合测试下来这是一种非常粗糙的实现方式。</p><p>下面是使用QWaitCondition 替代msleep的过程。</p><h1 id="有缺陷的用法"><a href="#有缺陷的用法" class="headerlink" title="有缺陷的用法"></a>有缺陷的用法</h1><p>渲染线程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//define QMutex and QWaitConditio</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    mutex.<span class="built_in">lock</span>();</span><br><span class="line">    condition.<span class="built_in">wait</span>(&amp;mutex); </span><br><span class="line">    <span class="built_in">render</span>();</span><br><span class="line">    mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据更新线程如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cudaMemCpy</span>(...);</span><br><span class="line"><span class="comment">/* 数据已更新，唤起渲染线程 */</span></span><br><span class="line">condition.<span class="built_in">wakeAll</span>();</span><br></pre></td></tr></table></figure><p>上述的QMutex并没有起到真正的作用，加锁和解锁在同一个while中没什么意义。考虑这种情况：<br>由于系统调度的原因，即 无法保证每次渲染线程中的condition.wait(&amp;mutex)都会优先于数据线程中的condition.wakeAll()。有一定概率下，wakeAll()会被先执行，那么渲染线程就会在那里等待，知道下一帧数据更新才会被唤起。<br>这种情况在渲染中倒也影响不大，最多就是不更新这一帧，不过也可能会出现视频轻微卡顿一下的情况。<br>但如果使用场景是一些连续通信数据包的处理，那就会出现中间丢包的情况，这就比较麻烦。</p><p>为了避免上述的概率性问题，可以使用下面的做法。</p><h1 id="正确用法"><a href="#正确用法" class="headerlink" title="正确用法"></a>正确用法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//define QMutex and QWaitConditio</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    mutex.<span class="built_in">lock</span>();</span><br><span class="line">    condition.<span class="built_in">wait</span>(&amp;mutex); </span><br><span class="line">    <span class="built_in">render</span>();</span><br><span class="line">    mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据更新线程如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cudaMemCpy</span>(...);</span><br><span class="line"><span class="comment">/* 数据已更新，唤起渲染线程 */</span></span><br><span class="line">mutex.<span class="built_in">lock</span>();</span><br><span class="line">condition.<span class="built_in">wakeAll</span>();</span><br><span class="line">mutex.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近需要将QOpenGL的渲染改为EGL渲染，那么就无法使用Qt提供的条件执行函数update();&lt;br&gt;粗糙的实现方式是 EGL在 wh</summary>
      
    
    
    
    <category term="Qt" scheme="http://example.com/categories/Qt/"/>
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>C++07--模板</title>
    <link href="http://example.com/2025/05/19/C++/C-07-%E6%A8%A1%E6%9D%BF/"/>
    <id>http://example.com/2025/05/19/C++/C-07-%E6%A8%A1%E6%9D%BF/</id>
    <published>2025-05-19T03:00:07.000Z</published>
    <updated>2025-05-19T03:21:19.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、函数模板"><a href="#一、函数模板" class="headerlink" title="一、函数模板"></a>一、函数模板</h1><p>对比函数重载，函数模板只需要通过一次函数定义就可以实现不同参数列表和参数类型的函数重载功能。<br>主要说明 “函数模板具体化” 的例子: 如果要将某一个或某几个要处理的数据类型进行单独处理，需要额外定义对应数据类型的模板函数，形式是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template &lt;&gt; <span class="type">void</span> <span class="title function_">fun</span><span class="params">(type &amp;t)</span>; </span><br></pre></td></tr></table></figure><p>函数模板具体化和普通函数可同时存在，调用顺序为： 普通函数 &gt; 函数模板具体化 &gt; 模板函数，这就类似于在类之外实现“多态”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"> </span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node *next;</span><br><span class="line">    Node(<span class="type">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 模板函数</span></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tfunc</span><span class="params">(T &amp;t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;tT:&quot;</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数模板具体化（用于处理Node类型）</span></span><br><span class="line">template &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tfunc</span><span class="params">(Node &amp;node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;tNode val:&quot;</span> &lt;&lt; node.val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tfunc</span><span class="params">(<span class="type">int</span> &amp;a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;tfunc():&quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">2.1</span>;</span><br><span class="line">    tfunc(a);</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    tfunc(b);</span><br><span class="line">    Node <span class="title function_">node</span><span class="params">(<span class="number">2</span>)</span>;</span><br><span class="line">    tfunc(node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// tT:2.1     </span></span><br><span class="line"><span class="comment">// tfunc():1  </span></span><br><span class="line"><span class="comment">// tNode val:2</span></span><br></pre></td></tr></table></figure><h1 id="二、类模板"><a href="#二、类模板" class="headerlink" title="二、类模板"></a>二、类模板</h1><p>ref: <a href="https://www.cnblogs.com/horacle/p/13701314.html">https://www.cnblogs.com/horacle/p/13701314.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、函数模板&quot;&gt;&lt;a href=&quot;#一、函数模板&quot; class=&quot;headerlink&quot; title=&quot;一、函数模板&quot;&gt;&lt;/a&gt;一、函数模板&lt;/h1&gt;&lt;p&gt;对比函数重载，函数模板只需要通过一次函数定义就可以实现不同参数列表和参数类型的函数重载功能。&lt;br&gt;主要说明</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>EGL无窗口FBO渲染记录</title>
    <link href="http://example.com/2025/05/14/OpenGl/EGL%E6%97%A0%E7%AA%97%E5%8F%A3FBO%E6%B8%B2%E6%9F%93%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2025/05/14/OpenGl/EGL%E6%97%A0%E7%AA%97%E5%8F%A3FBO%E6%B8%B2%E6%9F%93%E8%AE%B0%E5%BD%95/</id>
    <published>2025-05-14T07:56:18.000Z</published>
    <updated>2025-07-23T02:22:04.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>在原先的概念中，无论是openGL还是EGL都是建议在X 或者wayland等窗口上实现的渲染。<br>由于项目中需要动态插拔显示器，甚至要求系统启动后才接入显示器。 这就要求动态创建X或wayland等窗口系统。<br>好在“nvidia显卡xorg多种配置方案” 这篇文章中已经解决了动态X创建的问题。接下来解决的是渲染的问题。</p><h1 id="二、渲染方案"><a href="#二、渲染方案" class="headerlink" title="二、渲染方案"></a>二、渲染方案</h1><h2 id="方案1：使用cuda指针IPC"><a href="#方案1：使用cuda指针IPC" class="headerlink" title="方案1：使用cuda指针IPC"></a>方案1：使用cuda指针IPC</h2><p>这种方式已经在项目中使用，但是缺点也很明显。</p><h3 id="缺点1："><a href="#缺点1：" class="headerlink" title="缺点1："></a>缺点1：</h3><pre><code>一个Cuda device的指针，一旦与openGL的PBO进行注册绑定，那么它将无法作为IPC共享指针。也就是说程序中要创建两个Dev指针，一个用于cuda-opengl-interop, 另一个用于进程间的IPC</code></pre><h3 id="缺点2："><a href="#缺点2：" class="headerlink" title="缺点2："></a>缺点2：</h3><pre><code>由缺点1衍生出来的问题，也就是主程序需要将openGL渲染后的场景(保存在pbo绑定的dev指针)，d2d拷贝到IPC的dev指针中；同理，副程序需要将IPC指针中的场景，拷贝到自身PBO绑定的Dev指针(这样才能更新纹理)。每多一个副程序，就会多两次d2d的cudaMemcpy，在显卡4个显示接口都用满的情况下，对系统性能是一个很大的考验。</code></pre><h2 id="方案2：进程间共享纹理"><a href="#方案2：进程间共享纹理" class="headerlink" title="方案2：进程间共享纹理"></a>方案2：进程间共享纹理</h2><h3 id="具体："><a href="#具体：" class="headerlink" title="具体："></a>具体：</h3><pre><code>这个正是解决了方案1中多次d2d拷贝的问题。只需要在一个主程序中将纹理渲染好，接下来只需要把这个纹理共享出去即可。</code></pre><h3 id="更进一步的想法"><a href="#更进一步的想法" class="headerlink" title="更进一步的想法:"></a>更进一步的想法:</h3><pre><code>考虑到设备使用过程中显示器会被动态插拔(尽管没有哪个人会这么丧心病狂使用设备)。 假设主程序运行在display=:1.0的X窗口上，副程序依次运行在:1.1 、:1.2等窗口上。这时候如果被拔出的正好是:1.0窗口运行的显示器，这时候主程序就可能产生莫名其妙的问题。</code></pre><h3 id="最终确定"><a href="#最终确定" class="headerlink" title="最终确定:"></a>最终确定:</h3><pre><code>可以考虑EGL使用headless方式创建FBO离屏渲染，无需依赖X或Wayland窗口即可渲染出相应的场景。并且EGLImage还能将纹理共享出去。副程序直接获取纹理，绑定渲染即可。这个方案目前已经实现，详情参考gitlab上的代码。</code></pre><h3 id="小局限性"><a href="#小局限性" class="headerlink" title="小局限性:"></a>小局限性:</h3><pre><code>在ubuntu24自带的桌面系统环境下测试测试时，共享EGLimage方式失败。具体原因还不知道。不过使用Xorg创建的X window使用没什么问题。</code></pre><h2 id="方案3：cuda与EGL使用image方式InterOp-然后再将这个纹理共享出去"><a href="#方案3：cuda与EGL使用image方式InterOp-然后再将这个纹理共享出去" class="headerlink" title="方案3：cuda与EGL使用image方式InterOp,然后再将这个纹理共享出去"></a>方案3：cuda与EGL使用image方式InterOp,然后再将这个纹理共享出去</h2><p>在方案2的基础上增加了cuda与EGL通过texture进行interOp, 然后和方案2一样把这个texture转为EglImage共享出去，<br>Cuda数据直接cudaMemcpy2DToArray，主程序连FBO渲染都省了，只需要对egl进行非常简单的初始化，然后创建一个texture。<br>更不会出现下面卡顿的问题。</p><h3 id="方案3局限性"><a href="#方案3局限性" class="headerlink" title="方案3局限性:"></a>方案3局限性:</h3><p>经过进一步测试，方案3在分辨率小于800x600的纹理生效，但对于大尺寸的纹理，尽管没有提示错误，但副屏幕渲染出来是黑的。<br>原因暂时未知。 –20250715</p><h2 id="方案4：多线程初始化EGL渲染"><a href="#方案4：多线程初始化EGL渲染" class="headerlink" title="方案4：多线程初始化EGL渲染"></a>方案4：多线程初始化EGL渲染</h2><p>使用EGL可以和X窗口创建surface，想法是在同一个进程中创建多个进程，分别打开 :1.0 :1.1 :1.2等窗口，然后每个线程分别各自初始化EGL渲染。这样即不必在进程间共享纹理数据。</p><h3 id="方案4局限性"><a href="#方案4局限性" class="headerlink" title="方案4局限性:"></a>方案4局限性:</h3><p>但是从测试结果来看这种做法效果并不理想。主要表现如下：<br>1、虽然多个线程独立渲染，但是屏幕却不是独立实时显示，有的屏出现卡顿等情况。似乎多个X窗口间存在竞态关系。<br>2、使用XSync等函数可以强制每个屏幕输出，但双屏之间还是存在干扰，即屏幕不能按照各自的刷新率进行渲染。</p><h1 id="三、问题记录"><a href="#三、问题记录" class="headerlink" title="三、问题记录"></a>三、问题记录</h1><pre><code>在上述方案2实现的过程中遇到一个非常有趣的问题，FBO渲染结束后，必须要用PBO将渲染的场景glReadPixel读取(尽管没有使用这个读取的结果)，否则副程序就会非常卡顿。具体的原因还有待确定，这也是无意中解决副程序卡顿的问题。最初的现象是：主程序渲染结束后，无论是否调用eglSwapBuffer，副程序渲染都会非常卡，画面几乎不动。 这时候想用PBO将渲染后的场景读取并录制成mp4，查看视频文件是否也卡顿。结果PBO读取后，副程序就非常流畅。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;在原先的概念中，无论是openGL还是EGL都是建议在X 或者wayland等窗口上实现的渲染。&lt;br&gt;由于项目中需要动态插</summary>
      
    
    
    
    <category term="OpenGL" scheme="http://example.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://example.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>nvidia显卡手动创建Wayland窗口配置</title>
    <link href="http://example.com/2025/04/15/ubuntu/nvidia%E6%98%BE%E5%8D%A1%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BAWayland%E7%AA%97%E5%8F%A3%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2025/04/15/ubuntu/nvidia%E6%98%BE%E5%8D%A1%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BAWayland%E7%AA%97%E5%8F%A3%E9%85%8D%E7%BD%AE/</id>
    <published>2025-04-15T07:02:19.000Z</published>
    <updated>2025-08-20T02:07:14.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><h2 id="确认Nvida显卡的card"><a href="#确认Nvida显卡的card" class="headerlink" title="确认Nvida显卡的card"></a>确认Nvida显卡的card</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lufahai@ubuntu24:~$ <span class="built_in">ls</span> /dev/dri/</span><br><span class="line">by-path  card1  card2  renderD128  renderD129</span><br></pre></td></tr></table></figure><p>可以看到系统中有card1 和 card2，分别对应intel集成显卡和nvidia显卡。<br>进一步可以通过下面指令查看是否是nvidia显卡,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lufahai@ubuntu24:~$ udevadm info -a /dev/dri/card2 | grep nvidia</span><br><span class="line">输出：</span><br><span class="line">    DRIVERS==<span class="string">&quot;nvidia&quot;</span></span><br></pre></td></tr></table></figure><h2 id="nvidia显卡需开启modeset"><a href="#nvidia显卡需开启modeset" class="headerlink" title="nvidia显卡需开启modeset"></a>nvidia显卡需开启modeset</h2><p>先验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cat</span> /sys/module/nvidia_drm/parameters/modeset</span><br><span class="line">输出: N</span><br></pre></td></tr></table></figure><p>代表当前显卡并未开启modeset设置，在这种情况下对Nvidia显卡启动weston，会提示错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: DRM device <span class="string">&#x27;card2&#x27;</span> is not a KMS device</span><br></pre></td></tr></table></figure><p>解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/default/grub</span><br><span class="line"></span><br><span class="line">修改cmdline并保存退出:</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">&quot;quiet splash nvidia-drm.modeset=1 nvidia-drm.fbdev=1&quot;</span></span><br><span class="line"></span><br><span class="line">sudo update-grub</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>重启后重新查询&#x2F;sys&#x2F;…&#x2F;modeset,这回输出Y</p><h1 id="查询已连接显示器"><a href="#查询已连接显示器" class="headerlink" title="查询已连接显示器"></a>查询已连接显示器</h1><p>在&#x2F;sys&#x2F;class&#x2F;drm 路径下有所有输出口的连接信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /sys/class/drm/</span><br><span class="line">card1       card1-DP-2   card1-HDMI-A-1  card1-HDMI-A-3  card2       card2-DP-4  card2-HDMI-A-5  renderD129</span><br><span class="line">card1-DP-1  card1-eDP-1  card1-HDMI-A-2  card1-HDMI-A-4  card2-DP-3  card2-DP-5  renderD128      version</span><br></pre></td></tr></table></figure><p>eu<br>上面已确定card2是nvidia显卡，那么先确定card2-HDMI-A-5的连接状态，返回connected</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/class/drm/card2-HDMI-A-5/status</span><br><span class="line">connected</span><br></pre></td></tr></table></figure><p>这就可以确定HDMI接口的名称为HDMI-A-5<br>同理可以确定连接的是哪个DP接口</p><h1 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h1><p>weston.ini</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">backend=drm-backend.so</span><br><span class="line">require-input=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">[output]</span><br><span class="line">name=HDMI-A-1</span><br><span class="line">mode=3840x2160</span><br><span class="line">transform=normal</span><br></pre></td></tr></table></figure><p>额外资料：根据nvidia文档描述，weston启动时会从如下地方一次搜索weston.ini配置文件<br><a href="https://developer.nvidia.com/docs/drive/drive-os/6.0.9/public/drive-os-linux-sdk/common/topics/window_system_stub/WestonConfigurationFileLocation40.html">https://developer.nvidia.com/docs/drive/drive-os/6.0.9/public/drive-os-linux-sdk/common/topics/window_system_stub/WestonConfigurationFileLocation40.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">If <span class="variable">$XDG_CONFIG_HOME</span> is <span class="built_in">set</span>, Weston searches <span class="keyword">in</span>: <span class="variable">$XDG_CONFIG_HOME</span>/weston.ini</span><br><span class="line"></span><br><span class="line">If <span class="variable">$HOME</span> is <span class="built_in">set</span>, Weston searches <span class="keyword">in</span>: <span class="variable">$HOME</span>/.config/weston.ini</span><br><span class="line"></span><br><span class="line">If <span class="variable">$XDG_CONFIG_DIRS</span> is <span class="built_in">set</span>, Weston searches <span class="keyword">in</span>: <span class="variable">$XDG_CONFIG_DIR</span>/weston/weston.ini</span><br><span class="line"></span><br><span class="line">If <span class="variable">$XDG_CONFIG_DIRS</span> is not <span class="built_in">set</span>, Weston searches <span class="keyword">in</span>: /etc/xdg/weston/weston.ini</span><br><span class="line"></span><br><span class="line">If no variables are <span class="built_in">set</span>, Weston searches <span class="keyword">in</span>: &lt;current <span class="built_in">dir</span>&gt;/weston.ini</span><br><span class="line"></span><br><span class="line">Where the environment variable:</span><br><span class="line"><span class="variable">$HOME</span> is your home directory.</span><br><span class="line"><span class="variable">$XDG_CONFIG_HOME</span> is your specific configuration directory.</span><br><span class="line"><span class="variable">$XDG_CONFIG_DIRS</span> is a colon <span class="string">&#x27;:&#x27;</span> delimited list of configuration base directories, such as /etc/xdg-foo:/etc/xdg.</span><br></pre></td></tr></table></figure><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>需要指定XDG_RUNTIME_DIR目录， 启动脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /tmp/.xdg &amp;&amp;  <span class="built_in">chmod</span> 0700 /tmp/.xdg</span><br><span class="line"><span class="built_in">export</span> XDG_RUNTIME_DIR=/tmp/.xdg</span><br><span class="line">weston --drm-device=card2 --renderer=gl</span><br></pre></td></tr></table></figure><p>在tty console终端可以直接启动，不需要sudo权限，即便是nvidia显卡连接了多个显示器，所有已连接的显示器都会创建weston窗口，并且是扩展的方式，鼠标可以在显示器之间的窗口滑动。</p><h1 id="进一步理解"><a href="#进一步理解" class="headerlink" title="进一步理解"></a>进一步理解</h1><h1 id="drm与weston实例对应关系"><a href="#drm与weston实例对应关系" class="headerlink" title="drm与weston实例对应关系"></a>drm与weston实例对应关系</h1><p>一个GPU(intel核显 或 Nvidia显卡)，只能对应地以drm backend方式创建一个weston示例。因为每个GPU对应的是&#x2F;dev&#x2F;dri 目录下的一个card，创建weston的时候通过–drm-device&#x3D;card2 指定使用那个GPU。<br>因此之前的想法：针对显卡的多个显示器创建多个Weston的想法是不对的。</p><h1 id="同一个drm-card下的多个显示器异显"><a href="#同一个drm-card下的多个显示器异显" class="headerlink" title="同一个drm card下的多个显示器异显"></a>同一个drm card下的多个显示器异显</h1><p>主要参考： <a href="https://www.toradex.com/zh-cn/blog/verdin-imx8m-plus-qt5-shuang-ping-xian-shi?srsltid=AfmBOopge_L04NM4Do79U6DuOSF2TTrNhI4iI_KsGCay0LvYmRwHmSki">https://www.toradex.com/zh-cn/blog/verdin-imx8m-plus-qt5-shuang-ping-xian-shi?srsltid=AfmBOopge_L04NM4Do79U6DuOSF2TTrNhI4iI_KsGCay0LvYmRwHmSki</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">idle-time=0 </span><br><span class="line">xwayland=<span class="literal">true</span></span><br><span class="line">repaint-window=16</span><br><span class="line">modules=screen-share.so</span><br><span class="line">shell=kiosk-shell.so</span><br><span class="line"></span><br><span class="line">[output]</span><br><span class="line">name=HDMI-A-1</span><br><span class="line">app-ids=Qt5_CinematicExperience</span><br><span class="line">mode=1920x1080</span><br><span class="line"></span><br><span class="line">[output]</span><br><span class="line">name=HDMI-A-2</span><br><span class="line">app-ids=smarthome</span><br><span class="line">mode=1920x1080</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>app-ids 只能在kiosk下生效，默认的desktop不生效。<br>并且app-ids 不一定就是可执行文件名查找方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WAYLAND_DEBUG=1 ./smarthome 2&gt;&amp;1 | grep app</span><br><span class="line">输出的字符串就是app-ids：</span><br><span class="line">[2173895.185]  -&gt; xdg_toplevel@21.set_app_id(<span class="string">&quot;smarthome&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><p>在nvidia显卡上暂时还测试不出来，参考文章用的是Arm板子</p><h2 id="进展250428"><a href="#进展250428" class="headerlink" title="进展250428"></a>进展250428</h2><p>使用kiosk方式创建窗口后，EGL程序通过下面指定，EGL就能通过supervisor在显示器上渲染。<br>mWlDisplay &#x3D; wl_display_connect(“wayland-1”);</p><p>但，双屏下还是合并的。 可以进一步研究通过配置不同的seat，从而启动多个Weston,<br>这样就有多个wayland-x, 这样每个渲染程序就能对应找到自己需要渲染的显示器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h1&gt;&lt;h2 id=&quot;确认Nvida显卡的card&quot;&gt;&lt;a href=&quot;#确认Nvida显卡的card&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="ubuntu系统" scheme="http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="ubuntu系统" scheme="http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>opencl引入主机内存字节对齐问题</title>
    <link href="http://example.com/2025/04/08/openCL/opencl%E5%BC%95%E5%85%A5%E4%B8%BB%E6%9C%BA%E5%86%85%E5%AD%98%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2025/04/08/openCL/opencl%E5%BC%95%E5%85%A5%E4%B8%BB%E6%9C%BA%E5%86%85%E5%AD%98%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/</id>
    <published>2025-04-08T01:21:47.000Z</published>
    <updated>2025-09-09T08:18:58.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主机内存拷贝到openCL内存"><a href="#主机内存拷贝到openCL内存" class="headerlink" title="主机内存拷贝到openCL内存"></a>主机内存拷贝到openCL内存</h1><h2 id="方式1："><a href="#方式1：" class="headerlink" title="方式1："></a>方式1：</h2><p>定义cl_mem的时候设置Flag | CL_MEM_ALLOC_HOST_PTR</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> size = mWidth * mHeight * <span class="number">4</span>;</span><br><span class="line">cl_mem srcBuf = clCreateBuffer(mContext, CL_MEM_READ_ONLY | CL_MEM_ALLOC_HOST_PTR, size, <span class="literal">NULL</span>, &amp;err);</span><br></pre></td></tr></table></figure><p>这样主机内存拷贝到opencl内存的时候就可以使用map方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *srcPtr = clEnqueueMapBuffer(mQueue, srcBuf, CL_FALSE, CL_MAP_WRITE, <span class="number">0</span>, size, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (srcPtr) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(srcPtr, *buf, size);</span><br><span class="line">    clEnqueueUnmapMemObject(mQueue, srcBuf, srcPtr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式比直接写的方式效率更高。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enqueueWriteBuffer(*mBufSrc, CL_FALSE, <span class="number">0</span>, mImgHalfSize, mVecSrc.data());</span><br></pre></td></tr></table></figure><h2 id="方式2："><a href="#方式2：" class="headerlink" title="方式2："></a>方式2：</h2><p>openCL直接引入主机内存可以避免上步骤的内存拷贝<br>前提是要查询openCL是否支持引入host内存的扩展。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cl_arm_import_memory </span><br><span class="line">cl_arm_import_memory_dma_buf </span><br><span class="line">cl_arm_import_memory_host </span><br><span class="line">cl_arm_import_memory_protected </span><br><span class="line">cl_arm_import_memory_android_hardware_buffer</span><br></pre></td></tr></table></figure><p>测试1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> imgSize = mImgWidth * mImgHeight * <span class="number">3</span> / <span class="number">2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* imgBuf = <span class="built_in">malloc</span>(imgSize);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> cl_import_properties_arm importProperties[] = &#123;</span><br><span class="line">    CL_IMPORT_TYPE_ARM,</span><br><span class="line">    CL_IMPORT_TYPE_HOST_ARM, <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">cl_int imRet = CL_SUCCESS;</span><br><span class="line">cl_mem mSrcBuf = clImportMemoryARM(mContext, CL_MEM_READ_WRITE, importProperties, imgBuf, imgSize, &amp;imRet);</span><br><span class="line"><span class="keyword">if</span> (imRet != CL_SUCCESS) &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;failed to import host memory: &quot;</span> &lt;&lt; imRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时程序返回的是-6，具体意思是out of host memory.</p><p>解决参考</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//stackoverflow.com/questions/78786585/climportmemoryarm-opencl-sometime-return-error-6</span></span><br></pre></td></tr></table></figure><p>简单来说就是内存对齐问题，直接通过malloc申请的内存无法保证内存字节对齐。<br>解决如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arm64 OS */</span></span><br><span class="line"><span class="type">size_t</span> imgSize = mImgWidth * mImgHeight * <span class="number">3</span> / <span class="number">2</span>;</span><br><span class="line">posix_memalign((<span class="type">void</span>**)&amp;imgBuf, <span class="number">64</span>, imgSize);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> cl_import_properties_arm importProperties[] = &#123;</span><br><span class="line">    CL_IMPORT_TYPE_ARM,</span><br><span class="line">    CL_IMPORT_TYPE_HOST_ARM, <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">cl_int imRet = CL_SUCCESS;</span><br><span class="line">cl_mem mSrcBuf = clImportMemoryARM(mContext, CL_MEM_READ_WRITE, importProperties, imgBuf, imgSize, &amp;imRet);</span><br><span class="line"><span class="keyword">if</span> (imRet != CL_SUCCESS) &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;failed to import host memory: &quot;</span> &lt;&lt; imRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式3-dmaBuf-："><a href="#方式3-dmaBuf-：" class="headerlink" title="方式3(dmaBuf)："></a>方式3(dmaBuf)：</h2><p>尽管方式2解决了从host memory到opencl buf的拷贝，但是前提是v4l2的图像数据要提前拷贝到这个hostMemory中。<br>最近接触到v4l2可以使用dmaBuf的方式获取视频数据，因此产生一个想法。提前分配好dmaBuf作为v4l2Buf传入队列中，<br>这样就可以避免dqBuf后，还要将数据拷贝到hostMemory中。<br>具体如下：</p><p>1、V4L2端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* allocate dmaBuf */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_buffers; i++) &#123;</span><br><span class="line">    dmabuf_fds[i] = dmabuf_heap_alloc(dmabuf_heap_fd, <span class="literal">NULL</span>, pix_fmt.sizeimage);</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* enque dmabufs into v4l2 device */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_buffers; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_plane</span> <span class="title">planes</span>[<span class="title">VIDEO_MAX_PLANES</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    buf.index = i;</span><br><span class="line">    buf.memory = V4L2_MEMORY_DMABUF;</span><br><span class="line">    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    buf.m.fd = dmabuf_fds[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ioctl(v4l2_fd, VIDIOC_QBUF, &amp;buf)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;VIDIOC_QBUF: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> exit_cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、openCL端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cl_mem bufArray[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> cl_import_properties_arm importProperties[] = &#123;</span><br><span class="line">    CL_IMPORT_TYPE_ARM,</span><br><span class="line">    CL_IMPORT_TYPE_DMA_BUF_ARM, <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_buffers; i++) &#123; </span><br><span class="line">    bufArray[i] = clImportMemoryARM(ctx, CL_MEM_READ_WRITE, importProperties,</span><br><span class="line">                        &amp;dmabuf_fds[i], sizeimage,  &amp;error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样v4l2在驱动层就可以把图像数据直接更新到dmaBuf，openCL可以直接获取。 避免内存拷贝到hostMemory.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://registry.khronos.org/OpenCL/extensions/arm/cl_arm_import_memory.txt">https://registry.khronos.org/OpenCL/extensions/arm/cl_arm_import_memory.txt</a></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在arm平台上使用import host的方式，效率最高，因为第一种方式还要map才能复制。<br>但是就一般性而言，第一种方式对其他平台兼容性更好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;主机内存拷贝到openCL内存&quot;&gt;&lt;a href=&quot;#主机内存拷贝到openCL内存&quot; class=&quot;headerlink&quot; title=&quot;主机内存拷贝到openCL内存&quot;&gt;&lt;/a&gt;主机内存拷贝到openCL内存&lt;/h1&gt;&lt;h2 id=&quot;方式1：&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="openCL" scheme="http://example.com/categories/openCL/"/>
    
    
    <category term="openCL" scheme="http://example.com/tags/openCL/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu24解决chrome-sandbox权限导致app无法启动问题</title>
    <link href="http://example.com/2025/04/02/ubuntu/ubuntu24%E8%A7%A3%E5%86%B3chrome-sandbox%E6%9D%83%E9%99%90%E5%AF%BC%E8%87%B4app%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2025/04/02/ubuntu/ubuntu24%E8%A7%A3%E5%86%B3chrome-sandbox%E6%9D%83%E9%99%90%E5%AF%BC%E8%87%B4app%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/</id>
    <published>2025-04-02T03:19:51.000Z</published>
    <updated>2025-04-02T03:23:59.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><p>安装了新版本的ubuntu24，之前的clash软件启动后提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[42711:0402/111553.491149:FATAL:setuid_sandbox_host.cc(157)] The SUID sandbox helper binary was found, but is not configured correctly. Rather than run without sandboxing I<span class="string">&#x27;m aborting now. You need to make sure that /opt/clash/chrome-sandbox is owned by root and has mode 4755.</span></span><br></pre></td></tr></table></figure><p>程序无法启动。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>根据提示先chown再chmod，分两步进行，但不生效。最后发现要&amp;&amp;并作一条指令才生效，令人匪夷所思。</p><p>正解如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> root /opt/clash/chrome-sandbox &amp;&amp; sudo <span class="built_in">chmod</span> 4755 /opt/clash/chrome-sandbox</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题来源&quot;&gt;&lt;a href=&quot;#问题来源&quot; class=&quot;headerlink&quot; title=&quot;问题来源&quot;&gt;&lt;/a&gt;问题来源&lt;/h1&gt;&lt;p&gt;安装了新版本的ubuntu24，之前的clash软件启动后提示&lt;/p&gt;
&lt;figure class=&quot;highlight b</summary>
      
    
    
    
    <category term="ubuntu系统" scheme="http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="ubuntu系统" scheme="http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux打印机使用总结</title>
    <link href="http://example.com/2025/04/01/ubuntu/Linux%E6%89%93%E5%8D%B0%E6%9C%BA%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2025/04/01/ubuntu/Linux%E6%89%93%E5%8D%B0%E6%9C%BA%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2025-04-01T08:59:42.000Z</published>
    <updated>2025-04-08T01:23:09.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图形界面使用"><a href="#图形界面使用" class="headerlink" title="图形界面使用"></a>图形界面使用</h1><pre><code>直接在设置页面添加即可。</code></pre><h1 id="命令行配合Qt程序使用"><a href="#命令行配合Qt程序使用" class="headerlink" title="命令行配合Qt程序使用"></a>命令行配合Qt程序使用</h1><h2 id="查找打印机"><a href="#查找打印机" class="headerlink" title="查找打印机"></a>查找打印机</h2><p>打印机使用USB方式连接到电脑，通过以下命令查询，注意加sudo权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stephen@localhost:~$ sudo lpinfo -v</span><br><span class="line">file cups-brf:/</span><br><span class="line">network beh</span><br><span class="line">network socket</span><br><span class="line">network ipp</span><br><span class="line">network http</span><br><span class="line">network https</span><br><span class="line">network lpd</span><br><span class="line">network ipps</span><br><span class="line">serial serial:/dev/ttyS0?baud=115200</span><br><span class="line">direct usb://HP/LaserJet%20M203-M206?serial=VNC3J55865</span><br></pre></td></tr></table></figure><p>最后一个usb:&#x2F;&#x2F;HP…就是USB连接的惠普打印机。</p><h2 id="增加打印机"><a href="#增加打印机" class="headerlink" title="增加打印机"></a>增加打印机</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lpadmin -p HP_LaserJet -v usb://HP/LaserJet%20M203-M206?serial=VNC3J55865 -E</span><br></pre></td></tr></table></figure><p>-p 后面是自定义的打印机名称<br>-v 后面是上一步查看到的地址</p><p>这时候使用下面指令就可以查看到已经添加的打印机了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lpstat -v</span><br></pre></td></tr></table></figure><h2 id="设置为默认"><a href="#设置为默认" class="headerlink" title="设置为默认"></a>设置为默认</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lpadmin -d HP_LaserJet</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lp a.pdf -d HP_LaserJet</span><br></pre></td></tr></table></figure><p>可以打印，但不知道为什么，上一步设为默认打印机后，使用lp指令要-d指定打印机，否则打印失败。<br>但是对于Qt程序可以直接识别到上步设置的默认打印机，因此没太纠结。</p><h2 id="Qt参考程序"><a href="#Qt参考程序" class="headerlink" title="Qt参考程序"></a>Qt参考程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QPrinter printerPixmap;</span><br><span class="line">QPixmap pixmap = QPixmap::grabWidget(ui-&gt;lab_img, ui-&gt;lab_img-&gt;rect());  <span class="comment">//获取界面的图片</span></span><br><span class="line">printerPixmap.setOrientation(QPrinter::Landscape);<span class="comment">//纵向：Portrait 横向：Landscape</span></span><br><span class="line">printerPixmap.setPageSize(QPrinter::A4);<span class="comment">//设置纸张大小</span></span><br><span class="line">QPainter painterPixmap;</span><br><span class="line">painterPixmap.begin(&amp;printerPixmap);</span><br><span class="line">painterPixmap.scale(<span class="number">1</span>, <span class="number">1</span>);<span class="comment">//设置图像长宽是原图的多少倍</span></span><br><span class="line">painterPixmap.drawPixmap(<span class="number">300</span>, <span class="number">300</span> , pixmap);<span class="comment">//设置图像在A4中的开始坐标是什么</span></span><br><span class="line">painterPixmap.end();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图形界面使用&quot;&gt;&lt;a href=&quot;#图形界面使用&quot; class=&quot;headerlink&quot; title=&quot;图形界面使用&quot;&gt;&lt;/a&gt;图形界面使用&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;直接在设置页面添加即可。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;命令行配合Qt程序使用</summary>
      
    
    
    
    <category term="ubuntu系统" scheme="http://example.com/categories/ubuntu%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="ubuntu系统" scheme="http://example.com/tags/ubuntu%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>关于armLinux openCL与EGL互操作的探究--基于rockchip</title>
    <link href="http://example.com/2025/03/28/armLinux/%E5%85%B3%E4%BA%8EarmLinux-openCL%E4%B8%8EEGL%E4%BA%92%E6%93%8D%E4%BD%9C%E7%9A%84%E6%8E%A2%E7%A9%B6-%E5%9F%BA%E4%BA%8Erockchip/"/>
    <id>http://example.com/2025/03/28/armLinux/%E5%85%B3%E4%BA%8EarmLinux-openCL%E4%B8%8EEGL%E4%BA%92%E6%93%8D%E4%BD%9C%E7%9A%84%E6%8E%A2%E7%A9%B6-%E5%9F%BA%E4%BA%8Erockchip/</id>
    <published>2025-03-28T08:45:16.000Z</published>
    <updated>2025-06-03T02:03:39.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>希望在Linux环境下使用mali GPU来对图像进行处理及显示，主要包括三个方面：<br>1、图像采集；2、图像处理；3、图像显示。<br>其中1和3都已被优化解决，唯独2暂时没优化到最理想的效果。</p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>图像采集可以使用mjpg硬件解码，可以获得高分辨下的较高帧率，基本满足。<br>图像渲染可以用openGL渲染，但考虑到交互和移植问题，使用了EGL渲染，不依赖X11或wayland,渲染效率更高。</p><p>图像处理使用的是openCL，可以很好的完成基本的图像处理。但目前瓶颈在于图像需要从CPU拷贝到GPU，最后再拷贝会CPU交给EGL渲染。<br>虽说做了一次优化：使用openCL定义buf的时候直接使用host memory的指针，即zero-copy，最后再交由egl渲染。 效果还不错。</p><h1 id="方案1："><a href="#方案1：" class="headerlink" title="方案1："></a>方案1：</h1><p>不依赖任何图形界面，直接由Qt集成的opengl进行渲染，获得的视频数据直接gliamge2d交给openGL去渲染。唯一的不足是后期的处理全靠glsl实现。<br>在rk3566上测试效果还是很不错的。</p><h1 id="方案2："><a href="#方案2：" class="headerlink" title="方案2："></a>方案2：</h1><p>在wayland界面下使用dmabuf作为桥梁，可以实现EGL创建一个eglImage, 然后opencl利用这个eglImage创建出关联的oclImage, 测试中发现oclImage只能对EGLimage内存进行<br>写入操作，而无法读取。也就是这个oclImage传给kernel时只能声明为 __write_only image2d_t的方式。opencl对image进行写入后，EGL也会被同样修改，随后egl就可以直接渲染，没有任何拷贝。</p><p>但是从eglImage到oclImage仍存在一个问题，只能写入不能读取，即eglImage只能作为目标输出dstPtr.<br>为了解决视频流输出的问题，arm提供了opencl引入host内存的扩展: clImportMemoryARM。<br>也就是存有图像数据的hostMem可以直接给opencl使用，避免了内存拷贝问题。</p><p>至此彻底解决内存拷贝问题。</p><h1 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h1><p>在weston.ini可以类似nvidia将屏幕配置成8 Bit或10 Bit,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line"><span class="comment"># xrgb8888|rgb565|xrgb2101010</span></span><br><span class="line">gbm-format=xrgb2101010</span><br></pre></td></tr></table></figure><p>也可以针对屏幕某个屏幕设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[output]</span><br><span class="line"><span class="comment"># output 的 name 可以查看 /sys/class/drm/card0-name</span></span><br><span class="line">name=HDMI-A-1</span><br><span class="line"><span class="comment"># xrgb8888|rgb565|xrgb2101010</span></span><br><span class="line">gbm-format=xrgb2101010</span><br></pre></td></tr></table></figure><p>主要参考，特别要注意一些Linux环境下使用的细节<br><a href="https://registry.khronos.org/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import.txt">https://registry.khronos.org/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import.txt</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;希望在Linux环境下使用mali GPU来对图像进行处理及显示，主要包括三个方面：&lt;br&gt;1、图像采集；2、图像处理；3、图像显示。&lt;br</summary>
      
    
    
    
    <category term="armLinux" scheme="http://example.com/categories/armLinux/"/>
    
    
    <category term="armLinux" scheme="http://example.com/tags/armLinux/"/>
    
  </entry>
  
</feed>
